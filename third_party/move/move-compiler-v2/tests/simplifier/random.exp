// ---- Model Dump
module 0x8675::M {
    struct S {
        f: u64,
        g: u64,
    }
    private fun id<T>(r: &#0): &#0 {
        r
    }
    private fun id_mut<T>(r: &mut #0): &mut #0 {
        r
    }
    private fun t0() {
        {
          let v: u64 = 0;
          {
            let x: &mut u64 = Borrow(Mutable)(v);
            {
              let y: &mut u64 = Borrow(Mutable)(v);
              Deref(x);
              Deref(y);
              if Eq<u64>(v, 0) {
                v: u64 = 3;
                Tuple()
              } else {
                v: u64 = 2;
                Tuple()
              };
              {
                let x$0$: &mut u64 = M::id_mut<u64>(Borrow(Mutable)(v));
                {
                  let y$0$: &mut u64 = Borrow(Mutable)(v);
                  Deref(x$0$);
                  Deref(y$0$);
                  {
                    let x$1$: &u64 = Borrow(Immutable)(v);
                    {
                      let y$1$: &mut u64 = Borrow(Mutable)(v);
                      Deref(y$1$);
                      Deref(x$1$);
                      Deref(y$1$);
                      {
                        let x$2$: &u64 = Borrow(Immutable)(v);
                        {
                          let y$2$: &u64 = Borrow(Immutable)(v);
                          Deref(x$2$);
                          Deref(y$2$);
                          Deref(x$2$);
                          {
                            let x$3$: &u64 = M::id<u64>(Borrow(Immutable)(v));
                            {
                              let y$3$: &u64 = Borrow(Immutable)(v);
                              Deref(x$3$);
                              Deref(y$3$);
                              Deref(x$3$);
                              Tuple()
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun test1(r: u64): u64 {
        loop {
          if Gt<u64>(r, 0) {
            r: u64 = Sub<u64>(r, 1);
            Tuple()
          } else {
            break
          }
        };
        {
          let t2: u64 = Add<u64>(r, r);
          t2
        }
    }
    spec fun $id<T>(r: #0): #0 {
        r
    }
    spec fun $id_mut<T>(r: #0): #0 {
        r
    }
    spec fun $t0();
    spec fun $test1(r: u64): u64;
} // end 0x8675::M


Diagnostics:
error: cannot mutably borrow local `v` since other references exists
   ┌─ tests/simplifier/random.move:22:17
   │
21 │         let x = &mut v;
   │                 ------ previous mutable local borrow
22 │         let y = &mut v; // error in v2
   │                 ^^^^^^ mutable borrow attempted here

error: cannot mutably borrow local `v` since other references exists
   ┌─ tests/simplifier/random.move:33:17
   │
32 │         let x = id_mut(&mut v);
   │                        ------ previous mutable local borrow
33 │         let y = &mut v; // error in v2
   │                 ^^^^^^ mutable borrow attempted here

error: cannot mutably borrow local `v` since other references exists
   ┌─ tests/simplifier/random.move:38:17
   │
37 │         let x = &v;
   │                 -- previous local borrow
38 │         let y = &mut v;
   │                 ^^^^^^ mutable borrow attempted here
