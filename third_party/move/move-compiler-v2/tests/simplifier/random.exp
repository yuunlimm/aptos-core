// ---- Model Dump
module 0x8675::M {
    struct S {
        f: u64,
        g: u64,
    }
    private fun id<T>(r: &#0): &#0 {
        r
    }
    private fun id_mut<T>(r: &mut #0): &mut #0 {
        r
    }
    private fun t0() {
        {
          let v: u64 = 0;
          {
            let x: &mut u64 = Borrow(Mutable)(v);
            {
              let y: &mut u64 = Borrow(Mutable)(v);
              Deref(x);
              Deref(y);
              if Eq<u64>(v, 0) {
                v: u64 = 3;
                Tuple()
              } else {
                v: u64 = 2;
                Tuple()
              };
              {
                let q: u64 = v;
                {
                  let x: &mut u64 = M::id_mut<u64>(Borrow(Mutable)(v));
                  {
                    let y: &mut u64 = Borrow(Mutable)(v);
                    Deref(x);
                    Deref(y);
                    {
                      let x: &u64 = Borrow(Immutable)(v);
                      {
                        let y: &mut u64 = Borrow(Mutable)(v);
                        Deref(y);
                        Deref(x);
                        Deref(y);
                        {
                          let x: &u64 = Borrow(Immutable)(v);
                          {
                            let y: &u64 = Borrow(Immutable)(v);
                            Deref(x);
                            Deref(y);
                            Deref(x);
                            {
                              let x: &u64 = M::id<u64>(Borrow(Immutable)(v));
                              {
                                let y: &u64 = Borrow(Immutable)(v);
                                Deref(x);
                                Deref(y);
                                Deref(x);
                                Tuple()
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun test1(r: u64): u64 {
        {
          let t: u64 = r;
          loop {
            if Gt<u64>(r, 0) {
              r: u64 = Sub<u64>(r, 1);
              Tuple()
            } else {
              break
            }
          };
          {
            let t2: u64 = Add<u64>(r, t);
            t2
          }
        }
    }
    spec fun $id<T>(r: #0): #0 {
        r
    }
    spec fun $id_mut<T>(r: #0): #0 {
        r
    }
    spec fun $t0();
    spec fun $test1(r: u64): u64;
} // end 0x8675::M


Diagnostics:
error: cannot mutably borrow local `v` since other references exists
   ┌─ tests/simplifier/random.move:22:17
   │
21 │         let x = &mut v;
   │                 ------ previous mutable local borrow
22 │         let y = &mut v; // error in v2
   │                 ^^^^^^ mutable borrow attempted here

error: cannot mutably borrow local `v` since other references exists
   ┌─ tests/simplifier/random.move:33:17
   │
32 │         let x = id_mut(&mut v);
   │                        ------ previous mutable local borrow
33 │         let y = &mut v; // error in v2
   │                 ^^^^^^ mutable borrow attempted here

error: cannot mutably borrow local `v` since other references exists
   ┌─ tests/simplifier/random.move:38:17
   │
37 │         let x = &v;
   │                 -- previous local borrow
38 │         let y = &mut v;
   │                 ^^^^^^ mutable borrow attempted here
