// ---- Model Dump
module 0x8675::M {
    struct S {
        f: u64,
        g: u64,
    }
    private fun id<T>(r: &#0): &#0 {
        r
    }
    private fun id_mut<T>(r: &mut #0): &mut #0 {
        r
    }
    private fun t0() {
        {
          let v: u64 = 0;
          {
            let x: &mut u64 = Borrow(Mutable)(v);
            {
              let y: &mut u64 = Borrow(Mutable)(v);
              Deref(x);
              Deref(y);
              if Eq<u64>(v, 0) {
                v: u64 = 3;
                Tuple()
              } else {
                v: u64 = 2;
                Tuple()
              };
              {
                let x$0$: &mut u64 = M::id_mut<u64>(Borrow(Mutable)(v));
                {
                  let y$0$: &mut u64 = Borrow(Mutable)(v);
                  Deref(x$0$);
                  Deref(y$0$);
                  {
                    let x$1$: &u64 = Borrow(Immutable)(v);
                    {
                      let y$1$: &mut u64 = Borrow(Mutable)(v);
                      Deref(y$1$);
                      Deref(x$1$);
                      Deref(y$1$);
                      {
                        let x$2$: &u64 = Borrow(Immutable)(v);
                        {
                          let y$2$: &u64 = Borrow(Immutable)(v);
                          Deref(x$2$);
                          Deref(y$2$);
                          Deref(x$2$);
                          {
                            let x$3$: &u64 = M::id<u64>(Borrow(Immutable)(v));
                            {
                              let y$3$: &u64 = Borrow(Immutable)(v);
                              Deref(x$3$);
                              Deref(y$3$);
                              Deref(x$3$);
                              Tuple()
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
    }
    private fun test1(r: u64): u64 {
        {
          let t2: u64 = 0;
          loop {
            if Gt<u64>(r, 0) {
              r: u64 = Sub<u64>(r, 1);
              t2: u64 = Add<u64>(t2, r);
              Tuple()
            } else {
              break
            }
          };
          {
            let t3: u64 = Add<u64>(Add<u64>(r, r), t2);
            t3
          }
        }
    }
    private fun test1a(x: u64,r: &u64): u64 {
        {
          let t: u64 = Deref(r);
          {
            let t3: u64 = {
              let (x: u64, _) = Tuple(x, r);
              {
                let r: u64 = Add<u64>(x, 3);
                loop {
                  if Gt<u64>(x, 0) {
                    x: u64 = Sub<u64>(x, Deref(r));
                    Tuple()
                  } else {
                    break
                  }
                };
                Add<u64>(r, x)
              }
            };
            {
              let t2: u64 = Add<u64>(Deref(r), t);
              Add<u64>(Add<u64>(t2, t3), t)
            }
          }
        }
    }
    spec fun $id<T>(r: #0): #0 {
        r
    }
    spec fun $id_mut<T>(r: #0): #0 {
        r
    }
    spec fun $iterloop(x: u64,y: &u64): u64;
    spec fun $t0();
    spec fun $test1(r: u64): u64;
    spec fun $test1a(x: u64,r: &u64): u64;
} // end 0x8675::M


Diagnostics:
error: cannot mutably borrow local `v` since other references exists
   ┌─ tests/simplifier/random.move:40:17
   │
39 │         let x = &mut v;
   │                 ------ previous mutable local borrow
40 │         let y = &mut v; // error in v2
   │                 ^^^^^^ mutable borrow attempted here

error: cannot mutably borrow local `v` since other references exists
   ┌─ tests/simplifier/random.move:51:17
   │
50 │         let x = id_mut(&mut v);
   │                        ------ previous mutable local borrow
51 │         let y = &mut v; // error in v2
   │                 ^^^^^^ mutable borrow attempted here

error: cannot mutably borrow local `v` since other references exists
   ┌─ tests/simplifier/random.move:56:17
   │
55 │         let x = &v;
   │                 -- previous local borrow
56 │         let y = &mut v;
   │                 ^^^^^^ mutable borrow attempted here
