+ cargo test -p move-compiler-v2 -p move-compiler-v2-transactional-tests -p move-compiler -p move-compiler-transactional-tests inline_fun
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/move_compiler-f77af380031b68fd)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

     Running unittests src/bin/move-build.rs (target/debug/deps/move_build-7ba1c4232b64d9ec)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

     Running unittests src/bin/move-check.rs (target/debug/deps/move_check-f627d0e980b0662e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

     Running tests/move_check_testsuite.rs (target/debug/deps/move_check_testsuite-5ebf5b9d0c8cf6f0)

running 1 test
Before expansion: program = ------ Lib Defs: ------
no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::ascii {
    use std::vector;use std::option:: {
        Self, Option
    };const EINVALID_ASCII_CHARACTER:u64 = 0x10000;copy drop storestruct String {
        bytes: vector<u8>
    }spec String{invariant forall i in 0 .. len(bytes) : is_valid_char(bytes[i])}copy drop storestruct Char {
        byte: u8
    }spec Char{invariant is_valid_char(byte)}public fun char(byte: u8): Char {
        assert!(is_valid_char(byte), EINVALID_ASCII_CHARACTER);
        Char{byte: byte}
    }spec char{aborts_if ! is_valid_char(byte)EINVALID_ASCII_CHARACTER}public fun string(bytes: vector<u8>): String {
        let x = try_string(bytes);
        assert!(option::is_some(&x), EINVALID_ASCII_CHARACTER);
        option::destroy_some(x)
    }spec string{aborts_if exists i in 0 .. len(bytes) : ! is_valid_char(bytes[i])EINVALID_ASCII_CHARACTER}public fun try_string(bytes: vector<u8>): Option<String> {
        let len = vector::length(&bytes);
        let i = 0;
        while ( {
            spec {spec {invariant i <= len;
            invariant forall j in 0 .. i : is_valid_char(bytes[j])}};
            i < len
        }) {
            let possible_byte = *vector::borrow(&bytes, i);
            if (! is_valid_char(possible_byte)) return option::none();
            i = i + 1;

        };
        spec {spec {assert i == len;
        assert forall j in 0 .. len : is_valid_char(bytes[j])}};
        option::some(String{bytes: bytes})
    }public fun all_characters_printable(string: &String): bool {
        let len = vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec {spec {invariant i <= len;
            invariant forall j in 0 .. i : is_printable_char(string.bytes[j])}};
            i < len
        }) {
            let byte = *vector::borrow(&string.bytes, i);
            if (! is_printable_char(byte)) return false;
            i = i + 1;

        };
        spec {spec {assert i == len;
        assert forall j in 0 .. len : is_printable_char(string.bytes[j])}};
        true
    }spec all_characters_printable{ensures result ==> forall j in 0 .. len(string.bytes) : is_printable_char(string.bytes[j])}public fun push_char(string: &mut String, char: Char): () {
        vector::push_back(&mut string.bytes, char.byte);

    }spec push_char{ensures len(string.bytes) == len(old(string.bytes)) + 1}public fun pop_char(string: &mut String): Char {
        Char{byte: vector::pop_back(&mut string.bytes)}
    }spec pop_char{ensures len(string.bytes) == len(old(string.bytes)) - 1}public fun length(string: &String): u64 {
        vector::length(as_bytes(string))
    }public fun as_bytes(string: &String): &vector<u8> {
        &string.bytes
    }public fun into_bytes(string: String): vector<u8> {
        let String{bytes: bytes} = string;
        bytes
    }public fun byte(char: Char): u8 {
        let Char{byte: byte} = char;
        byte
    }public fun is_valid_char(b: u8): bool {
        b <= 0x7F
    }public fun is_printable_char(byte: u8): bool {
        byte >= 0x20 && byte <= 0x7E
    }
}no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::bcs {
    public native fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;
    spec module {}spec module {native fun serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }
}no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::bit_vector {
    use std::vector;const EINDEX:u64 = 0x20000;const ELENGTH:u64 = 0x20001;const WORD_SIZE:u64 = 1;const MAX_SIZE:u64 = 1024;copy drop storestruct BitVector {
        length: u64;
        bit_field: vector<bool>
    }public fun new(length: u64): BitVector {
        assert!(length > 0, ELENGTH);
        assert!(length < MAX_SIZE, ELENGTH);
        let counter = 0;
        let bit_field = vector::empty();
        while ( {
            spec {spec {invariant counter <= length;
            invariant len(bit_field) == counter}};
            counter < length
        }) {
            vector::push_back(&mut bit_field, false);
            counter = counter + 1;

        };
        spec {spec {assert counter == length;
        assert len(bit_field) == length}};
        BitVector{length: length, bit_field: bit_field}
    }spec new{include NewAbortsIf;
    ensures result.length == length;
    ensures len(result.bit_field) == length}spec schema NewAbortsIf{locallength: u64;
    aborts_if length <= 0ELENGTH;
    aborts_if length >= MAX_SIZEELENGTH}public fun set(bitvector: &mut BitVector, bit_index: u64): () {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;

    }spec set{include SetAbortsIf;
    ensures bitvector.bit_field[bit_index]}spec schema SetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}public fun unset(bitvector: &mut BitVector, bit_index: u64): () {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;

    }spec unset{include UnsetAbortsIf;
    ensures ! bitvector.bit_field[bit_index]}spec schema UnsetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}public fun shift_left(bitvector: &mut BitVector, amount: u64): () {
        if (amount >= bitvector.length)  {
            let len = vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;

            };

        } else  {
            let i = amount;
            while (i < bitvector.length) {
                if (is_index_set(bitvector, i)) set(bitvector, i - amount) else unset(bitvector, i - amount);
                i = i + 1;

            };
            i = bitvector.length - amount;
            while (i < bitvector.length) {
                unset(bitvector, i);
                i = i + 1;

            };

        }
    }public fun is_index_set(bitvector: &BitVector, bit_index: u64): bool {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        *vector::borrow(&bitvector.bit_field, bit_index)
    }spec is_index_set{include IsIndexSetAbortsIf;
    ensures result == bitvector.bit_field[bit_index]}spec schema IsIndexSetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}spec module {fun spec_is_index_set(bitvector: BitVector, bit_index: u64): bool {
        if (bit_index >= length(bitvector))  {
            false
        } else  {
            bitvector.bit_field[bit_index]
        }
    }}public fun length(bitvector: &BitVector): u64 {
        vector::length(&bitvector.bit_field)
    }public fun longest_set_sequence_starting_at(bitvector: &BitVector, start_index: u64): u64 {
        assert!(start_index < bitvector.length, EINDEX);
        let index = start_index;
        while (index < bitvector.length) {
            if (! is_index_set(bitvector, index)) break;
            index = index + 1;

        };
        index - start_index
    }
}no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::error {
    const INVALID_ARGUMENT:u64 = 0x1;const OUT_OF_RANGE:u64 = 0x2;const INVALID_STATE:u64 = 0x3;const UNAUTHENTICATED:u64 = 0x4;const PERMISSION_DENIED:u64 = 0x5;const NOT_FOUND:u64 = 0x6;const ABORTED:u64 = 0x7;const ALREADY_EXISTS:u64 = 0x8;const RESOURCE_EXHAUSTED:u64 = 0x9;const CANCELLED:u64 = 0xA;const INTERNAL:u64 = 0xB;const NOT_IMPLEMENTED:u64 = 0xC;const UNAVAILABLE:u64 = 0xD;public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }public fun invalid_argument(r: u64): u64 {
        canonical(INVALID_ARGUMENT, r)
    }public fun out_of_range(r: u64): u64 {
        canonical(OUT_OF_RANGE, r)
    }public fun invalid_state(r: u64): u64 {
        canonical(INVALID_STATE, r)
    }public fun unauthenticated(r: u64): u64 {
        canonical(UNAUTHENTICATED, r)
    }public fun permission_denied(r: u64): u64 {
        canonical(PERMISSION_DENIED, r)
    }public fun not_found(r: u64): u64 {
        canonical(NOT_FOUND, r)
    }public fun aborted(r: u64): u64 {
        canonical(ABORTED, r)
    }public fun already_exists(r: u64): u64 {
        canonical(ALREADY_EXISTS, r)
    }public fun resource_exhausted(r: u64): u64 {
        canonical(RESOURCE_EXHAUSTED, r)
    }public fun internal(r: u64): u64 {
        canonical(INTERNAL, r)
    }public fun not_implemented(r: u64): u64 {
        canonical(NOT_IMPLEMENTED, r)
    }public fun unavailable(r: u64): u64 {
        canonical(UNAVAILABLE, r)
    }
}no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::fixed_point32 {
    copy drop storestruct FixedPoint32 {
        value: u64
    }const MAX_U64:u128 = 18446744073709551615;const EDENOMINATOR:u64 = 0x10001;const EDIVISION:u64 = 0x20002;const EMULTIPLICATION:u64 = 0x20003;const EDIVISION_BY_ZERO:u64 = 0x10004;const ERATIO_OUT_OF_RANGE:u64 = 0x20005;public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64 {
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert!(product <= MAX_U64, EMULTIPLICATION);
        (product as u64)
    }spec multiply_u64{pragma opaque;
    include MultiplyAbortsIf;
    ensures result == spec_multiply_u64(val, multiplier)}spec schema MultiplyAbortsIf{localval: num;
    localmultiplier: FixedPoint32;
    aborts_if spec_multiply_u64(val, multiplier) > MAX_U64EMULTIPLICATION}spec module {fun spec_multiply_u64(val: num, multiplier: FixedPoint32): num {
        val * multiplier.value >> 32
    }}public fun divide_u64(val: u64, divisor: FixedPoint32): u64 {
        assert!(divisor.value != 0, EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / (divisor.value as u128);
        assert!(quotient <= MAX_U64, EDIVISION);
        (quotient as u64)
    }spec divide_u64{pragma opaque;
    include DivideAbortsIf;
    ensures result == spec_divide_u64(val, divisor)}spec schema DivideAbortsIf{localval: num;
    localdivisor: FixedPoint32;
    aborts_if divisor.value == 0EDIVISION_BY_ZERO;
    aborts_if spec_divide_u64(val, divisor) > MAX_U64EDIVISION}spec module {fun spec_divide_u64(val: num, divisor: FixedPoint32): num {
        val << 32 / divisor.value
    }}public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert!(scaled_denominator != 0, EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);
        assert!(quotient <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32{value: (quotient as u64)}
    }spec create_from_rational{pragma verify = false;
    pragma opaque;
    include CreateFromRationalAbortsIf;
    ensures result == spec_create_from_rational(numerator, denominator)}spec schema CreateFromRationalAbortsIf{localnumerator: u64;
    localdenominator: u64;
    let scaled_numerator = (numerator as u128) << 64;
    let scaled_denominator = (denominator as u128) << 32;
    let quotient = scaled_numerator / scaled_denominator;
    aborts_if scaled_denominator == 0EDENOMINATOR;
    aborts_if quotient == 0 && scaled_numerator != 0ERATIO_OUT_OF_RANGE;
    aborts_if quotient > MAX_U64ERATIO_OUT_OF_RANGE}spec module {fun spec_create_from_rational(numerator: num, denominator: num): FixedPoint32 {
        FixedPoint32{value: numerator << 64 / denominator << 32}
    }}public fun create_from_raw_value(value: u64): FixedPoint32 {
        FixedPoint32{value: value}
    }spec create_from_raw_value{pragma opaque;
    aborts_if false;
    ensures result.value == value}public fun get_raw_value(num: FixedPoint32): u64 {
        num.value
    }public fun is_zero(num: FixedPoint32): bool {
        num.value == 0
    }public fun min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }spec min{pragma opaque;
    aborts_if false;
    ensures result == spec_min(num1, num2)}spec module {fun spec_min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }}public fun max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }spec max{pragma opaque;
    aborts_if false;
    ensures result == spec_max(num1, num2)}spec module {fun spec_max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }}public fun create_from_u64(val: u64): FixedPoint32 {
        let value = (val as u128) << 32;
        assert!(value <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32{value: (value as u64)}
    }spec create_from_u64{pragma opaque;
    include CreateFromU64AbortsIf;
    ensures result == spec_create_from_u64(val)}spec schema CreateFromU64AbortsIf{localval: num;
    let scaled_value = (val as u128) << 32;
    aborts_if scaled_value > MAX_U64}spec module {fun spec_create_from_u64(val: num): FixedPoint32 {
        FixedPoint32{value: val << 32}
    }}public fun floor(num: FixedPoint32): u64 {
        num.value >> 32
    }spec floor{pragma opaque;
    aborts_if false;
    ensures result == spec_floor(num)}spec module {fun spec_floor(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional >> 32
        }
    }}public fun ceil(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        if (num.value == floored_num)  {
            return floored_num >> 32
        };
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }spec ceil{pragma verify = false;
    pragma opaque;
    aborts_if false;
    ensures result == spec_ceil(num)}spec module {fun spec_ceil(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let one = 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}public fun round(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if (num.value < boundary)  {
            floored_num >> 32
        } else  {
            ceil(num)
        }
    }spec round{pragma opaque;
    pragma timeout = 120;
    aborts_if false;
    ensures result == spec_round(num)}spec module {fun spec_round(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let boundary = 1 << 32 / 2;
        let one = 1 << 32;
        if (fractional < boundary)  {
            val.value - fractional >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}spec module {}spec module {pragma aborts_if_is_strict}
}no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::hash {
    public native fun sha2_256(data: vector<u8>): vector<u8>;
    public native fun sha3_256(data: vector<u8>): vector<u8>;

}no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::option {
    use std::vector;copy drop storestruct Option<Element> {
        vec: vector<Element>
    }spec Option{invariant len(vec) <= 1}const EOPTION_IS_SET:u64 = 0x40000;const EOPTION_NOT_SET:u64 = 0x40001;public fun none<Element>(): Option<Element> {
        Option{vec: vector::empty()}
    }spec none{pragma opaque;
    aborts_if false;
    ensures result == spec_none<Element>()}spec module {fun spec_none<Element>(): Option<Element> {
        Option{vec: vec()}
    }}public fun some<Element>(e: Element): Option<Element> {
        Option{vec: vector::singleton(e)}
    }spec some{pragma opaque;
    aborts_if false;
    ensures result == spec_some(e)}spec module {fun spec_some<Element>(e: Element): Option<Element> {
        Option{vec: vec(e)}
    }}public fun is_none<Element>(t: &Option<Element>): bool {
        vector::is_empty(&t.vec)
    }spec is_none{pragma opaque;
    aborts_if false;
    ensures result == is_none(t)}public fun is_some<Element>(t: &Option<Element>): bool {
        ! vector::is_empty(&t.vec)
    }spec is_some{pragma opaque;
    aborts_if false;
    ensures result == is_some(t)}public fun contains<Element>(t: &Option<Element>, e_ref: &Element): bool {
        vector::contains(&t.vec, e_ref)
    }spec contains{pragma opaque;
    aborts_if false;
    ensures result == spec_contains(t, e_ref)}spec module {fun spec_contains<Element>(t: Option<Element>, e: Element): bool {
        is_some(t) && borrow(t) == e
    }}public fun borrow<Element>(t: &Option<Element>): &Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow(&t.vec, 0)
    }spec borrow{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t)}public fun borrow_with_default<Element>(t: &Option<Element>, default_ref: &Element): &Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default_ref else vector::borrow(vec_ref, 0)
    }spec borrow_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default_ref}public fun get_with_default<Element: copy+drop>(t: &Option<Element>, default: Element): Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default else *vector::borrow(vec_ref, 0)
    }spec get_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default}public fun fill<Element>(t: &mut Option<Element>, e: Element): () {
        let vec_ref = &mut t.vec;
        if (vector::is_empty(vec_ref)) vector::push_back(vec_ref, e) else abort EOPTION_IS_SET
    }spec fill{pragma opaque;
    aborts_if is_some(t)EOPTION_IS_SET;
    ensures is_some(t);
    ensures borrow(t) == e}public fun extract<Element>(t: &mut Option<Element>): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::pop_back(&mut t.vec)
    }spec extract{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(old(t));
    ensures is_none(t)}public fun borrow_mut<Element>(t: &mut Option<Element>): &mut Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow_mut(&mut t.vec, 0)
    }spec borrow_mut{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t);
    ensures t == old(t)}public fun swap<Element>(t: &mut Option<Element>, e: Element): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = vector::pop_back(vec_ref);
        vector::push_back(vec_ref, e);
        old_value
    }spec swap{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(old(t));
    ensures is_some(t);
    ensures borrow(t) == e}public fun swap_or_fill<Element>(t: &mut Option<Element>, e: Element): Option<Element> {
        let vec_ref = &mut t.vec;
        let old_value = if (vector::is_empty(vec_ref)) none() else some(vector::pop_back(vec_ref));
        vector::push_back(vec_ref, e);
        old_value
    }spec swap_or_fill{pragma opaque;
    ensures result == old(t);
    ensures borrow(t) == e}public fun destroy_with_default<Element: drop>(t: Option<Element>, default: Element): Element {
        let Option{vec: vec} = t;
        if (vector::is_empty(&mut vec)) default else vector::pop_back(&mut vec)
    }spec destroy_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default}public fun destroy_some<Element>(t: Option<Element>): Element {
        assert!(is_some(&t), EOPTION_NOT_SET);
        let Option{vec: vec} = t;
        let elem = vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
        elem
    }spec destroy_some{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t)}public fun destroy_none<Element>(t: Option<Element>): () {
        assert!(is_none(&t), EOPTION_IS_SET);
        let Option{vec: vec} = t;
        vector::destroy_empty(vec)
    }spec destroy_none{pragma opaque;
    aborts_if is_some(t)EOPTION_IS_SET}public fun to_vec<Element>(t: Option<Element>): vector<Element> {
        let Option{vec: vec} = t;
        vec
    }spec to_vec{pragma opaque;
    aborts_if false;
    ensures result == t.vec}public inline fun for_each<Element>(o: Option<Element>, f: (Element):()): () {
        if (is_some(&o))  {
            f(destroy_some(o))
        } else  {
            destroy_none(o)
        }
    }public inline fun for_each_ref<Element>(o: &Option<Element>, f: (&Element):()): () {
        if (is_some(o))  {
            f(borrow(o))
        }
    }public inline fun for_each_mut<Element>(o: &mut Option<Element>, f: (&mut Element):()): () {
        if (is_some(o))  {
            f(borrow_mut(o))
        }
    }public inline fun fold<Accumulator, Element>(o: Option<Element>, init: Accumulator, f: (Accumulator, Element):Accumulator): Accumulator {
        if (is_some(&o))  {
            f(init, destroy_some(o))
        } else  {
            destroy_none(o);
            init
        }
    }public inline fun map<Element, OtherElement>(o: Option<Element>, f: (Element):OtherElement): Option<OtherElement> {
        if (is_some(&o))  {
            some(f(destroy_some(o)))
        } else  {
            destroy_none(o);
            none()
        }
    }public inline fun filter<Element: drop>(o: Option<Element>, f: (&Element):bool): Option<Element> {
        if (is_some(&o) && f(borrow(&o)))  {
            o
        } else  {
            none()
        }
    }spec module {}spec module {pragma aborts_if_is_strict}spec schema AbortsIfNone<Element>{localt: Option<Element>;
    aborts_if is_none(t)EOPTION_NOT_SET}
}no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::signer {
    public native fun borrow_address(s: &signer): &address;
    public fun address_of(s: &signer): address {
        *borrow_address(s)
    }spec module {native fun is_txn_signer(s: signer): bool;
    }spec module {native fun is_txn_signer_addr(a: address): bool;
    }
}no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::string {
    use std::vector;use std::option:: {
        Self, Option
    };const EINVALID_UTF8:u64 = 1;const EINVALID_INDEX:u64 = 2;copy drop storestruct String {
        bytes: vector<u8>
    }public fun utf8(bytes: vector<u8>): String {
        assert!(internal_check_utf8(&bytes), EINVALID_UTF8);
        String{bytes: bytes}
    }public fun try_utf8(bytes: vector<u8>): Option<String> {
        if (internal_check_utf8(&bytes))  {
            option::some(String{bytes: bytes})
        } else  {
            option::none()
        }
    }public fun bytes(s: &String): &vector<u8> {
        &s.bytes
    }public fun is_empty(s: &String): bool {
        vector::is_empty(&s.bytes)
    }public fun length(s: &String): u64 {
        vector::length(&s.bytes)
    }public fun append(s: &mut String, r: String): () {
        vector::append(&mut s.bytes, r.bytes)
    }public fun append_utf8(s: &mut String, bytes: vector<u8>): () {
        append(s, utf8(bytes))
    }public fun insert(s: &mut String, at: u64, o: String): () {
        let bytes = &s.bytes;
        assert!(at <= vector::length(bytes) && internal_is_char_boundary(bytes, at), EINVALID_INDEX);
        let l = length(s);
        let front = sub_string(s, 0, at);
        let end = sub_string(s, at, l);
        append(&mut front, o);
        append(&mut front, end);
        *s = front;

    }public fun sub_string(s: &String, i: u64, j: u64): String {
        let bytes = &s.bytes;
        let l = vector::length(bytes);
        assert!(j <= l && i <= j && internal_is_char_boundary(bytes, i) && internal_is_char_boundary(bytes, j), EINVALID_INDEX);
        String{bytes: internal_sub_string(bytes, i, j)}
    }public fun index_of(s: &String, r: &String): u64 {
        internal_index_of(&s.bytes, &r.bytes)
    } native fun internal_check_utf8(v: &vector<u8>): bool;
     native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;
     native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;
     native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

}no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::type_name {
    use std::ascii:: {
        String
    };copy drop storestruct TypeName {
        name: String
    }public native fun get<T>(): TypeName;
    public fun borrow_string(self: &TypeName): &String {
        &self.name
    }public fun into_string(self: TypeName): String {
        self.name
    }
}no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module std::vector {
    const EINDEX_OUT_OF_BOUNDS:u64 = 0x20000;#[bytecode_instruction]public native fun empty<Element>(): vector<Element>;
    #[bytecode_instruction]public native fun length<Element>(v: &vector<Element>): u64;
    #[bytecode_instruction]public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;
    #[bytecode_instruction]public native fun push_back<Element>(v: &mut vector<Element>, e: Element): ();
    #[bytecode_instruction]public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;
    #[bytecode_instruction]public native fun pop_back<Element>(v: &mut vector<Element>): Element;
    #[bytecode_instruction]public native fun destroy_empty<Element>(v: vector<Element>): ();
    #[bytecode_instruction]public native fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64): ();
    public fun singleton<Element>(e: Element): vector<Element> {
        let v = empty();
        push_back(&mut v, e);
        v
    }spec singleton{aborts_if false;
    ensures result == vec(e)}public fun reverse<Element>(v: &mut vector<Element>): () {
        let len = length(v);
        if (len == 0) return ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;

        }
    }spec reverse{pragma intrinsic = true}public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>): () {
        reverse(&mut other);
        while (! is_empty(&other))push_back(lhs, pop_back(&mut other));
        destroy_empty(other);

    }spec append{pragma intrinsic = true}spec is_empty{pragma intrinsic = true}public fun is_empty<Element>(v: &vector<Element>): bool {
        length(v) == 0
    }public fun contains<Element>(v: &vector<Element>, e: &Element): bool {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return true;
            i = i + 1;

        };
        false
    }spec contains{pragma intrinsic = true}public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return (true, i);
            i = i + 1;

        };
        (false, 0)
    }spec index_of{pragma intrinsic = true}public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {
        let len = length(v);
        if (i >= len) abort EINDEX_OUT_OF_BOUNDS;
        len = len - 1;
        while (i < len)swap(v, i,  {
            i = i + 1;
            i
        });
        pop_back(v)
    }spec remove{pragma intrinsic = true}public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {
        assert!(! is_empty(v), EINDEX_OUT_OF_BOUNDS);
        let last_idx = length(v) - 1;
        swap(v, i, last_idx);
        pop_back(v)
    }spec swap_remove{pragma intrinsic = true}public inline fun for_each<Element>(v: vector<Element>, f: (Element):()): () {
        reverse(&mut v);
        while (! is_empty(&v)) {
            let e = pop_back(&mut v);
            f(e);

        };

    }public inline fun for_each_ref<Element>(v: &vector<Element>, f: (&Element):()): () {
        let i = 0;
        while (i < length(v)) {
            f(borrow(v, i));
            i = i + 1
        }
    }public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: (&mut Element):()): () {
        let i = 0;
        while (i < length(v)) {
            f(borrow_mut(v, i));
            i = i + 1
        }
    }public inline fun fold<Accumulator, Element>(v: vector<Element>, init: Accumulator, f: (Accumulator, Element):Accumulator): Accumulator {
        let accu = init;
        for_each(v, |elem|accu = f(accu, elem));
        accu
    }public inline fun map<Element, NewElement>(v: vector<Element>, f: (Element):NewElement): vector<NewElement> {
        let result = vector<NewElement>[];
        for_each(v, |elem|push_back(&mut result, f(elem)));
        result
    }public inline fun filter<Element: drop>(v: vector<Element>, p: (&Element):bool): vector<Element> {
        let result = vector<Element>[];
        for_each(v, |elem| {
            if (p(&elem)) push_back(&mut result, elem);

        });
        result
    }spec module {}spec module {fun eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
        len(v1) == len(v2) + 1 && v1[len(v1) - 1] == e && v1[0 .. len(v1) - 1] == v2[0 .. len(v2)]
    };
    fun eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
        len(v) == len(v1) + len(v2) && v[0 .. len(v1)] == v1 && v[len(v1) .. len(v)] == v2
    };
    fun eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1 == v2[1 .. len(v2)]
    };
    fun eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1[0 .. i] == v2[0 .. i] && v1[i .. len(v1)] == v2[i + 1 .. len(v2)]
    }}
}
------ Source Defs: ------
no package
A => 0x42
Async => 0x20
B => 0x42
K => 0x19
M => 0x1
aptos_std => 0x1
std => 0x1
module 0x42::Test {
    use std::vector;public inline fun filter<X: drop>(v: &mut vector<X>, predicate: (&X):bool): () {
        let i = 0;
        while ( {
            spec {spec {invariant forall k in 0 .. i : ! predicate(v[k])}};
            i < vector::length(v)
        }) {
            if (predicate(vector::borrow(v, i)))  {
                vector::swap_remove(v, i);

            } else  {
                i = i + 1;

            };

        }
    }public fun test_filter(): vector<u64> {
        let v = vector[1u64, 2, 3];
        filter(&mut v, |e|*e > 1);
        v
    }spec test_filter{pragma verify = false}
}
After expansion: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #1
    neighbor#dependency (std=0x1)::option;
    uses address (std=0x1);
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public native fun all_characters_printable(string: &(std=0x1)::ascii::String): bool;

    #[]public native fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8>;

    #[]public native fun byte(char: (std=0x1)::ascii::Char): u8;

    #[]public native fun char(byte: u8): (std=0x1)::ascii::Char;

    #[]public native fun into_bytes(string: (std=0x1)::ascii::String): vector<u8>;

    #[]public native fun is_printable_char(byte: u8): bool;

    #[]public native fun is_valid_char(b: u8): bool;

    #[]public native fun length(string: &(std=0x1)::ascii::String): u64;

    #[]public native fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char;

    #[]public native fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): ();

    #[]public native fun string(bytes: vector<u8>): (std=0x1)::ascii::String;

    #[]public native fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String>;

     spec String{invariant forall i in 0 .. len(bytes) : (std=0x1)::ascii::is_valid_char(bytes[i])}
     spec Char{invariant (std=0x1)::ascii::is_valid_char(byte)}
     spec char{aborts_if ! (std=0x1)::ascii::is_valid_char(byte)(std=0x1)::ascii::EINVALID_ASCII_CHARACTER}
     spec string{aborts_if exists i in 0 .. len(bytes) : ! (std=0x1)::ascii::is_valid_char(bytes[i])(std=0x1)::ascii::EINVALID_ASCII_CHARACTER}
     spec all_characters_printable{ensures result ==> forall j in 0 .. len(string.bytes) : (std=0x1)::ascii::is_printable_char(string.bytes[j])}
     spec push_char{ensures len(string.bytes) == len(old(string.bytes)) + 1}
     spec pop_char{ensures len(string.bytes) == len(old(string.bytes)) - 1}

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;

     spec module {}
     spec module {native define serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }

}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #0
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public native fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool;

    #[]public native fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64;

    #[]public native fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64;

    #[]public native fun new(length: u64): (std=0x1)::bit_vector::BitVector;

    #[]public native fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();

    #[]public native fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): ();

    #[]public native fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();

     spec new{include (std=0x1)::bit_vector::NewAbortsIf;
    ensures result.length == length;
    ensures len(result.bit_field) == length}
     spec schema NewAbortsIf{locallength: u64;
    aborts_if length <= 0(std=0x1)::bit_vector::ELENGTH;
    aborts_if length >= (std=0x1)::bit_vector::MAX_SIZE(std=0x1)::bit_vector::ELENGTH}
     spec set{include (std=0x1)::bit_vector::SetAbortsIf;
    ensures bitvector.bit_field[bit_index]}
     spec schema SetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec unset{include (std=0x1)::bit_vector::UnsetAbortsIf;
    ensures ! bitvector.bit_field[bit_index]}
     spec schema UnsetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec is_index_set{include (std=0x1)::bit_vector::IsIndexSetAbortsIf;
    ensures result == bitvector.bit_field[bit_index]}
     spec schema IsIndexSetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec module {define spec_is_index_set(bitvector: (std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        if (bit_index >= (std=0x1)::bit_vector::length(bitvector))  {
            false
        } else  {
            bitvector.bit_field[bit_index]
        }
    }}

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public native fun aborted(r: u64): u64;

    #[]public native fun already_exists(r: u64): u64;

    #[]public native fun canonical(category: u64, reason: u64): u64;

    #[]public native fun internal(r: u64): u64;

    #[]public native fun invalid_argument(r: u64): u64;

    #[]public native fun invalid_state(r: u64): u64;

    #[]public native fun not_found(r: u64): u64;

    #[]public native fun not_implemented(r: u64): u64;

    #[]public native fun out_of_range(r: u64): u64;

    #[]public native fun permission_denied(r: u64): u64;

    #[]public native fun resource_exhausted(r: u64): u64;

    #[]public native fun unauthenticated(r: u64): u64;

    #[]public native fun unavailable(r: u64): u64;


}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public native fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool;

    #[]public native fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

     spec multiply_u64{pragma opaque;
    include (std=0x1)::fixed_point32::MultiplyAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_multiply_u64(val, multiplier)}
     spec schema MultiplyAbortsIf{localval: num;
    localmultiplier: (std=0x1)::fixed_point32::FixedPoint32;
    aborts_if (std=0x1)::fixed_point32::spec_multiply_u64(val, multiplier) > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::EMULTIPLICATION}
     spec module {define spec_multiply_u64(val: num, multiplier: (std=0x1)::fixed_point32::FixedPoint32): num {
        val * multiplier.value >> 32
    }}
     spec divide_u64{pragma opaque;
    include (std=0x1)::fixed_point32::DivideAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_divide_u64(val, divisor)}
     spec schema DivideAbortsIf{localval: num;
    localdivisor: (std=0x1)::fixed_point32::FixedPoint32;
    aborts_if divisor.value == 0(std=0x1)::fixed_point32::EDIVISION_BY_ZERO;
    aborts_if (std=0x1)::fixed_point32::spec_divide_u64(val, divisor) > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::EDIVISION}
     spec module {define spec_divide_u64(val: num, divisor: (std=0x1)::fixed_point32::FixedPoint32): num {
        val << 32 / divisor.value
    }}
     spec create_from_rational{pragma verify = false;
    pragma opaque;
    include (std=0x1)::fixed_point32::CreateFromRationalAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_create_from_rational(numerator, denominator)}
     spec schema CreateFromRationalAbortsIf{localnumerator: u64;
    localdenominator: u64;
    let scaled_numerator = (numerator as u128) << 64;
    let scaled_denominator = (denominator as u128) << 32;
    let quotient = scaled_numerator / scaled_denominator;
    aborts_if scaled_denominator == 0(std=0x1)::fixed_point32::EDENOMINATOR;
    aborts_if quotient == 0 && scaled_numerator != 0(std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE;
    aborts_if quotient > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE}
     spec module {define spec_create_from_rational(numerator: num, denominator: num): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: numerator << 64 / denominator << 32}
    }}
     spec create_from_raw_value{pragma opaque;
    aborts_if false;
    ensures result.value == value}
     spec min{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_min(num1, num2)}
     spec module {define spec_min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }}
     spec max{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_max(num1, num2)}
     spec module {define spec_max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }}
     spec create_from_u64{pragma opaque;
    include (std=0x1)::fixed_point32::CreateFromU64AbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_create_from_u64(val)}
     spec schema CreateFromU64AbortsIf{localval: num;
    let scaled_value = (val as u128) << 32;
    aborts_if scaled_value > (std=0x1)::fixed_point32::MAX_U64}
     spec module {define spec_create_from_u64(val: num): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: val << 32}
    }}
     spec floor{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_floor(num)}
     spec module {define spec_floor(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional >> 32
        }
    }}
     spec ceil{pragma verify = false;
    pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_ceil(num)}
     spec module {define spec_ceil(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let one = 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}
     spec round{pragma opaque;
    pragma timeout = 120;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_round(num)}
     spec module {define spec_round(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let boundary = 1 << 32 / 2;
        let one = 1 << 32;
        if (fractional < boundary)  {
            val.value - fractional >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}
     spec module {}
     spec module {pragma aborts_if_is_strict}

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #0
    #[]struct Option<Element> has copy drop store {
        0#vec: vector<Element>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public native fun borrow<Element>(t: &(std=0x1)::option::Option<Element>): &Element;

    #[]public native fun borrow_mut<Element>(t: &mut (std=0x1)::option::Option<Element>): &mut Element;

    #[]public native fun borrow_with_default<Element>(t: &(std=0x1)::option::Option<Element>, default_ref: &Element): &Element;

    #[]public native fun contains<Element>(t: &(std=0x1)::option::Option<Element>, e_ref: &Element): bool;

    #[]public native fun destroy_none<Element>(t: (std=0x1)::option::Option<Element>): ();

    #[]public native fun destroy_some<Element>(t: (std=0x1)::option::Option<Element>): Element;

    #[]public native fun destroy_with_default<Element: drop>(t: (std=0x1)::option::Option<Element>, default: Element): Element;

    #[]public native fun extract<Element>(t: &mut (std=0x1)::option::Option<Element>): Element;

    #[]public native fun fill<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): ();

    #[]public inline fun filter<Element: drop>(o: (std=0x1)::option::Option<Element>, f: |&Element|bool): (std=0x1)::option::Option<Element> {
        if ((std=0x1)::option::is_some(&o) && f((std=0x1)::option::borrow(&o)))  {
            o
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public inline fun fold<Accumulator, Element>(o: (std=0x1)::option::Option<Element>, init: Accumulator, f: |Accumulator, Element|Accumulator): Accumulator {
        if ((std=0x1)::option::is_some(&o))  {
            f(init, (std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o);
            init
        }
    }
    #[]public inline fun for_each<Element>(o: (std=0x1)::option::Option<Element>, f: |Element|()): () {
        if ((std=0x1)::option::is_some(&o))  {
            f((std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o)
        }
    }
    #[]public inline fun for_each_mut<Element>(o: &mut (std=0x1)::option::Option<Element>, f: |&mut Element|()): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow_mut(o))
        } else ()
    }
    #[]public inline fun for_each_ref<Element>(o: &(std=0x1)::option::Option<Element>, f: |&Element|()): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow(o))
        } else ()
    }
    #[]public native fun get_with_default<Element: copy+drop>(t: &(std=0x1)::option::Option<Element>, default: Element): Element;

    #[]public native fun is_none<Element>(t: &(std=0x1)::option::Option<Element>): bool;

    #[]public native fun is_some<Element>(t: &(std=0x1)::option::Option<Element>): bool;

    #[]public inline fun map<Element, OtherElement>(o: (std=0x1)::option::Option<Element>, f: |Element|OtherElement): (std=0x1)::option::Option<OtherElement> {
        if ((std=0x1)::option::is_some(&o))  {
            (std=0x1)::option::some(f((std=0x1)::option::destroy_some(o)))
        } else  {
            (std=0x1)::option::destroy_none(o);
            (std=0x1)::option::none()
        }
    }
    #[]public native fun none<Element>(): (std=0x1)::option::Option<Element>;

    #[]public native fun some<Element>(e: Element): (std=0x1)::option::Option<Element>;

    #[]public native fun swap<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): Element;

    #[]public native fun swap_or_fill<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): (std=0x1)::option::Option<Element>;

    #[]public native fun to_vec<Element>(t: (std=0x1)::option::Option<Element>): vector<Element>;

     spec Option{invariant len(vec) <= 1}
     spec none{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_none<Element>()}
     spec module {define spec_none<Element>(): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: vec()}
    }}
     spec some{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_some(e)}
     spec module {define spec_some<Element>(e: Element): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: vec(e)}
    }}
     spec is_none{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::is_none(t)}
     spec is_some{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::is_some(t)}
     spec contains{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_contains(t, e_ref)}
     spec module {define spec_contains<Element>(t: (std=0x1)::option::Option<Element>, e: Element): bool {
        (std=0x1)::option::is_some(t) && (std=0x1)::option::borrow(t) == e
    }}
     spec borrow{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t)}
     spec borrow_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default_ref}
     spec get_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default}
     spec fill{pragma opaque;
    aborts_if (std=0x1)::option::is_some(t)(std=0x1)::option::EOPTION_IS_SET;
    ensures (std=0x1)::option::is_some(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec extract{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(old(t));
    ensures (std=0x1)::option::is_none(t)}
     spec borrow_mut{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t);
    ensures t == old(t)}
     spec swap{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(old(t));
    ensures (std=0x1)::option::is_some(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec swap_or_fill{pragma opaque;
    ensures result == old(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec destroy_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default}
     spec destroy_some{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t)}
     spec destroy_none{pragma opaque;
    aborts_if (std=0x1)::option::is_some(t)(std=0x1)::option::EOPTION_IS_SET}
     spec to_vec{pragma opaque;
    aborts_if false;
    ensures result == t.vec}
     spec module {}
     spec module {pragma aborts_if_is_strict}
     spec schema AbortsIfNone<Element>{localt: (std=0x1)::option::Option<Element>;
    aborts_if (std=0x1)::option::is_none(t)(std=0x1)::option::EOPTION_NOT_SET}

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public native fun address_of(s: &signer): address;

    #[]public native fun borrow_address(s: &signer): &address;

     spec module {native define is_txn_signer(s: signer): bool;
    }
     spec module {native define is_txn_signer_addr(a: address): bool;
    }

}
module (std=0x1)::string {
    #[]library module
    dependency order #2
    neighbor#dependency (std=0x1)::option;
    uses address (std=0x1);
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public native fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): ();

    #[]public native fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): ();

    #[]public native fun bytes(s: &(std=0x1)::string::String): &vector<u8>;

    #[]public native fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64;

    #[]public native fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): ();

    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public native fun is_empty(s: &(std=0x1)::string::String): bool;

    #[]public native fun length(s: &(std=0x1)::string::String): u64;

    #[]public native fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String;

    #[]public native fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String>;

    #[]public native fun utf8(bytes: vector<u8>): (std=0x1)::string::String;


}
module (std=0x1)::type_name {
    #[]library module
    dependency order #3
    neighbor#dependency (std=0x1)::ascii;
    uses address (std=0x1);
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public native fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String;

    #[]public native fun get<T>(): (std=0x1)::type_name::TypeName;

    #[]public native fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String;


}
module (std=0x1)::vector {
    #[]library module
    dependency order #4
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public native fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>): ();

    #[bytecode_instruction]public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;

    #[bytecode_instruction]public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;

    #[]public native fun contains<Element>(v: &vector<Element>, e: &Element): bool;

    #[bytecode_instruction]public native fun destroy_empty<Element>(v: vector<Element>): ();

    #[bytecode_instruction]public native fun empty<Element>(): vector<Element>;

    #[]public inline fun filter<Element: drop>(v: vector<Element>, p: |&Element|bool): vector<Element> {
        let result = vector<Element>[];
        (std=0x1)::vector::for_each(v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back(&mut result, elem) else ();
            /*()*/
        });
        result
    }
    #[]public inline fun fold<Accumulator, Element>(v: vector<Element>, init: Accumulator, f: |Accumulator, Element|Accumulator): Accumulator {
        let accu = init;
        (std=0x1)::vector::for_each(v, |elem|accu = f(accu, elem));
        accu
    }
    #[]public inline fun for_each<Element>(v: vector<Element>, f: |Element|()): () {
        (std=0x1)::vector::reverse(&mut v);
        while (! (std=0x1)::vector::is_empty(&v)) {
            let e = (std=0x1)::vector::pop_back(&mut v);
            f(e);
            /*()*/
        };
        /*()*/
    }
    #[]public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: |&mut Element|()): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow_mut(v, i));
            i = i + 1
        }
    }
    #[]public inline fun for_each_ref<Element>(v: &vector<Element>, f: |&Element|()): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow(v, i));
            i = i + 1
        }
    }
    #[]public native fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64);

    #[]public native fun is_empty<Element>(v: &vector<Element>): bool;

    #[bytecode_instruction]public native fun length<Element>(v: &vector<Element>): u64;

    #[]public inline fun map<Element, NewElement>(v: vector<Element>, f: |Element|NewElement): vector<NewElement> {
        let result = vector<NewElement>[];
        (std=0x1)::vector::for_each(v, |elem|(std=0x1)::vector::push_back(&mut result, f(elem)));
        result
    }
    #[bytecode_instruction]public native fun pop_back<Element>(v: &mut vector<Element>): Element;

    #[bytecode_instruction]public native fun push_back<Element>(v: &mut vector<Element>, e: Element): ();

    #[]public native fun remove<Element>(v: &mut vector<Element>, i: u64): Element;

    #[]public native fun reverse<Element>(v: &mut vector<Element>): ();

    #[]public native fun singleton<Element>(e: Element): vector<Element>;

    #[bytecode_instruction]public native fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64): ();

    #[]public native fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element;

     spec singleton{aborts_if false;
    ensures result == vec(e)}
     spec reverse{pragma intrinsic = true}
     spec append{pragma intrinsic = true}
     spec is_empty{pragma intrinsic = true}
     spec contains{pragma intrinsic = true}
     spec index_of{pragma intrinsic = true}
     spec remove{pragma intrinsic = true}
     spec swap_remove{pragma intrinsic = true}
     spec module {}
     spec module {define eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
        len(v1) == len(v2) + 1 && v1[len(v1) - 1] == e && v1[0 .. len(v1) - 1] == v2[0 .. len(v2)]
    };
    define eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
        len(v) == len(v1) + len(v2) && v[0 .. len(v1)] == v1 && v[len(v1) .. len(v)] == v2
    };
    define eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1 == v2[1 .. len(v2)]
    };
    define eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1[0 .. i] == v2[0 .. i] && v1[i .. len(v1)] == v2[i + 1 .. len(v2)]
    }}

}
module 0x42::Test {
    #[]source module
    dependency order #5
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]public inline fun filter<X: drop>(v: &mut vector<X>, predicate: |&X|bool): () {
        let i = 0;
        while ( {
            spec #0 uses [i, v] applies [predicate];
            i < (std=0x1)::vector::length(v)
        }) {
            if (predicate((std=0x1)::vector::borrow(v, i)))  {
                (std=0x1)::vector::swap_remove(v, i);
                /*()*/
            } else  {
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun test_filter(): vector<u64> {
        let v = vector[1u64, 2, 3];
        0x42::Test::filter(&mut v, |e|*e > 1);
        v
    }
     spec test_filter{pragma verify = false}

}
After naming: program = module (std=0x1)::ascii {
    #[]source module
    dependency order #1
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public native fun all_characters_printable(string: &(std=0x1)::ascii::String): bool;

    #[]public native fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8>;

    #[]public native fun byte(char: (std=0x1)::ascii::Char): u8;

    #[]public native fun char(byte: u8): (std=0x1)::ascii::Char;

    #[]public native fun into_bytes(string: (std=0x1)::ascii::String): vector<u8>;

    #[]public native fun is_printable_char(byte: u8): bool;

    #[]public native fun is_valid_char(b: u8): bool;

    #[]public native fun length(string: &(std=0x1)::ascii::String): u64;

    #[]public native fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char;

    #[]public native fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): ();

    #[]public native fun string(bytes: vector<u8>): (std=0x1)::ascii::String;

    #[]public native fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String>;


}
module (std=0x1)::bcs {
    #[]source module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]source module
    dependency order #0
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public native fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool;

    #[]public native fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64;

    #[]public native fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64;

    #[]public native fun new(length: u64): (std=0x1)::bit_vector::BitVector;

    #[]public native fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();

    #[]public native fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): ();

    #[]public native fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();


}
module (std=0x1)::error {
    #[]source module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public native fun aborted(r: u64): u64;

    #[]public native fun already_exists(r: u64): u64;

    #[]public native fun canonical(category: u64, reason: u64): u64;

    #[]public native fun internal(r: u64): u64;

    #[]public native fun invalid_argument(r: u64): u64;

    #[]public native fun invalid_state(r: u64): u64;

    #[]public native fun not_found(r: u64): u64;

    #[]public native fun not_implemented(r: u64): u64;

    #[]public native fun out_of_range(r: u64): u64;

    #[]public native fun permission_denied(r: u64): u64;

    #[]public native fun resource_exhausted(r: u64): u64;

    #[]public native fun unauthenticated(r: u64): u64;

    #[]public native fun unavailable(r: u64): u64;


}
module (std=0x1)::fixed_point32 {
    #[]source module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public native fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool;

    #[]public native fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64;


}
module (std=0x1)::hash {
    #[]source module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]source module
    dependency order #0
    #[]struct Option<Element#1> has copy drop store {
        0#vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public native fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2;

    #[]public native fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3;

    #[]public native fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4;

    #[]public native fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool;

    #[]public native fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): ();

    #[]public native fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7;

    #[]public native fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop;

    #[]public native fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9;

    #[]public native fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): ();

    #[]public inline fun filter<Element#11: drop>(o: (std=0x1)::option::Option<Element#11: drop>, f: |..|..<&Element#11: drop, bool>): (std=0x1)::option::Option<Element#11: drop> {
        if ((std=0x1)::option::is_some(&o) && f((std=0x1)::option::borrow(&o)))  {
            o
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public inline fun fold<Accumulator#12, Element#13>(o: (std=0x1)::option::Option<Element#13>, init: Accumulator#12, f: |..|..<Accumulator#12, Element#13, Accumulator#12>): Accumulator#12 {
        if ((std=0x1)::option::is_some(&o))  {
            f(init, (std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o);
            init
        }
    }
    #[]public inline fun for_each<Element#14>(o: (std=0x1)::option::Option<Element#14>, f: |..|..<Element#14, ()>): () {
        if ((std=0x1)::option::is_some(&o))  {
            f((std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o)
        }
    }
    #[]public inline fun for_each_mut<Element#15>(o: &mut (std=0x1)::option::Option<Element#15>, f: |..|..<&mut Element#15, ()>): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow_mut(o))
        } else ()
    }
    #[]public inline fun for_each_ref<Element#16>(o: &(std=0x1)::option::Option<Element#16>, f: |..|..<&Element#16, ()>): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow(o))
        } else ()
    }
    #[]public native fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop;

    #[]public native fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool;

    #[]public native fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool;

    #[]public inline fun map<Element#20, OtherElement#21>(o: (std=0x1)::option::Option<Element#20>, f: |..|..<Element#20, OtherElement#21>): (std=0x1)::option::Option<OtherElement#21> {
        if ((std=0x1)::option::is_some(&o))  {
            (std=0x1)::option::some(f((std=0x1)::option::destroy_some(o)))
        } else  {
            (std=0x1)::option::destroy_none(o);
            (std=0x1)::option::none()
        }
    }
    #[]public native fun none<Element#22>(): (std=0x1)::option::Option<Element#22>;

    #[]public native fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23>;

    #[]public native fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24;

    #[]public native fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25>;

    #[]public native fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26>;


}
module (std=0x1)::signer {
    #[]source module
    dependency order #0
    #[]public native fun address_of(s: &signer): address;

    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]source module
    dependency order #2
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public native fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): ();

    #[]public native fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): ();

    #[]public native fun bytes(s: &(std=0x1)::string::String): &vector<u8>;

    #[]public native fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64;

    #[]public native fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): ();

    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public native fun is_empty(s: &(std=0x1)::string::String): bool;

    #[]public native fun length(s: &(std=0x1)::string::String): u64;

    #[]public native fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String;

    #[]public native fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String>;

    #[]public native fun utf8(bytes: vector<u8>): (std=0x1)::string::String;


}
module (std=0x1)::type_name {
    #[]source module
    dependency order #3
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public native fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String;

    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public native fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String;


}
module (std=0x1)::vector {
    #[]source module
    dependency order #4
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public native fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): ();

    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public native fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool;

    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public inline fun filter<Element#34: drop>(v: vector<Element#34: drop>, p: |..|..<&Element#34: drop, bool>): vector<Element#34: drop> {
        let result = vector<Element#34: drop>[];
        (std=0x1)::vector::for_each(v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back(&mut result, elem) else ();
            /*()*/
        });
        result
    }
    #[]public inline fun fold<Accumulator#35, Element#36>(v: vector<Element#36>, init: Accumulator#35, f: |..|..<Accumulator#35, Element#36, Accumulator#35>): Accumulator#35 {
        let accu = init;
        (std=0x1)::vector::for_each(v, |elem|accu = f(accu, elem));
        accu
    }
    #[]public inline fun for_each<Element#37>(v: vector<Element#37>, f: |..|..<Element#37, ()>): () {
        (std=0x1)::vector::reverse(&mut v);
        while (! (std=0x1)::vector::is_empty(&v)) {
            let e = (std=0x1)::vector::pop_back(&mut v);
            f(e);
            /*()*/
        };
        /*()*/
    }
    #[]public inline fun for_each_mut<Element#38>(v: &mut vector<Element#38>, f: |..|..<&mut Element#38, ()>): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow_mut(v, i));
            i = i + 1
        }
    }
    #[]public inline fun for_each_ref<Element#39>(v: &vector<Element#39>, f: |..|..<&Element#39, ()>): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow(v, i));
            i = i + 1
        }
    }
    #[]public native fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64);

    #[]public native fun is_empty<Element#41>(v: &vector<Element#41>): bool;

    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[]public inline fun map<Element#43, NewElement#44>(v: vector<Element#43>, f: |..|..<Element#43, NewElement#44>): vector<NewElement#44> {
        let result = vector<NewElement#44>[];
        (std=0x1)::vector::for_each(v, |elem|(std=0x1)::vector::push_back(&mut result, f(elem)));
        result
    }
    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public native fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47;

    #[]public native fun reverse<Element#48>(v: &mut vector<Element#48>): ();

    #[]public native fun singleton<Element#49>(e: Element#49): vector<Element#49>;

    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public native fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51;


}
module 0x42::Test {
    #[]library module
    dependency order #5
    #[]public inline fun filter<X#52: drop>(v: &mut vector<X#52: drop>, predicate: |..|..<&X#52: drop, bool>): () {
        let i = 0;
        while ( {
            spec #0 uses [i, v] applies [predicate];
            i < (std=0x1)::vector::length(v)
        }) {
            if (predicate((std=0x1)::vector::borrow(v, i)))  {
                (std=0x1)::vector::swap_remove(v, i);
                /*()*/
            } else  {
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun test_filter(): vector<u64> {
        let v = vector[1u64, 2, 3];
        0x42::Test::filter(&mut v, |e|*e > 1);
        v
    }

}
After typing: program = module (std=0x1)::ascii {
    #[]source module
    dependency order #1
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536u64;
    #[]public native fun all_characters_printable(string: &(std=0x1)::ascii::String): bool;

    #[]public native fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8>;

    #[]public native fun byte(char: (std=0x1)::ascii::Char): u8;

    #[]public native fun char(byte: u8): (std=0x1)::ascii::Char;

    #[]public native fun into_bytes(string: (std=0x1)::ascii::String): vector<u8>;

    #[]public native fun is_printable_char(byte: u8): bool;

    #[]public native fun is_valid_char(b: u8): bool;

    #[]public native fun length(string: &(std=0x1)::ascii::String): u64;

    #[]public native fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char;

    #[]public native fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): ();

    #[]public native fun string(bytes: vector<u8>): (std=0x1)::ascii::String;

    #[]public native fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String>;


}
module (std=0x1)::bcs {
    #[]source module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]source module
    dependency order #0
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072u64;
    #[]const ELENGTH:u64 = 131073u64;
    #[]const MAX_SIZE:u64 = 1024u64;
    #[]const WORD_SIZE:u64 = 1u64;
    #[]public native fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool;

    #[]public native fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64;

    #[]public native fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64;

    #[]public native fun new(length: u64): (std=0x1)::bit_vector::BitVector;

    #[]public native fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();

    #[]public native fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): ();

    #[]public native fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();


}
module (std=0x1)::error {
    #[]source module
    dependency order #0
    #[]const ABORTED:u64 = 7u64;
    #[]const ALREADY_EXISTS:u64 = 8u64;
    #[]const CANCELLED:u64 = 10u64;
    #[]const INTERNAL:u64 = 11u64;
    #[]const INVALID_ARGUMENT:u64 = 1u64;
    #[]const INVALID_STATE:u64 = 3u64;
    #[]const NOT_FOUND:u64 = 6u64;
    #[]const NOT_IMPLEMENTED:u64 = 12u64;
    #[]const OUT_OF_RANGE:u64 = 2u64;
    #[]const PERMISSION_DENIED:u64 = 5u64;
    #[]const RESOURCE_EXHAUSTED:u64 = 9u64;
    #[]const UNAUTHENTICATED:u64 = 4u64;
    #[]const UNAVAILABLE:u64 = 13u64;
    #[]public native fun aborted(r: u64): u64;

    #[]public native fun already_exists(r: u64): u64;

    #[]public native fun canonical(category: u64, reason: u64): u64;

    #[]public native fun internal(r: u64): u64;

    #[]public native fun invalid_argument(r: u64): u64;

    #[]public native fun invalid_state(r: u64): u64;

    #[]public native fun not_found(r: u64): u64;

    #[]public native fun not_implemented(r: u64): u64;

    #[]public native fun out_of_range(r: u64): u64;

    #[]public native fun permission_denied(r: u64): u64;

    #[]public native fun resource_exhausted(r: u64): u64;

    #[]public native fun unauthenticated(r: u64): u64;

    #[]public native fun unavailable(r: u64): u64;


}
module (std=0x1)::fixed_point32 {
    #[]source module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537u64;
    #[]const EDIVISION:u64 = 131074u64;
    #[]const EDIVISION_BY_ZERO:u64 = 65540u64;
    #[]const EMULTIPLICATION:u64 = 131075u64;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077u64;
    #[]const MAX_U64:u128 = 18446744073709551615u128;
    #[]public native fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool;

    #[]public native fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64;


}
module (std=0x1)::hash {
    #[]source module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]source module
    dependency order #0
    #[]struct Option<Element#1> has copy drop store {
        0#vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144u64;
    #[]const EOPTION_NOT_SET:u64 = 262145u64;
    #[]public native fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2;

    #[]public native fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3;

    #[]public native fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4;

    #[]public native fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool;

    #[]public native fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): ();

    #[]public native fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7;

    #[]public native fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop;

    #[]public native fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9;

    #[]public native fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): ();

    #[]public fun filter!<Element#11: drop>(o: (std=0x1)::option::Option<Element#11: drop>, f: |..|..<&Element#11: drop, bool>): (std=0x1)::option::Option<Element#11: drop> {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#11: drop>]<Element#11: drop>(&o) &&@bool f((std=0x1)::option::borrow[parameter_types: [&(std=0x1)::option::Option<Element#11: drop>]<Element#11: drop>(&o)))  {
            move o
        } else  {
            (std=0x1)::option::none<Element#11: drop>(())
        }
    }
    #[]public fun fold!<Accumulator#12, Element#13>(o: (std=0x1)::option::Option<Element#13>, init: Accumulator#12, f: |..|..<Accumulator#12, Element#13, Accumulator#12>): Accumulator#12 {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#13>]<Element#13>(&o))  {
            f((move init, (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#13>]<Element#13>(move o)))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#13>]<Element#13>(move o);
            move init
        }
    }
    #[]public fun for_each!<Element#14>(o: (std=0x1)::option::Option<Element#14>, f: |..|..<Element#14, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#14>]<Element#14>(&o))  {
            f((std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#14>]<Element#14>(move o))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#14>]<Element#14>(move o)
        }
    }
    #[]public fun for_each_mut!<Element#15>(o: &mut (std=0x1)::option::Option<Element#15>, f: |..|..<&mut Element#15, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#15>]<Element#15>(copy o))  {
            f((std=0x1)::option::borrow_mut[parameter_types: [&mut (std=0x1)::option::Option<Element#15>]<Element#15>(copy o))
        } else ()
    }
    #[]public fun for_each_ref!<Element#16>(o: &(std=0x1)::option::Option<Element#16>, f: |..|..<&Element#16, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#16>]<Element#16>(copy o))  {
            f((std=0x1)::option::borrow[parameter_types: [&(std=0x1)::option::Option<Element#16>]<Element#16>(copy o))
        } else ()
    }
    #[]public native fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop;

    #[]public native fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool;

    #[]public native fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool;

    #[]public fun map!<Element#20, OtherElement#21>(o: (std=0x1)::option::Option<Element#20>, f: |..|..<Element#20, OtherElement#21>): (std=0x1)::option::Option<OtherElement#21> {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#20>]<Element#20>(&o))  {
            (std=0x1)::option::some[parameter_types: [OtherElement#21]<OtherElement#21>(f((std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#20>]<Element#20>(move o)))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#20>]<Element#20>(move o);
            (std=0x1)::option::none<OtherElement#21>(())
        }
    }
    #[]public native fun none<Element#22>(): (std=0x1)::option::Option<Element#22>;

    #[]public native fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23>;

    #[]public native fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24;

    #[]public native fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25>;

    #[]public native fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26>;


}
module (std=0x1)::signer {
    #[]source module
    dependency order #0
    #[]public native fun address_of(s: &signer): address;

    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]source module
    dependency order #2
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2u64;
    #[]const EINVALID_UTF8:u64 = 1u64;
    #[]public native fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): ();

    #[]public native fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): ();

    #[]public native fun bytes(s: &(std=0x1)::string::String): &vector<u8>;

    #[]public native fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64;

    #[]public native fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): ();

    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public native fun is_empty(s: &(std=0x1)::string::String): bool;

    #[]public native fun length(s: &(std=0x1)::string::String): u64;

    #[]public native fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String;

    #[]public native fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String>;

    #[]public native fun utf8(bytes: vector<u8>): (std=0x1)::string::String;


}
module (std=0x1)::type_name {
    #[]source module
    dependency order #3
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public native fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String;

    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public native fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String;


}
module (std=0x1)::vector {
    #[]source module
    dependency order #4
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072u64;
    #[]public native fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): ();

    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public native fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool;

    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public fun filter!<Element#34: drop>(v: vector<Element#34: drop>, p: |..|..<&Element#34: drop, bool>): vector<Element#34: drop> {
        let result: (vector<Element#34: drop>) = vector#0<Element#34: drop>[()];
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#34: drop>, |..|..<Element#34: drop, ()>]<Element#34: drop>((move v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#34: drop>, Element#34: drop]<Element#34: drop>((&mut result, move elem)) else ();
            /*()*/
        }));
        move result
    }
    #[]public fun fold!<Accumulator#35, Element#36>(v: vector<Element#36>, init: Accumulator#35, f: |..|..<Accumulator#35, Element#36, Accumulator#35>): Accumulator#35 {
        let accu: (Accumulator#35) = move init;
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#36>, |..|..<Element#36, ()>]<Element#36>((move v, |elem|accu: (Accumulator#35) = f((move accu, move elem))));
        move accu
    }
    #[]public fun for_each!<Element#37>(v: vector<Element#37>, f: |..|..<Element#37, ()>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#37>]<Element#37>(&mut v);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#37>]<Element#37>(&v)) {
            let e: (Element#37) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#37>]<Element#37>(&mut v);
            f(move e);
            /*()*/
        };
        /*()*/
    }
    #[]public fun for_each_mut!<Element#38>(v: &mut vector<Element#38>, f: |..|..<&mut Element#38, ()>): () {
        let i: (u64) = 0u64;
        while (copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<Element#38>]<Element#38>(copy v)) {
            f((std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#38>, u64]<Element#38>((copy v, copy i)));
            i: (u64) = copy i +@u64 1u64
        }
    }
    #[]public fun for_each_ref!<Element#39>(v: &vector<Element#39>, f: |..|..<&Element#39, ()>): () {
        let i: (u64) = 0u64;
        while (copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<Element#39>]<Element#39>(copy v)) {
            f((std=0x1)::vector::borrow[parameter_types: [&vector<Element#39>, u64]<Element#39>((copy v, copy i)));
            i: (u64) = copy i +@u64 1u64
        }
    }
    #[]public native fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64);

    #[]public native fun is_empty<Element#41>(v: &vector<Element#41>): bool;

    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[]public fun map!<Element#43, NewElement#44>(v: vector<Element#43>, f: |..|..<Element#43, NewElement#44>): vector<NewElement#44> {
        let result: (vector<NewElement#44>) = vector#0<NewElement#44>[()];
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#43>, |..|..<Element#43, ()>]<Element#43>((move v, |elem|(std=0x1)::vector::push_back[parameter_types: [&mut vector<NewElement#44>, NewElement#44]<NewElement#44>((&mut result, f(move elem)))));
        move result
    }
    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public native fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47;

    #[]public native fun reverse<Element#48>(v: &mut vector<Element#48>): ();

    #[]public native fun singleton<Element#49>(e: Element#49): vector<Element#49>;

    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public native fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51;


}
module 0x42::Test {
    #[]library module
    dependency order #5
    #[]public fun filter!<X#52: drop>(v: &mut vector<X#52: drop>, predicate: |..|..<&X#52: drop, bool>): () {
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [i (i), predicate (predicate), v (v)];
            copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<X#52: drop>]<X#52: drop>(copy v)
        }) {
            if (predicate((std=0x1)::vector::borrow[parameter_types: [&vector<X#52: drop>, u64]<X#52: drop>((copy v, copy i))))  {
                (std=0x1)::vector::swap_remove[parameter_types: [&mut vector<X#52: drop>, u64]<X#52: drop>((copy v, copy i));
                /*()*/
            } else  {
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun test_filter(): vector<u64> {
        let v: (vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        0x42::Test::filter[parameter_types: [&mut vector<u64>, |..|..<&u64, bool>]<u64>((&mut v, |e|*copy e >@u64 1u64));
        copy v
    }

}
After inlining: program = module (std=0x1)::ascii {
    #[]source module
    dependency order #1
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536u64;
    #[]public native fun all_characters_printable(string: &(std=0x1)::ascii::String): bool;

    #[]public native fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8>;

    #[]public native fun byte(char: (std=0x1)::ascii::Char): u8;

    #[]public native fun char(byte: u8): (std=0x1)::ascii::Char;

    #[]public native fun into_bytes(string: (std=0x1)::ascii::String): vector<u8>;

    #[]public native fun is_printable_char(byte: u8): bool;

    #[]public native fun is_valid_char(b: u8): bool;

    #[]public native fun length(string: &(std=0x1)::ascii::String): u64;

    #[]public native fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char;

    #[]public native fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): ();

    #[]public native fun string(bytes: vector<u8>): (std=0x1)::ascii::String;

    #[]public native fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String>;


}
module (std=0x1)::bcs {
    #[]source module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]source module
    dependency order #0
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072u64;
    #[]const ELENGTH:u64 = 131073u64;
    #[]const MAX_SIZE:u64 = 1024u64;
    #[]const WORD_SIZE:u64 = 1u64;
    #[]public native fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool;

    #[]public native fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64;

    #[]public native fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64;

    #[]public native fun new(length: u64): (std=0x1)::bit_vector::BitVector;

    #[]public native fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();

    #[]public native fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): ();

    #[]public native fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();


}
module (std=0x1)::error {
    #[]source module
    dependency order #0
    #[]const ABORTED:u64 = 7u64;
    #[]const ALREADY_EXISTS:u64 = 8u64;
    #[]const CANCELLED:u64 = 10u64;
    #[]const INTERNAL:u64 = 11u64;
    #[]const INVALID_ARGUMENT:u64 = 1u64;
    #[]const INVALID_STATE:u64 = 3u64;
    #[]const NOT_FOUND:u64 = 6u64;
    #[]const NOT_IMPLEMENTED:u64 = 12u64;
    #[]const OUT_OF_RANGE:u64 = 2u64;
    #[]const PERMISSION_DENIED:u64 = 5u64;
    #[]const RESOURCE_EXHAUSTED:u64 = 9u64;
    #[]const UNAUTHENTICATED:u64 = 4u64;
    #[]const UNAVAILABLE:u64 = 13u64;
    #[]public native fun aborted(r: u64): u64;

    #[]public native fun already_exists(r: u64): u64;

    #[]public native fun canonical(category: u64, reason: u64): u64;

    #[]public native fun internal(r: u64): u64;

    #[]public native fun invalid_argument(r: u64): u64;

    #[]public native fun invalid_state(r: u64): u64;

    #[]public native fun not_found(r: u64): u64;

    #[]public native fun not_implemented(r: u64): u64;

    #[]public native fun out_of_range(r: u64): u64;

    #[]public native fun permission_denied(r: u64): u64;

    #[]public native fun resource_exhausted(r: u64): u64;

    #[]public native fun unauthenticated(r: u64): u64;

    #[]public native fun unavailable(r: u64): u64;


}
module (std=0x1)::fixed_point32 {
    #[]source module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537u64;
    #[]const EDIVISION:u64 = 131074u64;
    #[]const EDIVISION_BY_ZERO:u64 = 65540u64;
    #[]const EMULTIPLICATION:u64 = 131075u64;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077u64;
    #[]const MAX_U64:u128 = 18446744073709551615u128;
    #[]public native fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool;

    #[]public native fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64;


}
module (std=0x1)::hash {
    #[]source module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]source module
    dependency order #0
    #[]struct Option<Element#1> has copy drop store {
        0#vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144u64;
    #[]const EOPTION_NOT_SET:u64 = 262145u64;
    #[]public native fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2;

    #[]public native fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3;

    #[]public native fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4;

    #[]public native fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool;

    #[]public native fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): ();

    #[]public native fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7;

    #[]public native fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop;

    #[]public native fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9;

    #[]public native fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): ();

    #[]public native fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop;

    #[]public native fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool;

    #[]public native fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool;

    #[]public native fun none<Element#22>(): (std=0x1)::option::Option<Element#22>;

    #[]public native fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23>;

    #[]public native fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24;

    #[]public native fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25>;

    #[]public native fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26>;


}
module (std=0x1)::signer {
    #[]source module
    dependency order #0
    #[]public native fun address_of(s: &signer): address;

    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]source module
    dependency order #2
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2u64;
    #[]const EINVALID_UTF8:u64 = 1u64;
    #[]public native fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): ();

    #[]public native fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): ();

    #[]public native fun bytes(s: &(std=0x1)::string::String): &vector<u8>;

    #[]public native fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64;

    #[]public native fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): ();

    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public native fun is_empty(s: &(std=0x1)::string::String): bool;

    #[]public native fun length(s: &(std=0x1)::string::String): u64;

    #[]public native fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String;

    #[]public native fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String>;

    #[]public native fun utf8(bytes: vector<u8>): (std=0x1)::string::String;


}
module (std=0x1)::type_name {
    #[]source module
    dependency order #3
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public native fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String;

    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public native fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String;


}
module (std=0x1)::vector {
    #[]source module
    dependency order #4
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072u64;
    #[]public native fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): ();

    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public native fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool;

    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public native fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64);

    #[]public native fun is_empty<Element#41>(v: &vector<Element#41>): bool;

    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public native fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47;

    #[]public native fun reverse<Element#48>(v: &mut vector<Element#48>): ();

    #[]public native fun singleton<Element#49>(e: Element#49): vector<Element#49>;

    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public native fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51;


}
module 0x42::Test {
    #[]library module
    dependency order #5
    #[]public fun test_filter(): vector<u64> {
        let v: (vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
         {
            let v#0: (&mut vector<u64>) = annot(&mut v: &mut vector<u64>);
            let i#2: (u64) = 0u64;
            while ( {
                spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate]
                lambda predicate -> test_filter_predicate_0: (e: &u64): bool {
                    *copy e >@u64 1u64
                }
                ;
                copy i#2 <@u64 (std=0x1)::vector::length[parameter_types: [&vector<u64>]<u64>(copy v#0)
            }) {
                if ( {
                    let e#3: (&u64) = (std=0x1)::vector::borrow[parameter_types: [&vector<u64>, u64]<u64>((copy v#0, copy i#2));
                    *copy e#3 >@u64 1u64
                })  {
                    (std=0x1)::vector::swap_remove[parameter_types: [&mut vector<u64>, u64]<u64>((copy v#0, copy i#2));
                    /*()*/
                } else  {
                    i#2: (u64) = copy i#2 +@u64 1u64;
                    /*()*/
                };
                /*()*/
            }
        };
        copy v
    }

}
After hlir: program = module (std=0x1)::ascii {
    #[]source module
    dependency order #1
    #[]struct Char has copy drop store {
        byte: u8
    }
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 =  {
        locals:


        return 65536u64
    };
    #[]public native fun all_characters_printable(string: &(std=0x1)::ascii::String): bool;

    #[]public native fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8>;

    #[]public native fun byte(char: (std=0x1)::ascii::Char): u8;

    #[]public native fun char(byte: u8): (std=0x1)::ascii::Char;

    #[]public native fun into_bytes(string: (std=0x1)::ascii::String): vector<u8>;

    #[]public native fun is_printable_char(byte: u8): bool;

    #[]public native fun is_valid_char(b: u8): bool;

    #[]public native fun length(string: &(std=0x1)::ascii::String): u64;

    #[]public native fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char;

    #[]public native fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): ();

    #[]public native fun string(bytes: vector<u8>): (std=0x1)::ascii::String;

    #[]public native fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String>;


}
module (std=0x1)::bcs {
    #[]source module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]source module
    dependency order #0
    #[]struct BitVector has copy drop store {
        length: u64;
        bit_field: vector<bool>
    }
    #[]const EINDEX:u64 =  {
        locals:


        return 131072u64
    };
    #[]const ELENGTH:u64 =  {
        locals:


        return 131073u64
    };
    #[]const MAX_SIZE:u64 =  {
        locals:


        return 1024u64
    };
    #[]const WORD_SIZE:u64 =  {
        locals:


        return 1u64
    };
    #[]public native fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool;

    #[]public native fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64;

    #[]public native fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64;

    #[]public native fun new(length: u64): (std=0x1)::bit_vector::BitVector;

    #[]public native fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();

    #[]public native fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): ();

    #[]public native fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();


}
module (std=0x1)::error {
    #[]source module
    dependency order #0
    #[]const ABORTED:u64 =  {
        locals:


        return 7u64
    };
    #[]const ALREADY_EXISTS:u64 =  {
        locals:


        return 8u64
    };
    #[]const CANCELLED:u64 =  {
        locals:


        return 10u64
    };
    #[]const INTERNAL:u64 =  {
        locals:


        return 11u64
    };
    #[]const INVALID_ARGUMENT:u64 =  {
        locals:


        return 1u64
    };
    #[]const INVALID_STATE:u64 =  {
        locals:


        return 3u64
    };
    #[]const NOT_FOUND:u64 =  {
        locals:


        return 6u64
    };
    #[]const NOT_IMPLEMENTED:u64 =  {
        locals:


        return 12u64
    };
    #[]const OUT_OF_RANGE:u64 =  {
        locals:


        return 2u64
    };
    #[]const PERMISSION_DENIED:u64 =  {
        locals:


        return 5u64
    };
    #[]const RESOURCE_EXHAUSTED:u64 =  {
        locals:


        return 9u64
    };
    #[]const UNAUTHENTICATED:u64 =  {
        locals:


        return 4u64
    };
    #[]const UNAVAILABLE:u64 =  {
        locals:


        return 13u64
    };
    #[]public native fun aborted(r: u64): u64;

    #[]public native fun already_exists(r: u64): u64;

    #[]public native fun canonical(category: u64, reason: u64): u64;

    #[]public native fun internal(r: u64): u64;

    #[]public native fun invalid_argument(r: u64): u64;

    #[]public native fun invalid_state(r: u64): u64;

    #[]public native fun not_found(r: u64): u64;

    #[]public native fun not_implemented(r: u64): u64;

    #[]public native fun out_of_range(r: u64): u64;

    #[]public native fun permission_denied(r: u64): u64;

    #[]public native fun resource_exhausted(r: u64): u64;

    #[]public native fun unauthenticated(r: u64): u64;

    #[]public native fun unavailable(r: u64): u64;


}
module (std=0x1)::fixed_point32 {
    #[]source module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        value: u64
    }
    #[]const EDENOMINATOR:u64 =  {
        locals:


        return 65537u64
    };
    #[]const EDIVISION:u64 =  {
        locals:


        return 131074u64
    };
    #[]const EDIVISION_BY_ZERO:u64 =  {
        locals:


        return 65540u64
    };
    #[]const EMULTIPLICATION:u64 =  {
        locals:


        return 131075u64
    };
    #[]const ERATIO_OUT_OF_RANGE:u64 =  {
        locals:


        return 131077u64
    };
    #[]const MAX_U64:u128 =  {
        locals:


        return 18446744073709551615u128
    };
    #[]public native fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool;

    #[]public native fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64;


}
module (std=0x1)::hash {
    #[]source module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]source module
    dependency order #0
    #[]struct Option<Element#1> has copy drop store {
        vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 =  {
        locals:


        return 262144u64
    };
    #[]const EOPTION_NOT_SET:u64 =  {
        locals:


        return 262145u64
    };
    #[]public native fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2;

    #[]public native fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3;

    #[]public native fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4;

    #[]public native fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool;

    #[]public native fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): ();

    #[]public native fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7;

    #[]public native fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop;

    #[]public native fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9;

    #[]public native fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): ();

    #[]public native fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop;

    #[]public native fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool;

    #[]public native fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool;

    #[]public native fun none<Element#22>(): (std=0x1)::option::Option<Element#22>;

    #[]public native fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23>;

    #[]public native fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24;

    #[]public native fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25>;

    #[]public native fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26>;


}
module (std=0x1)::signer {
    #[]source module
    dependency order #0
    #[]public native fun address_of(s: &signer): address;

    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]source module
    dependency order #2
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 =  {
        locals:


        return 2u64
    };
    #[]const EINVALID_UTF8:u64 =  {
        locals:


        return 1u64
    };
    #[]public native fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): ();

    #[]public native fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): ();

    #[]public native fun bytes(s: &(std=0x1)::string::String): &vector<u8>;

    #[]public native fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64;

    #[]public native fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): ();

    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public native fun is_empty(s: &(std=0x1)::string::String): bool;

    #[]public native fun length(s: &(std=0x1)::string::String): u64;

    #[]public native fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String;

    #[]public native fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String>;

    #[]public native fun utf8(bytes: vector<u8>): (std=0x1)::string::String;


}
module (std=0x1)::type_name {
    #[]source module
    dependency order #3
    #[]struct TypeName has copy drop store {
        name: (std=0x1)::ascii::String
    }
    #[]public native fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String;

    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public native fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String;


}
module (std=0x1)::vector {
    #[]source module
    dependency order #4
    #[]const EINDEX_OUT_OF_BOUNDS:u64 =  {
        locals:


        return 131072u64
    };
    #[]public native fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): ();

    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public native fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool;

    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public native fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64);

    #[]public native fun is_empty<Element#41>(v: &vector<Element#41>): bool;

    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public native fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47;

    #[]public native fun reverse<Element#48>(v: &mut vector<Element#48>): ();

    #[]public native fun singleton<Element#49>(e: Element#49): vector<Element#49>;

    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public native fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51;


}
module 0x42::Test {
    #[]library module
    dependency order #5
    #[]public fun test_filter(): vector<u64> {
        locals:
            %#1: &mut vector<u64>,
            %#2: u64,
            e#3: &u64,
            i#2: u64,
            v: vector<u64>,
            v#0: &mut vector<u64>

        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        while ( {
            pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
            ;
            copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))
        }) {
            ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
            (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
            if (*copy e#3 > 1u64)  {
                pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
                pop  = /*;()*/
            } else  {
                (i#2: u64) = copy i#2 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        };
        pop  = /*()*/;
        return copy v
    }

}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*copy e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = copy i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        return copy v
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*copy e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = copy i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        return copy v
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*move#last e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = move#last i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        pop _ = move#last v#0;
        return move#last v
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#value<u64>[1u64, 2u64, 3u64];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*move#last e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = move#last i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        pop _ = move#last v#0;
        return move#last v
After cfgir: program = module (std=0x1)::ascii {
    #[]source module
    dependency order #1
    #[]struct Char has copy drop store {
        byte: u8
    }
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public native all_characters_printable(string: &(std=0x1)::ascii::String): bool;

    #[]public native as_bytes(string: &(std=0x1)::ascii::String): &vector<u8>;

    #[]public native byte(char: (std=0x1)::ascii::Char): u8;

    #[]public native char(byte: u8): (std=0x1)::ascii::Char;

    #[]public native into_bytes(string: (std=0x1)::ascii::String): vector<u8>;

    #[]public native is_printable_char(byte: u8): bool;

    #[]public native is_valid_char(b: u8): bool;

    #[]public native length(string: &(std=0x1)::ascii::String): u64;

    #[]public native pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char;

    #[]public native push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): ();

    #[]public native string(bytes: vector<u8>): (std=0x1)::ascii::String;

    #[]public native try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String>;


}
module (std=0x1)::bcs {
    #[]source module
    dependency order #0
    #[]public native to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]source module
    dependency order #0
    #[]struct BitVector has copy drop store {
        length: u64;
        bit_field: vector<bool>
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public native is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool;

    #[]public native length(bitvector: &(std=0x1)::bit_vector::BitVector): u64;

    #[]public native longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64;

    #[]public native new(length: u64): (std=0x1)::bit_vector::BitVector;

    #[]public native set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();

    #[]public native shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): ();

    #[]public native unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): ();


}
module (std=0x1)::error {
    #[]source module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public native aborted(r: u64): u64;

    #[]public native already_exists(r: u64): u64;

    #[]public native canonical(category: u64, reason: u64): u64;

    #[]public native internal(r: u64): u64;

    #[]public native invalid_argument(r: u64): u64;

    #[]public native invalid_state(r: u64): u64;

    #[]public native not_found(r: u64): u64;

    #[]public native not_implemented(r: u64): u64;

    #[]public native out_of_range(r: u64): u64;

    #[]public native permission_denied(r: u64): u64;

    #[]public native resource_exhausted(r: u64): u64;

    #[]public native unauthenticated(r: u64): u64;

    #[]public native unavailable(r: u64): u64;


}
module (std=0x1)::fixed_point32 {
    #[]source module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public native ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool;

    #[]public native max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32;

    #[]public native multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64;

    #[]public native round(num: (std=0x1)::fixed_point32::FixedPoint32): u64;


}
module (std=0x1)::hash {
    #[]source module
    dependency order #0
    #[]public native sha2_256(data: vector<u8>): vector<u8>;

    #[]public native sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]source module
    dependency order #0
    #[]struct Option<Element#1> has copy drop store {
        vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public native borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2;

    #[]public native borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3;

    #[]public native borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4;

    #[]public native contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool;

    #[]public native destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): ();

    #[]public native destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7;

    #[]public native destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop;

    #[]public native extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9;

    #[]public native fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): ();

    #[]public native get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop;

    #[]public native is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool;

    #[]public native is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool;

    #[]public native none<Element#22>(): (std=0x1)::option::Option<Element#22>;

    #[]public native some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23>;

    #[]public native swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24;

    #[]public native swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25>;

    #[]public native to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26>;


}
module (std=0x1)::signer {
    #[]source module
    dependency order #0
    #[]public native address_of(s: &signer): address;

    #[]public native borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]source module
    dependency order #2
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public native append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): ();

    #[]public native append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): ();

    #[]public native bytes(s: &(std=0x1)::string::String): &vector<u8>;

    #[]public native index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64;

    #[]public native insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): ();

    #[] native internal_check_utf8(v: &vector<u8>): bool;

    #[] native internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public native is_empty(s: &(std=0x1)::string::String): bool;

    #[]public native length(s: &(std=0x1)::string::String): u64;

    #[]public native sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String;

    #[]public native try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String>;

    #[]public native utf8(bytes: vector<u8>): (std=0x1)::string::String;


}
module (std=0x1)::type_name {
    #[]source module
    dependency order #3
    #[]struct TypeName has copy drop store {
        name: (std=0x1)::ascii::String
    }
    #[]public native borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String;

    #[]public native get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public native into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String;


}
module (std=0x1)::vector {
    #[]source module
    dependency order #4
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public native append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): ();

    #[bytecode_instruction]public native borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public native contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool;

    #[bytecode_instruction]public native destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native empty<Element#33>(): vector<Element#33>;

    #[]public native index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64);

    #[]public native is_empty<Element#41>(v: &vector<Element#41>): bool;

    #[bytecode_instruction]public native length<Element#42>(v: &vector<Element#42>): u64;

    #[bytecode_instruction]public native pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public native remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47;

    #[]public native reverse<Element#48>(v: &mut vector<Element#48>): ();

    #[]public native singleton<Element#49>(e: Element#49): vector<Element#49>;

    #[bytecode_instruction]public native swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public native swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51;


}
module 0x42::Test {
    #[]library module
    dependency order #5
    #[]public test_filter(): vector<u64> {
        locals:
            %#1: &mut vector<u64>,
            %#2: u64,
            e#3: &u64,
            i#2: u64,
            v: vector<u64>,
            v#0: &mut vector<u64>

        loop heads:

            1

        start=0

        label 0:
            (v: vector<u64>) = vector#value<u64>[1u64, 2u64, 3u64];
            (v#0: &mut vector<u64>) = &mut v;
            (i#2: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
            ;
            jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

        
        label 2:
            ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
            (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
            jump_if(*move#last e#3 > 1u64) 3 else 4

        
        label 3:
            pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
            jump 5

        
        label 4:
            (i#2: u64) = move#last i#2 + 1u64;
            jump 5

        
        label 5:
            jump 1

        
        label 6:
            pop _ = move#last v#0;
            return move#last v


    }

}
test move_check_testsuite::inlining/inline_fun.move ... [0m[32mok[0m

test result: [0m[32mok[0m. 1 passed; 0 failed; 0 ignored; 0 measured; 952 filtered out; finished in 0.05s

     Running unittests src/lib.rs (target/debug/deps/move_compiler_transactional_tests-c177729137e383c6)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/tests.rs (target/debug/deps/tests-351da09fae6302f2)

running 1 test
Before expansion: program = ------ Lib Defs: ------

------ Source Defs: ------
no package
std => 0x1
module std::ascii {
    use std::vector;use std::option:: {
        Self, Option
    };const EINVALID_ASCII_CHARACTER:u64 = 0x10000;copy drop storestruct String {
        bytes: vector<u8>
    }spec String{invariant forall i in 0 .. len(bytes) : is_valid_char(bytes[i])}copy drop storestruct Char {
        byte: u8
    }spec Char{invariant is_valid_char(byte)}public fun char(byte: u8): Char {
        assert!(is_valid_char(byte), EINVALID_ASCII_CHARACTER);
        Char{byte: byte}
    }spec char{aborts_if ! is_valid_char(byte)EINVALID_ASCII_CHARACTER}public fun string(bytes: vector<u8>): String {
        let x = try_string(bytes);
        assert!(option::is_some(&x), EINVALID_ASCII_CHARACTER);
        option::destroy_some(x)
    }spec string{aborts_if exists i in 0 .. len(bytes) : ! is_valid_char(bytes[i])EINVALID_ASCII_CHARACTER}public fun try_string(bytes: vector<u8>): Option<String> {
        let len = vector::length(&bytes);
        let i = 0;
        while ( {
            spec {spec {invariant i <= len;
            invariant forall j in 0 .. i : is_valid_char(bytes[j])}};
            i < len
        }) {
            let possible_byte = *vector::borrow(&bytes, i);
            if (! is_valid_char(possible_byte)) return option::none();
            i = i + 1;

        };
        spec {spec {assert i == len;
        assert forall j in 0 .. len : is_valid_char(bytes[j])}};
        option::some(String{bytes: bytes})
    }public fun all_characters_printable(string: &String): bool {
        let len = vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec {spec {invariant i <= len;
            invariant forall j in 0 .. i : is_printable_char(string.bytes[j])}};
            i < len
        }) {
            let byte = *vector::borrow(&string.bytes, i);
            if (! is_printable_char(byte)) return false;
            i = i + 1;

        };
        spec {spec {assert i == len;
        assert forall j in 0 .. len : is_printable_char(string.bytes[j])}};
        true
    }spec all_characters_printable{ensures result ==> forall j in 0 .. len(string.bytes) : is_printable_char(string.bytes[j])}public fun push_char(string: &mut String, char: Char): () {
        vector::push_back(&mut string.bytes, char.byte);

    }spec push_char{ensures len(string.bytes) == len(old(string.bytes)) + 1}public fun pop_char(string: &mut String): Char {
        Char{byte: vector::pop_back(&mut string.bytes)}
    }spec pop_char{ensures len(string.bytes) == len(old(string.bytes)) - 1}public fun length(string: &String): u64 {
        vector::length(as_bytes(string))
    }public fun as_bytes(string: &String): &vector<u8> {
        &string.bytes
    }public fun into_bytes(string: String): vector<u8> {
        let String{bytes: bytes} = string;
        bytes
    }public fun byte(char: Char): u8 {
        let Char{byte: byte} = char;
        byte
    }public fun is_valid_char(b: u8): bool {
        b <= 0x7F
    }public fun is_printable_char(byte: u8): bool {
        byte >= 0x20 && byte <= 0x7E
    }
}no package
std => 0x1
module std::bcs {
    public native fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;
    spec module {}spec module {native fun serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }
}no package
std => 0x1
module std::bit_vector {
    use std::vector;const EINDEX:u64 = 0x20000;const ELENGTH:u64 = 0x20001;const WORD_SIZE:u64 = 1;const MAX_SIZE:u64 = 1024;copy drop storestruct BitVector {
        length: u64;
        bit_field: vector<bool>
    }public fun new(length: u64): BitVector {
        assert!(length > 0, ELENGTH);
        assert!(length < MAX_SIZE, ELENGTH);
        let counter = 0;
        let bit_field = vector::empty();
        while ( {
            spec {spec {invariant counter <= length;
            invariant len(bit_field) == counter}};
            counter < length
        }) {
            vector::push_back(&mut bit_field, false);
            counter = counter + 1;

        };
        spec {spec {assert counter == length;
        assert len(bit_field) == length}};
        BitVector{length: length, bit_field: bit_field}
    }spec new{include NewAbortsIf;
    ensures result.length == length;
    ensures len(result.bit_field) == length}spec schema NewAbortsIf{locallength: u64;
    aborts_if length <= 0ELENGTH;
    aborts_if length >= MAX_SIZEELENGTH}public fun set(bitvector: &mut BitVector, bit_index: u64): () {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;

    }spec set{include SetAbortsIf;
    ensures bitvector.bit_field[bit_index]}spec schema SetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}public fun unset(bitvector: &mut BitVector, bit_index: u64): () {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;

    }spec unset{include UnsetAbortsIf;
    ensures ! bitvector.bit_field[bit_index]}spec schema UnsetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}public fun shift_left(bitvector: &mut BitVector, amount: u64): () {
        if (amount >= bitvector.length)  {
            let len = vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;

            };

        } else  {
            let i = amount;
            while (i < bitvector.length) {
                if (is_index_set(bitvector, i)) set(bitvector, i - amount) else unset(bitvector, i - amount);
                i = i + 1;

            };
            i = bitvector.length - amount;
            while (i < bitvector.length) {
                unset(bitvector, i);
                i = i + 1;

            };

        }
    }public fun is_index_set(bitvector: &BitVector, bit_index: u64): bool {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        *vector::borrow(&bitvector.bit_field, bit_index)
    }spec is_index_set{include IsIndexSetAbortsIf;
    ensures result == bitvector.bit_field[bit_index]}spec schema IsIndexSetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}spec module {fun spec_is_index_set(bitvector: BitVector, bit_index: u64): bool {
        if (bit_index >= length(bitvector))  {
            false
        } else  {
            bitvector.bit_field[bit_index]
        }
    }}public fun length(bitvector: &BitVector): u64 {
        vector::length(&bitvector.bit_field)
    }public fun longest_set_sequence_starting_at(bitvector: &BitVector, start_index: u64): u64 {
        assert!(start_index < bitvector.length, EINDEX);
        let index = start_index;
        while (index < bitvector.length) {
            if (! is_index_set(bitvector, index)) break;
            index = index + 1;

        };
        index - start_index
    }
}no package
std => 0x1
module std::error {
    const INVALID_ARGUMENT:u64 = 0x1;const OUT_OF_RANGE:u64 = 0x2;const INVALID_STATE:u64 = 0x3;const UNAUTHENTICATED:u64 = 0x4;const PERMISSION_DENIED:u64 = 0x5;const NOT_FOUND:u64 = 0x6;const ABORTED:u64 = 0x7;const ALREADY_EXISTS:u64 = 0x8;const RESOURCE_EXHAUSTED:u64 = 0x9;const CANCELLED:u64 = 0xA;const INTERNAL:u64 = 0xB;const NOT_IMPLEMENTED:u64 = 0xC;const UNAVAILABLE:u64 = 0xD;public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }public fun invalid_argument(r: u64): u64 {
        canonical(INVALID_ARGUMENT, r)
    }public fun out_of_range(r: u64): u64 {
        canonical(OUT_OF_RANGE, r)
    }public fun invalid_state(r: u64): u64 {
        canonical(INVALID_STATE, r)
    }public fun unauthenticated(r: u64): u64 {
        canonical(UNAUTHENTICATED, r)
    }public fun permission_denied(r: u64): u64 {
        canonical(PERMISSION_DENIED, r)
    }public fun not_found(r: u64): u64 {
        canonical(NOT_FOUND, r)
    }public fun aborted(r: u64): u64 {
        canonical(ABORTED, r)
    }public fun already_exists(r: u64): u64 {
        canonical(ALREADY_EXISTS, r)
    }public fun resource_exhausted(r: u64): u64 {
        canonical(RESOURCE_EXHAUSTED, r)
    }public fun internal(r: u64): u64 {
        canonical(INTERNAL, r)
    }public fun not_implemented(r: u64): u64 {
        canonical(NOT_IMPLEMENTED, r)
    }public fun unavailable(r: u64): u64 {
        canonical(UNAVAILABLE, r)
    }
}no package
std => 0x1
module std::fixed_point32 {
    copy drop storestruct FixedPoint32 {
        value: u64
    }const MAX_U64:u128 = 18446744073709551615;const EDENOMINATOR:u64 = 0x10001;const EDIVISION:u64 = 0x20002;const EMULTIPLICATION:u64 = 0x20003;const EDIVISION_BY_ZERO:u64 = 0x10004;const ERATIO_OUT_OF_RANGE:u64 = 0x20005;public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64 {
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert!(product <= MAX_U64, EMULTIPLICATION);
        (product as u64)
    }spec multiply_u64{pragma opaque;
    include MultiplyAbortsIf;
    ensures result == spec_multiply_u64(val, multiplier)}spec schema MultiplyAbortsIf{localval: num;
    localmultiplier: FixedPoint32;
    aborts_if spec_multiply_u64(val, multiplier) > MAX_U64EMULTIPLICATION}spec module {fun spec_multiply_u64(val: num, multiplier: FixedPoint32): num {
        val * multiplier.value >> 32
    }}public fun divide_u64(val: u64, divisor: FixedPoint32): u64 {
        assert!(divisor.value != 0, EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / (divisor.value as u128);
        assert!(quotient <= MAX_U64, EDIVISION);
        (quotient as u64)
    }spec divide_u64{pragma opaque;
    include DivideAbortsIf;
    ensures result == spec_divide_u64(val, divisor)}spec schema DivideAbortsIf{localval: num;
    localdivisor: FixedPoint32;
    aborts_if divisor.value == 0EDIVISION_BY_ZERO;
    aborts_if spec_divide_u64(val, divisor) > MAX_U64EDIVISION}spec module {fun spec_divide_u64(val: num, divisor: FixedPoint32): num {
        val << 32 / divisor.value
    }}public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert!(scaled_denominator != 0, EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);
        assert!(quotient <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32{value: (quotient as u64)}
    }spec create_from_rational{pragma verify = false;
    pragma opaque;
    include CreateFromRationalAbortsIf;
    ensures result == spec_create_from_rational(numerator, denominator)}spec schema CreateFromRationalAbortsIf{localnumerator: u64;
    localdenominator: u64;
    let scaled_numerator = (numerator as u128) << 64;
    let scaled_denominator = (denominator as u128) << 32;
    let quotient = scaled_numerator / scaled_denominator;
    aborts_if scaled_denominator == 0EDENOMINATOR;
    aborts_if quotient == 0 && scaled_numerator != 0ERATIO_OUT_OF_RANGE;
    aborts_if quotient > MAX_U64ERATIO_OUT_OF_RANGE}spec module {fun spec_create_from_rational(numerator: num, denominator: num): FixedPoint32 {
        FixedPoint32{value: numerator << 64 / denominator << 32}
    }}public fun create_from_raw_value(value: u64): FixedPoint32 {
        FixedPoint32{value: value}
    }spec create_from_raw_value{pragma opaque;
    aborts_if false;
    ensures result.value == value}public fun get_raw_value(num: FixedPoint32): u64 {
        num.value
    }public fun is_zero(num: FixedPoint32): bool {
        num.value == 0
    }public fun min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }spec min{pragma opaque;
    aborts_if false;
    ensures result == spec_min(num1, num2)}spec module {fun spec_min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }}public fun max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }spec max{pragma opaque;
    aborts_if false;
    ensures result == spec_max(num1, num2)}spec module {fun spec_max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }}public fun create_from_u64(val: u64): FixedPoint32 {
        let value = (val as u128) << 32;
        assert!(value <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32{value: (value as u64)}
    }spec create_from_u64{pragma opaque;
    include CreateFromU64AbortsIf;
    ensures result == spec_create_from_u64(val)}spec schema CreateFromU64AbortsIf{localval: num;
    let scaled_value = (val as u128) << 32;
    aborts_if scaled_value > MAX_U64}spec module {fun spec_create_from_u64(val: num): FixedPoint32 {
        FixedPoint32{value: val << 32}
    }}public fun floor(num: FixedPoint32): u64 {
        num.value >> 32
    }spec floor{pragma opaque;
    aborts_if false;
    ensures result == spec_floor(num)}spec module {fun spec_floor(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional >> 32
        }
    }}public fun ceil(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        if (num.value == floored_num)  {
            return floored_num >> 32
        };
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }spec ceil{pragma verify = false;
    pragma opaque;
    aborts_if false;
    ensures result == spec_ceil(num)}spec module {fun spec_ceil(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let one = 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}public fun round(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if (num.value < boundary)  {
            floored_num >> 32
        } else  {
            ceil(num)
        }
    }spec round{pragma opaque;
    pragma timeout = 120;
    aborts_if false;
    ensures result == spec_round(num)}spec module {fun spec_round(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let boundary = 1 << 32 / 2;
        let one = 1 << 32;
        if (fractional < boundary)  {
            val.value - fractional >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}spec module {}spec module {pragma aborts_if_is_strict}
}no package
std => 0x1
module std::hash {
    public native fun sha2_256(data: vector<u8>): vector<u8>;
    public native fun sha3_256(data: vector<u8>): vector<u8>;

}no package
std => 0x1
module std::option {
    use std::vector;copy drop storestruct Option<Element> {
        vec: vector<Element>
    }spec Option{invariant len(vec) <= 1}const EOPTION_IS_SET:u64 = 0x40000;const EOPTION_NOT_SET:u64 = 0x40001;public fun none<Element>(): Option<Element> {
        Option{vec: vector::empty()}
    }spec none{pragma opaque;
    aborts_if false;
    ensures result == spec_none<Element>()}spec module {fun spec_none<Element>(): Option<Element> {
        Option{vec: vec()}
    }}public fun some<Element>(e: Element): Option<Element> {
        Option{vec: vector::singleton(e)}
    }spec some{pragma opaque;
    aborts_if false;
    ensures result == spec_some(e)}spec module {fun spec_some<Element>(e: Element): Option<Element> {
        Option{vec: vec(e)}
    }}public fun is_none<Element>(t: &Option<Element>): bool {
        vector::is_empty(&t.vec)
    }spec is_none{pragma opaque;
    aborts_if false;
    ensures result == is_none(t)}public fun is_some<Element>(t: &Option<Element>): bool {
        ! vector::is_empty(&t.vec)
    }spec is_some{pragma opaque;
    aborts_if false;
    ensures result == is_some(t)}public fun contains<Element>(t: &Option<Element>, e_ref: &Element): bool {
        vector::contains(&t.vec, e_ref)
    }spec contains{pragma opaque;
    aborts_if false;
    ensures result == spec_contains(t, e_ref)}spec module {fun spec_contains<Element>(t: Option<Element>, e: Element): bool {
        is_some(t) && borrow(t) == e
    }}public fun borrow<Element>(t: &Option<Element>): &Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow(&t.vec, 0)
    }spec borrow{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t)}public fun borrow_with_default<Element>(t: &Option<Element>, default_ref: &Element): &Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default_ref else vector::borrow(vec_ref, 0)
    }spec borrow_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default_ref}public fun get_with_default<Element: copy+drop>(t: &Option<Element>, default: Element): Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default else *vector::borrow(vec_ref, 0)
    }spec get_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default}public fun fill<Element>(t: &mut Option<Element>, e: Element): () {
        let vec_ref = &mut t.vec;
        if (vector::is_empty(vec_ref)) vector::push_back(vec_ref, e) else abort EOPTION_IS_SET
    }spec fill{pragma opaque;
    aborts_if is_some(t)EOPTION_IS_SET;
    ensures is_some(t);
    ensures borrow(t) == e}public fun extract<Element>(t: &mut Option<Element>): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::pop_back(&mut t.vec)
    }spec extract{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(old(t));
    ensures is_none(t)}public fun borrow_mut<Element>(t: &mut Option<Element>): &mut Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow_mut(&mut t.vec, 0)
    }spec borrow_mut{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t);
    ensures t == old(t)}public fun swap<Element>(t: &mut Option<Element>, e: Element): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = vector::pop_back(vec_ref);
        vector::push_back(vec_ref, e);
        old_value
    }spec swap{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(old(t));
    ensures is_some(t);
    ensures borrow(t) == e}public fun swap_or_fill<Element>(t: &mut Option<Element>, e: Element): Option<Element> {
        let vec_ref = &mut t.vec;
        let old_value = if (vector::is_empty(vec_ref)) none() else some(vector::pop_back(vec_ref));
        vector::push_back(vec_ref, e);
        old_value
    }spec swap_or_fill{pragma opaque;
    ensures result == old(t);
    ensures borrow(t) == e}public fun destroy_with_default<Element: drop>(t: Option<Element>, default: Element): Element {
        let Option{vec: vec} = t;
        if (vector::is_empty(&mut vec)) default else vector::pop_back(&mut vec)
    }spec destroy_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default}public fun destroy_some<Element>(t: Option<Element>): Element {
        assert!(is_some(&t), EOPTION_NOT_SET);
        let Option{vec: vec} = t;
        let elem = vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
        elem
    }spec destroy_some{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t)}public fun destroy_none<Element>(t: Option<Element>): () {
        assert!(is_none(&t), EOPTION_IS_SET);
        let Option{vec: vec} = t;
        vector::destroy_empty(vec)
    }spec destroy_none{pragma opaque;
    aborts_if is_some(t)EOPTION_IS_SET}public fun to_vec<Element>(t: Option<Element>): vector<Element> {
        let Option{vec: vec} = t;
        vec
    }spec to_vec{pragma opaque;
    aborts_if false;
    ensures result == t.vec}public inline fun for_each<Element>(o: Option<Element>, f: (Element):()): () {
        if (is_some(&o))  {
            f(destroy_some(o))
        } else  {
            destroy_none(o)
        }
    }public inline fun for_each_ref<Element>(o: &Option<Element>, f: (&Element):()): () {
        if (is_some(o))  {
            f(borrow(o))
        }
    }public inline fun for_each_mut<Element>(o: &mut Option<Element>, f: (&mut Element):()): () {
        if (is_some(o))  {
            f(borrow_mut(o))
        }
    }public inline fun fold<Accumulator, Element>(o: Option<Element>, init: Accumulator, f: (Accumulator, Element):Accumulator): Accumulator {
        if (is_some(&o))  {
            f(init, destroy_some(o))
        } else  {
            destroy_none(o);
            init
        }
    }public inline fun map<Element, OtherElement>(o: Option<Element>, f: (Element):OtherElement): Option<OtherElement> {
        if (is_some(&o))  {
            some(f(destroy_some(o)))
        } else  {
            destroy_none(o);
            none()
        }
    }public inline fun filter<Element: drop>(o: Option<Element>, f: (&Element):bool): Option<Element> {
        if (is_some(&o) && f(borrow(&o)))  {
            o
        } else  {
            none()
        }
    }spec module {}spec module {pragma aborts_if_is_strict}spec schema AbortsIfNone<Element>{localt: Option<Element>;
    aborts_if is_none(t)EOPTION_NOT_SET}
}no package
std => 0x1
module std::signer {
    public native fun borrow_address(s: &signer): &address;
    public fun address_of(s: &signer): address {
        *borrow_address(s)
    }spec module {native fun is_txn_signer(s: signer): bool;
    }spec module {native fun is_txn_signer_addr(a: address): bool;
    }
}no package
std => 0x1
module std::string {
    use std::vector;use std::option:: {
        Self, Option
    };const EINVALID_UTF8:u64 = 1;const EINVALID_INDEX:u64 = 2;copy drop storestruct String {
        bytes: vector<u8>
    }public fun utf8(bytes: vector<u8>): String {
        assert!(internal_check_utf8(&bytes), EINVALID_UTF8);
        String{bytes: bytes}
    }public fun try_utf8(bytes: vector<u8>): Option<String> {
        if (internal_check_utf8(&bytes))  {
            option::some(String{bytes: bytes})
        } else  {
            option::none()
        }
    }public fun bytes(s: &String): &vector<u8> {
        &s.bytes
    }public fun is_empty(s: &String): bool {
        vector::is_empty(&s.bytes)
    }public fun length(s: &String): u64 {
        vector::length(&s.bytes)
    }public fun append(s: &mut String, r: String): () {
        vector::append(&mut s.bytes, r.bytes)
    }public fun append_utf8(s: &mut String, bytes: vector<u8>): () {
        append(s, utf8(bytes))
    }public fun insert(s: &mut String, at: u64, o: String): () {
        let bytes = &s.bytes;
        assert!(at <= vector::length(bytes) && internal_is_char_boundary(bytes, at), EINVALID_INDEX);
        let l = length(s);
        let front = sub_string(s, 0, at);
        let end = sub_string(s, at, l);
        append(&mut front, o);
        append(&mut front, end);
        *s = front;

    }public fun sub_string(s: &String, i: u64, j: u64): String {
        let bytes = &s.bytes;
        let l = vector::length(bytes);
        assert!(j <= l && i <= j && internal_is_char_boundary(bytes, i) && internal_is_char_boundary(bytes, j), EINVALID_INDEX);
        String{bytes: internal_sub_string(bytes, i, j)}
    }public fun index_of(s: &String, r: &String): u64 {
        internal_index_of(&s.bytes, &r.bytes)
    } native fun internal_check_utf8(v: &vector<u8>): bool;
     native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;
     native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;
     native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

}no package
std => 0x1
module std::type_name {
    use std::ascii:: {
        String
    };copy drop storestruct TypeName {
        name: String
    }public native fun get<T>(): TypeName;
    public fun borrow_string(self: &TypeName): &String {
        &self.name
    }public fun into_string(self: TypeName): String {
        self.name
    }
}no package
std => 0x1
module std::vector {
    const EINDEX_OUT_OF_BOUNDS:u64 = 0x20000;#[bytecode_instruction]public native fun empty<Element>(): vector<Element>;
    #[bytecode_instruction]public native fun length<Element>(v: &vector<Element>): u64;
    #[bytecode_instruction]public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;
    #[bytecode_instruction]public native fun push_back<Element>(v: &mut vector<Element>, e: Element): ();
    #[bytecode_instruction]public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;
    #[bytecode_instruction]public native fun pop_back<Element>(v: &mut vector<Element>): Element;
    #[bytecode_instruction]public native fun destroy_empty<Element>(v: vector<Element>): ();
    #[bytecode_instruction]public native fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64): ();
    public fun singleton<Element>(e: Element): vector<Element> {
        let v = empty();
        push_back(&mut v, e);
        v
    }spec singleton{aborts_if false;
    ensures result == vec(e)}public fun reverse<Element>(v: &mut vector<Element>): () {
        let len = length(v);
        if (len == 0) return ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;

        }
    }spec reverse{pragma intrinsic = true}public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>): () {
        reverse(&mut other);
        while (! is_empty(&other))push_back(lhs, pop_back(&mut other));
        destroy_empty(other);

    }spec append{pragma intrinsic = true}spec is_empty{pragma intrinsic = true}public fun is_empty<Element>(v: &vector<Element>): bool {
        length(v) == 0
    }public fun contains<Element>(v: &vector<Element>, e: &Element): bool {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return true;
            i = i + 1;

        };
        false
    }spec contains{pragma intrinsic = true}public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return (true, i);
            i = i + 1;

        };
        (false, 0)
    }spec index_of{pragma intrinsic = true}public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {
        let len = length(v);
        if (i >= len) abort EINDEX_OUT_OF_BOUNDS;
        len = len - 1;
        while (i < len)swap(v, i,  {
            i = i + 1;
            i
        });
        pop_back(v)
    }spec remove{pragma intrinsic = true}public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {
        assert!(! is_empty(v), EINDEX_OUT_OF_BOUNDS);
        let last_idx = length(v) - 1;
        swap(v, i, last_idx);
        pop_back(v)
    }spec swap_remove{pragma intrinsic = true}public inline fun for_each<Element>(v: vector<Element>, f: (Element):()): () {
        reverse(&mut v);
        while (! is_empty(&v)) {
            let e = pop_back(&mut v);
            f(e);

        };

    }public inline fun for_each_ref<Element>(v: &vector<Element>, f: (&Element):()): () {
        let i = 0;
        while (i < length(v)) {
            f(borrow(v, i));
            i = i + 1
        }
    }public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: (&mut Element):()): () {
        let i = 0;
        while (i < length(v)) {
            f(borrow_mut(v, i));
            i = i + 1
        }
    }public inline fun fold<Accumulator, Element>(v: vector<Element>, init: Accumulator, f: (Accumulator, Element):Accumulator): Accumulator {
        let accu = init;
        for_each(v, |elem|accu = f(accu, elem));
        accu
    }public inline fun map<Element, NewElement>(v: vector<Element>, f: (Element):NewElement): vector<NewElement> {
        let result = vector<NewElement>[];
        for_each(v, |elem|push_back(&mut result, f(elem)));
        result
    }public inline fun filter<Element: drop>(v: vector<Element>, p: (&Element):bool): vector<Element> {
        let result = vector<Element>[];
        for_each(v, |elem| {
            if (p(&elem)) push_back(&mut result, elem);

        });
        result
    }spec module {}spec module {fun eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
        len(v1) == len(v2) + 1 && v1[len(v1) - 1] == e && v1[0 .. len(v1) - 1] == v2[0 .. len(v2)]
    };
    fun eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
        len(v) == len(v1) + len(v2) && v[0 .. len(v1)] == v1 && v[len(v1) .. len(v)] == v2
    };
    fun eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1 == v2[1 .. len(v2)]
    };
    fun eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1[0 .. i] == v2[0 .. i] && v1[i .. len(v1)] == v2[i + 1 .. len(v2)]
    }}
}
After expansion: program = module (std=0x1)::ascii {
    #[]source module
    dependency order #2
    neighbor#dependency (std=0x1)::option;
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len = (std=0x1)::vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec #0 uses [i, len, string];
            i < len
        }) {
            let byte = *(std=0x1)::vector::borrow(&string.bytes, i);
            if (! (std=0x1)::ascii::is_printable_char(byte)) return false else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [i, len, string];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char{0#byte: byte} = char;
        byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert!((std=0x1)::ascii::is_valid_char(byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::ascii::Char{0#byte: byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String{0#bytes: bytes} = string;
        bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        byte >= 32 && byte <= 126
    }
    #[]public fun is_valid_char(b: u8): bool {
        b <= 127
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length((std=0x1)::ascii::as_bytes(string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char{0#byte: (std=0x1)::vector::pop_back(&mut string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back(&mut string.bytes, char.byte);
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x = (std=0x1)::ascii::try_string(bytes);
        assert!((std=0x1)::option::is_some(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::option::destroy_some(x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len = (std=0x1)::vector::length(&bytes);
        let i = 0;
        while ( {
            spec #0 uses [bytes, i, len];
            i < len
        }) {
            let possible_byte = *(std=0x1)::vector::borrow(&bytes, i);
            if (! (std=0x1)::ascii::is_valid_char(possible_byte)) return (std=0x1)::option::none() else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [bytes, i, len];
        (std=0x1)::option::some((std=0x1)::ascii::String{0#bytes: bytes})
    }
     spec String{invariant forall i in 0 .. len(bytes) : (std=0x1)::ascii::is_valid_char(bytes[i])}
     spec Char{invariant (std=0x1)::ascii::is_valid_char(byte)}
     spec char{aborts_if ! (std=0x1)::ascii::is_valid_char(byte)(std=0x1)::ascii::EINVALID_ASCII_CHARACTER}
     spec string{aborts_if exists i in 0 .. len(bytes) : ! (std=0x1)::ascii::is_valid_char(bytes[i])(std=0x1)::ascii::EINVALID_ASCII_CHARACTER}
     spec all_characters_printable{ensures result ==> forall j in 0 .. len(string.bytes) : (std=0x1)::ascii::is_printable_char(string.bytes[j])}
     spec push_char{ensures len(string.bytes) == len(old(string.bytes)) + 1}
     spec pop_char{ensures len(string.bytes) == len(old(string.bytes)) - 1}

}
module (std=0x1)::bcs {
    #[]source module
    dependency order #0
    #[]public native fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;

     spec module {}
     spec module {native define serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }

}
module (std=0x1)::bit_vector {
    #[]source module
    dependency order #3
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        *(std=0x1)::vector::borrow(&bitvector.bit_field, bit_index)
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length(&bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert!(start_index < bitvector.length, (std=0x1)::bit_vector::EINDEX);
        let index = start_index;
        while (index < bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set(bitvector, index)) break else ();
            index = index + 1;
            /*()*/
        };
        index - start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert!(length > 0, (std=0x1)::bit_vector::ELENGTH);
        assert!(length < (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH);
        let counter = 0;
        let bit_field = (std=0x1)::vector::empty();
        while ( {
            spec #0 uses [bit_field, counter, length] applies [len];
            counter < length
        }) {
            (std=0x1)::vector::push_back(&mut bit_field, false);
            counter = counter + 1;
            /*()*/
        };
        spec #1 uses [bit_field, counter, length] applies [len];
        (std=0x1)::bit_vector::BitVector{1#bit_field: bit_field, 0#length: length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (amount >= bitvector.length)  {
            let len = (std=0x1)::vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;
                /*()*/
            };
            /*()*/
        } else  {
            let i = amount;
            while (i < bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set(bitvector, i)) (std=0x1)::bit_vector::set(bitvector, i - amount) else (std=0x1)::bit_vector::unset(bitvector, i - amount);
                i = i + 1;
                /*()*/
            };
            i = bitvector.length - amount;
            while (i < bitvector.length) {
                (std=0x1)::bit_vector::unset(bitvector, i);
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;
        /*()*/
    }
     spec new{include (std=0x1)::bit_vector::NewAbortsIf;
    ensures result.length == length;
    ensures len(result.bit_field) == length}
     spec schema NewAbortsIf{locallength: u64;
    aborts_if length <= 0(std=0x1)::bit_vector::ELENGTH;
    aborts_if length >= (std=0x1)::bit_vector::MAX_SIZE(std=0x1)::bit_vector::ELENGTH}
     spec set{include (std=0x1)::bit_vector::SetAbortsIf;
    ensures bitvector.bit_field[bit_index]}
     spec schema SetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec unset{include (std=0x1)::bit_vector::UnsetAbortsIf;
    ensures ! bitvector.bit_field[bit_index]}
     spec schema UnsetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec is_index_set{include (std=0x1)::bit_vector::IsIndexSetAbortsIf;
    ensures result == bitvector.bit_field[bit_index]}
     spec schema IsIndexSetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec module {define spec_is_index_set(bitvector: (std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        if (bit_index >= (std=0x1)::bit_vector::length(bitvector))  {
            false
        } else  {
            bitvector.bit_field[bit_index]
        }
    }}

}
module (std=0x1)::error {
    #[]source module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ABORTED, r)
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ALREADY_EXISTS, r)
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INTERNAL, r)
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_ARGUMENT, r)
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_STATE, r)
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_FOUND, r)
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_IMPLEMENTED, r)
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::OUT_OF_RANGE, r)
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::PERMISSION_DENIED, r)
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::RESOURCE_EXHAUSTED, r)
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAUTHENTICATED, r)
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAVAILABLE, r)
    }

}
module (std=0x1)::fixed_point32 {
    #[]source module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        if (num.value == floored_num)  {
            return floored_num >> 32
        } else ();
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert!(scaled_denominator != 0, (std=0x1)::fixed_point32::EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert!(quotient != 0 || numerator == 0, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        assert!(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value = (val as u128) << 32;
        assert!(value <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert!(divisor.value != 0, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / (divisor.value as u128);
        assert!(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION);
        (quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        num.value >> 32
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        num.value == 0
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert!(product <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION);
        (product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if (num.value < boundary)  {
            floored_num >> 32
        } else  {
            (std=0x1)::fixed_point32::ceil(num)
        }
    }
     spec multiply_u64{pragma opaque;
    include (std=0x1)::fixed_point32::MultiplyAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_multiply_u64(val, multiplier)}
     spec schema MultiplyAbortsIf{localval: num;
    localmultiplier: (std=0x1)::fixed_point32::FixedPoint32;
    aborts_if (std=0x1)::fixed_point32::spec_multiply_u64(val, multiplier) > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::EMULTIPLICATION}
     spec module {define spec_multiply_u64(val: num, multiplier: (std=0x1)::fixed_point32::FixedPoint32): num {
        val * multiplier.value >> 32
    }}
     spec divide_u64{pragma opaque;
    include (std=0x1)::fixed_point32::DivideAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_divide_u64(val, divisor)}
     spec schema DivideAbortsIf{localval: num;
    localdivisor: (std=0x1)::fixed_point32::FixedPoint32;
    aborts_if divisor.value == 0(std=0x1)::fixed_point32::EDIVISION_BY_ZERO;
    aborts_if (std=0x1)::fixed_point32::spec_divide_u64(val, divisor) > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::EDIVISION}
     spec module {define spec_divide_u64(val: num, divisor: (std=0x1)::fixed_point32::FixedPoint32): num {
        val << 32 / divisor.value
    }}
     spec create_from_rational{pragma verify = false;
    pragma opaque;
    include (std=0x1)::fixed_point32::CreateFromRationalAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_create_from_rational(numerator, denominator)}
     spec schema CreateFromRationalAbortsIf{localnumerator: u64;
    localdenominator: u64;
    let scaled_numerator = (numerator as u128) << 64;
    let scaled_denominator = (denominator as u128) << 32;
    let quotient = scaled_numerator / scaled_denominator;
    aborts_if scaled_denominator == 0(std=0x1)::fixed_point32::EDENOMINATOR;
    aborts_if quotient == 0 && scaled_numerator != 0(std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE;
    aborts_if quotient > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE}
     spec module {define spec_create_from_rational(numerator: num, denominator: num): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: numerator << 64 / denominator << 32}
    }}
     spec create_from_raw_value{pragma opaque;
    aborts_if false;
    ensures result.value == value}
     spec min{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_min(num1, num2)}
     spec module {define spec_min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }}
     spec max{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_max(num1, num2)}
     spec module {define spec_max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }}
     spec create_from_u64{pragma opaque;
    include (std=0x1)::fixed_point32::CreateFromU64AbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_create_from_u64(val)}
     spec schema CreateFromU64AbortsIf{localval: num;
    let scaled_value = (val as u128) << 32;
    aborts_if scaled_value > (std=0x1)::fixed_point32::MAX_U64}
     spec module {define spec_create_from_u64(val: num): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: val << 32}
    }}
     spec floor{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_floor(num)}
     spec module {define spec_floor(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional >> 32
        }
    }}
     spec ceil{pragma verify = false;
    pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_ceil(num)}
     spec module {define spec_ceil(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let one = 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}
     spec round{pragma opaque;
    pragma timeout = 120;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_round(num)}
     spec module {define spec_round(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let boundary = 1 << 32 / 2;
        let one = 1 << 32;
        if (fractional < boundary)  {
            val.value - fractional >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}
     spec module {}
     spec module {pragma aborts_if_is_strict}

}
module (std=0x1)::hash {
    #[]source module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]source module
    dependency order #1
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct Option<Element> has copy drop store {
        0#vec: vector<Element>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public fun borrow<Element>(t: &(std=0x1)::option::Option<Element>): &Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow(&t.vec, 0)
    }
    #[]public fun borrow_mut<Element>(t: &mut (std=0x1)::option::Option<Element>): &mut Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow_mut(&mut t.vec, 0)
    }
    #[]public fun borrow_with_default<Element>(t: &(std=0x1)::option::Option<Element>, default_ref: &Element): &Element {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default_ref else (std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun contains<Element>(t: &(std=0x1)::option::Option<Element>, e_ref: &Element): bool {
        (std=0x1)::vector::contains(&t.vec, e_ref)
    }
    #[]public fun destroy_none<Element>(t: (std=0x1)::option::Option<Element>): () {
        assert!((std=0x1)::option::is_none(&t), (std=0x1)::option::EOPTION_IS_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        (std=0x1)::vector::destroy_empty(vec)
    }
    #[]public fun destroy_some<Element>(t: (std=0x1)::option::Option<Element>): Element {
        assert!((std=0x1)::option::is_some(&t), (std=0x1)::option::EOPTION_NOT_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        let elem = (std=0x1)::vector::pop_back(&mut vec);
        (std=0x1)::vector::destroy_empty(vec);
        elem
    }
    #[]public fun destroy_with_default<Element: drop>(t: (std=0x1)::option::Option<Element>, default: Element): Element {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        if ((std=0x1)::vector::is_empty(&mut vec)) default else (std=0x1)::vector::pop_back(&mut vec)
    }
    #[]public fun extract<Element>(t: &mut (std=0x1)::option::Option<Element>): Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::pop_back(&mut t.vec)
    }
    #[]public fun fill<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): () {
        let vec_ref = &mut t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::vector::push_back(vec_ref, e) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public inline fun filter<Element: drop>(o: (std=0x1)::option::Option<Element>, f: |&Element|bool): (std=0x1)::option::Option<Element> {
        if ((std=0x1)::option::is_some(&o) && f((std=0x1)::option::borrow(&o)))  {
            o
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public inline fun fold<Accumulator, Element>(o: (std=0x1)::option::Option<Element>, init: Accumulator, f: |Accumulator, Element|Accumulator): Accumulator {
        if ((std=0x1)::option::is_some(&o))  {
            f(init, (std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o);
            init
        }
    }
    #[]public inline fun for_each<Element>(o: (std=0x1)::option::Option<Element>, f: |Element|()): () {
        if ((std=0x1)::option::is_some(&o))  {
            f((std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o)
        }
    }
    #[]public inline fun for_each_mut<Element>(o: &mut (std=0x1)::option::Option<Element>, f: |&mut Element|()): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow_mut(o))
        } else ()
    }
    #[]public inline fun for_each_ref<Element>(o: &(std=0x1)::option::Option<Element>, f: |&Element|()): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow(o))
        } else ()
    }
    #[]public fun get_with_default<Element: copy+drop>(t: &(std=0x1)::option::Option<Element>, default: Element): Element {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default else *(std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun is_none<Element>(t: &(std=0x1)::option::Option<Element>): bool {
        (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public fun is_some<Element>(t: &(std=0x1)::option::Option<Element>): bool {
        ! (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public inline fun map<Element, OtherElement>(o: (std=0x1)::option::Option<Element>, f: |Element|OtherElement): (std=0x1)::option::Option<OtherElement> {
        if ((std=0x1)::option::is_some(&o))  {
            (std=0x1)::option::some(f((std=0x1)::option::destroy_some(o)))
        } else  {
            (std=0x1)::option::destroy_none(o);
            (std=0x1)::option::none()
        }
    }
    #[]public fun none<Element>(): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::empty()}
    }
    #[]public fun some<Element>(e: Element): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::singleton(e)}
    }
    #[]public fun swap<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = (std=0x1)::vector::pop_back(vec_ref);
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun swap_or_fill<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): (std=0x1)::option::Option<Element> {
        let vec_ref = &mut t.vec;
        let old_value = if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::option::none() else (std=0x1)::option::some((std=0x1)::vector::pop_back(vec_ref));
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun to_vec<Element>(t: (std=0x1)::option::Option<Element>): vector<Element> {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        vec
    }
     spec Option{invariant len(vec) <= 1}
     spec none{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_none<Element>()}
     spec module {define spec_none<Element>(): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: vec()}
    }}
     spec some{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_some(e)}
     spec module {define spec_some<Element>(e: Element): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: vec(e)}
    }}
     spec is_none{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::is_none(t)}
     spec is_some{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::is_some(t)}
     spec contains{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_contains(t, e_ref)}
     spec module {define spec_contains<Element>(t: (std=0x1)::option::Option<Element>, e: Element): bool {
        (std=0x1)::option::is_some(t) && (std=0x1)::option::borrow(t) == e
    }}
     spec borrow{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t)}
     spec borrow_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default_ref}
     spec get_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default}
     spec fill{pragma opaque;
    aborts_if (std=0x1)::option::is_some(t)(std=0x1)::option::EOPTION_IS_SET;
    ensures (std=0x1)::option::is_some(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec extract{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(old(t));
    ensures (std=0x1)::option::is_none(t)}
     spec borrow_mut{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t);
    ensures t == old(t)}
     spec swap{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(old(t));
    ensures (std=0x1)::option::is_some(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec swap_or_fill{pragma opaque;
    ensures result == old(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec destroy_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default}
     spec destroy_some{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t)}
     spec destroy_none{pragma opaque;
    aborts_if (std=0x1)::option::is_some(t)(std=0x1)::option::EOPTION_IS_SET}
     spec to_vec{pragma opaque;
    aborts_if false;
    ensures result == t.vec}
     spec module {}
     spec module {pragma aborts_if_is_strict}
     spec schema AbortsIfNone<Element>{localt: (std=0x1)::option::Option<Element>;
    aborts_if (std=0x1)::option::is_none(t)(std=0x1)::option::EOPTION_NOT_SET}

}
module (std=0x1)::signer {
    #[]source module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address(s)
    }
    #[]public native fun borrow_address(s: &signer): &address;

     spec module {native define is_txn_signer(s: signer): bool;
    }
     spec module {native define is_txn_signer_addr(a: address): bool;
    }

}
module (std=0x1)::string {
    #[]source module
    dependency order #4
    neighbor#dependency (std=0x1)::option;
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append(&mut s.bytes, r.bytes)
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append(s, (std=0x1)::string::utf8(bytes))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of(&s.bytes, &r.bytes)
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes = &s.bytes;
        assert!(at <= (std=0x1)::vector::length(bytes) && (std=0x1)::string::internal_is_char_boundary(bytes, at), (std=0x1)::string::EINVALID_INDEX);
        let l = (std=0x1)::string::length(s);
        let front = (std=0x1)::string::sub_string(s, 0, at);
        let end = (std=0x1)::string::sub_string(s, at, l);
        (std=0x1)::string::append(&mut front, o);
        (std=0x1)::string::append(&mut front, end);
        *s = front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty(&s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length(&s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes = &s.bytes;
        let l = (std=0x1)::vector::length(bytes);
        assert!(j <= l && i <= j && (std=0x1)::string::internal_is_char_boundary(bytes, i) && (std=0x1)::string::internal_is_char_boundary(bytes, j), (std=0x1)::string::EINVALID_INDEX);
        (std=0x1)::string::String{0#bytes: (std=0x1)::string::internal_sub_string(bytes, i, j)}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8(&bytes))  {
            (std=0x1)::option::some((std=0x1)::string::String{0#bytes: bytes})
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert!((std=0x1)::string::internal_check_utf8(&bytes), (std=0x1)::string::EINVALID_UTF8);
        (std=0x1)::string::String{0#bytes: bytes}
    }

}
module (std=0x1)::type_name {
    #[]source module
    dependency order #5
    neighbor#dependency (std=0x1)::ascii;
    uses address (std=0x1);
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &self.name
    }
    #[]public native fun get<T>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        self.name
    }

}
module (std=0x1)::vector {
    #[]source module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>): () {
        (std=0x1)::vector::reverse(&mut other);
        while (! (std=0x1)::vector::is_empty(&other))(std=0x1)::vector::push_back(lhs, (std=0x1)::vector::pop_back(&mut other));
        (std=0x1)::vector::destroy_empty(other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;

    #[bytecode_instruction]public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;

    #[]public fun contains<Element>(v: &vector<Element>, e: &Element): bool {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return true else ();
            i = i + 1;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element>(v: vector<Element>): ();

    #[bytecode_instruction]public native fun empty<Element>(): vector<Element>;

    #[]public inline fun filter<Element: drop>(v: vector<Element>, p: |&Element|bool): vector<Element> {
        let result = vector<Element>[];
        (std=0x1)::vector::for_each(v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back(&mut result, elem) else ();
            /*()*/
        });
        result
    }
    #[]public inline fun fold<Accumulator, Element>(v: vector<Element>, init: Accumulator, f: |Accumulator, Element|Accumulator): Accumulator {
        let accu = init;
        (std=0x1)::vector::for_each(v, |elem|accu = f(accu, elem));
        accu
    }
    #[]public inline fun for_each<Element>(v: vector<Element>, f: |Element|()): () {
        (std=0x1)::vector::reverse(&mut v);
        while (! (std=0x1)::vector::is_empty(&v)) {
            let e = (std=0x1)::vector::pop_back(&mut v);
            f(e);
            /*()*/
        };
        /*()*/
    }
    #[]public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: |&mut Element|()): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow_mut(v, i));
            i = i + 1
        }
    }
    #[]public inline fun for_each_ref<Element>(v: &vector<Element>, f: |&Element|()): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow(v, i));
            i = i + 1
        }
    }
    #[]public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return (true, i) else ();
            i = i + 1;
            /*()*/
        };
        (false, 0)
    }
    #[]public fun is_empty<Element>(v: &vector<Element>): bool {
        (std=0x1)::vector::length(v) == 0
    }
    #[bytecode_instruction]public native fun length<Element>(v: &vector<Element>): u64;

    #[]public inline fun map<Element, NewElement>(v: vector<Element>, f: |Element|NewElement): vector<NewElement> {
        let result = vector<NewElement>[];
        (std=0x1)::vector::for_each(v, |elem|(std=0x1)::vector::push_back(&mut result, f(elem)));
        result
    }
    #[bytecode_instruction]public native fun pop_back<Element>(v: &mut vector<Element>): Element;

    #[bytecode_instruction]public native fun push_back<Element>(v: &mut vector<Element>, e: Element): ();

    #[]public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {
        let len = (std=0x1)::vector::length(v);
        if (i >= len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len = len - 1;
        while (i < len)(std=0x1)::vector::swap(v, i,  {
            i = i + 1;
            i
        });
        (std=0x1)::vector::pop_back(v)
    }
    #[]public fun reverse<Element>(v: &mut vector<Element>): () {
        let len = (std=0x1)::vector::length(v);
        if (len == 0) return () else ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            (std=0x1)::vector::swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;
            /*()*/
        }
    }
    #[]public fun singleton<Element>(e: Element): vector<Element> {
        let v = (std=0x1)::vector::empty();
        (std=0x1)::vector::push_back(&mut v, e);
        v
    }
    #[bytecode_instruction]public native fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {
        assert!(! (std=0x1)::vector::is_empty(v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS);
        let last_idx = (std=0x1)::vector::length(v) - 1;
        (std=0x1)::vector::swap(v, i, last_idx);
        (std=0x1)::vector::pop_back(v)
    }
     spec singleton{aborts_if false;
    ensures result == vec(e)}
     spec reverse{pragma intrinsic = true}
     spec append{pragma intrinsic = true}
     spec is_empty{pragma intrinsic = true}
     spec contains{pragma intrinsic = true}
     spec index_of{pragma intrinsic = true}
     spec remove{pragma intrinsic = true}
     spec swap_remove{pragma intrinsic = true}
     spec module {}
     spec module {define eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
        len(v1) == len(v2) + 1 && v1[len(v1) - 1] == e && v1[0 .. len(v1) - 1] == v2[0 .. len(v2)]
    };
    define eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
        len(v) == len(v1) + len(v2) && v[0 .. len(v1)] == v1 && v[len(v1) .. len(v)] == v2
    };
    define eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1 == v2[1 .. len(v2)]
    };
    define eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1[0 .. i] == v2[0 .. i] && v1[i .. len(v1)] == v2[i + 1 .. len(v2)]
    }}

}
After naming: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len = (std=0x1)::vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec #0 uses [i, len, string];
            i < len
        }) {
            let byte = *(std=0x1)::vector::borrow(&string.bytes, i);
            if (! (std=0x1)::ascii::is_printable_char(byte)) return false else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [i, len, string];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char{0#byte: byte} = char;
        byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert((std=0x1)::ascii::is_valid_char(byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::ascii::Char{0#byte: byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String{0#bytes: bytes} = string;
        bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        byte >= 32 && byte <= 126
    }
    #[]public fun is_valid_char(b: u8): bool {
        b <= 127
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length((std=0x1)::ascii::as_bytes(string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char{0#byte: (std=0x1)::vector::pop_back(&mut string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back(&mut string.bytes, (&*)char.byte);
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x = (std=0x1)::ascii::try_string(bytes);
        assert((std=0x1)::option::is_some(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::option::destroy_some(x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len = (std=0x1)::vector::length(&bytes);
        let i = 0;
        while ( {
            spec #0 uses [bytes, i, len];
            i < len
        }) {
            let possible_byte = *(std=0x1)::vector::borrow(&bytes, i);
            if (! (std=0x1)::ascii::is_valid_char(possible_byte)) return (std=0x1)::option::none() else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [bytes, i, len];
        (std=0x1)::option::some((std=0x1)::ascii::String{0#bytes: bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        *(std=0x1)::vector::borrow(&bitvector.bit_field, bit_index)
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length(&bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert(start_index < (&*)bitvector.length, (std=0x1)::bit_vector::EINDEX);
        let index = start_index;
        while (index < (&*)bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set(bitvector, index)) break else ();
            index = index + 1;
            /*()*/
        };
        index - start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert(length > 0, (std=0x1)::bit_vector::ELENGTH);
        assert(length < (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH);
        let counter = 0;
        let bit_field = (std=0x1)::vector::empty();
        while ( {
            spec #0 uses [bit_field, counter, length] applies [len];
            counter < length
        }) {
            (std=0x1)::vector::push_back(&mut bit_field, false);
            counter = counter + 1;
            /*()*/
        };
        spec #1 uses [bit_field, counter, length] applies [len];
        (std=0x1)::bit_vector::BitVector{1#bit_field: bit_field, 0#length: length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (amount >= (&*)bitvector.length)  {
            let len = (std=0x1)::vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;
                /*()*/
            };
            /*()*/
        } else  {
            let i = amount;
            while (i < (&*)bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set(bitvector, i)) (std=0x1)::bit_vector::set(bitvector, i - amount) else (std=0x1)::bit_vector::unset(bitvector, i - amount);
                i = i + 1;
                /*()*/
            };
            i = (&*)bitvector.length - amount;
            while (i < (&*)bitvector.length) {
                (std=0x1)::bit_vector::unset(bitvector, i);
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ABORTED, r)
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ALREADY_EXISTS, r)
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INTERNAL, r)
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_ARGUMENT, r)
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_STATE, r)
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_FOUND, r)
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_IMPLEMENTED, r)
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::OUT_OF_RANGE, r)
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::PERMISSION_DENIED, r)
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::RESOURCE_EXHAUSTED, r)
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAUTHENTICATED, r)
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAVAILABLE, r)
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        if ((&*)num.value == floored_num)  {
            return floored_num >> 32
        } else ();
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert(scaled_denominator != 0, (std=0x1)::fixed_point32::EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert(quotient != 0 || numerator == 0, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        assert(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value = (val as u128) << 32;
        assert(value <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((&*)divisor.value != 0, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / ((&*)divisor.value as u128);
        assert(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION);
        (quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        (&*)num.value >> 32
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        (&*)num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        (&*)num.value == 0
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if ((&*)num1.value > (&*)num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if ((&*)num1.value < (&*)num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product = (val as u128) * ((&*)multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert(product <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION);
        (product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if ((&*)num.value < boundary)  {
            floored_num >> 32
        } else  {
            (std=0x1)::fixed_point32::ceil(num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#1> has copy drop store {
        0#vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow(&t.vec, 0)
    }
    #[]public fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow_mut(&mut t.vec, 0)
    }
    #[]public fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4 {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default_ref else (std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool {
        (std=0x1)::vector::contains(&t.vec, e_ref)
    }
    #[]public fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): () {
        assert((std=0x1)::option::is_none(&t), (std=0x1)::option::EOPTION_IS_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        (std=0x1)::vector::destroy_empty(vec)
    }
    #[]public fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7 {
        assert((std=0x1)::option::is_some(&t), (std=0x1)::option::EOPTION_NOT_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        let elem = (std=0x1)::vector::pop_back(&mut vec);
        (std=0x1)::vector::destroy_empty(vec);
        elem
    }
    #[]public fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        if ((std=0x1)::vector::is_empty(&mut vec)) default else (std=0x1)::vector::pop_back(&mut vec)
    }
    #[]public fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::pop_back(&mut t.vec)
    }
    #[]public fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): () {
        let vec_ref = &mut t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::vector::push_back(vec_ref, e) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public inline fun filter<Element#11: drop>(o: (std=0x1)::option::Option<Element#11: drop>, f: |..|..<&Element#11: drop, bool>): (std=0x1)::option::Option<Element#11: drop> {
        if ((std=0x1)::option::is_some(&o) && f((std=0x1)::option::borrow(&o)))  {
            o
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public inline fun fold<Accumulator#12, Element#13>(o: (std=0x1)::option::Option<Element#13>, init: Accumulator#12, f: |..|..<Accumulator#12, Element#13, Accumulator#12>): Accumulator#12 {
        if ((std=0x1)::option::is_some(&o))  {
            f(init, (std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o);
            init
        }
    }
    #[]public inline fun for_each<Element#14>(o: (std=0x1)::option::Option<Element#14>, f: |..|..<Element#14, ()>): () {
        if ((std=0x1)::option::is_some(&o))  {
            f((std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o)
        }
    }
    #[]public inline fun for_each_mut<Element#15>(o: &mut (std=0x1)::option::Option<Element#15>, f: |..|..<&mut Element#15, ()>): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow_mut(o))
        } else ()
    }
    #[]public inline fun for_each_ref<Element#16>(o: &(std=0x1)::option::Option<Element#16>, f: |..|..<&Element#16, ()>): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow(o))
        } else ()
    }
    #[]public fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default else *(std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool {
        (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool {
        ! (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public inline fun map<Element#20, OtherElement#21>(o: (std=0x1)::option::Option<Element#20>, f: |..|..<Element#20, OtherElement#21>): (std=0x1)::option::Option<OtherElement#21> {
        if ((std=0x1)::option::is_some(&o))  {
            (std=0x1)::option::some(f((std=0x1)::option::destroy_some(o)))
        } else  {
            (std=0x1)::option::destroy_none(o);
            (std=0x1)::option::none()
        }
    }
    #[]public fun none<Element#22>(): (std=0x1)::option::Option<Element#22> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::empty()}
    }
    #[]public fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::singleton(e)}
    }
    #[]public fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = (std=0x1)::vector::pop_back(vec_ref);
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25> {
        let vec_ref = &mut t.vec;
        let old_value = if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::option::none() else (std=0x1)::option::some((std=0x1)::vector::pop_back(vec_ref));
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26> {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address(s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append(&mut s.bytes, (&*)r.bytes)
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append(s, (std=0x1)::string::utf8(bytes))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of(&s.bytes, &r.bytes)
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes = &s.bytes;
        assert(at <= (std=0x1)::vector::length(bytes) && (std=0x1)::string::internal_is_char_boundary(bytes, at), (std=0x1)::string::EINVALID_INDEX);
        let l = (std=0x1)::string::length(s);
        let front = (std=0x1)::string::sub_string(s, 0, at);
        let end = (std=0x1)::string::sub_string(s, at, l);
        (std=0x1)::string::append(&mut front, o);
        (std=0x1)::string::append(&mut front, end);
        *s = front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty(&s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length(&s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes = &s.bytes;
        let l = (std=0x1)::vector::length(bytes);
        assert(j <= l && i <= j && (std=0x1)::string::internal_is_char_boundary(bytes, i) && (std=0x1)::string::internal_is_char_boundary(bytes, j), (std=0x1)::string::EINVALID_INDEX);
        (std=0x1)::string::String{0#bytes: (std=0x1)::string::internal_sub_string(bytes, i, j)}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8(&bytes))  {
            (std=0x1)::option::some((std=0x1)::string::String{0#bytes: bytes})
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert((std=0x1)::string::internal_check_utf8(&bytes), (std=0x1)::string::EINVALID_UTF8);
        (std=0x1)::string::String{0#bytes: bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &self.name
    }
    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        (&*)self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): () {
        (std=0x1)::vector::reverse(&mut other);
        while (! (std=0x1)::vector::is_empty(&other))(std=0x1)::vector::push_back(lhs, (std=0x1)::vector::pop_back(&mut other));
        (std=0x1)::vector::destroy_empty(other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return true else ();
            i = i + 1;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public inline fun filter<Element#34: drop>(v: vector<Element#34: drop>, p: |..|..<&Element#34: drop, bool>): vector<Element#34: drop> {
        let result = vector<Element#34: drop>[];
        (std=0x1)::vector::for_each(v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back(&mut result, elem) else ();
            /*()*/
        });
        result
    }
    #[]public inline fun fold<Accumulator#35, Element#36>(v: vector<Element#36>, init: Accumulator#35, f: |..|..<Accumulator#35, Element#36, Accumulator#35>): Accumulator#35 {
        let accu = init;
        (std=0x1)::vector::for_each(v, |elem|accu = f(accu, elem));
        accu
    }
    #[]public inline fun for_each<Element#37>(v: vector<Element#37>, f: |..|..<Element#37, ()>): () {
        (std=0x1)::vector::reverse(&mut v);
        while (! (std=0x1)::vector::is_empty(&v)) {
            let e = (std=0x1)::vector::pop_back(&mut v);
            f(e);
            /*()*/
        };
        /*()*/
    }
    #[]public inline fun for_each_mut<Element#38>(v: &mut vector<Element#38>, f: |..|..<&mut Element#38, ()>): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow_mut(v, i));
            i = i + 1
        }
    }
    #[]public inline fun for_each_ref<Element#39>(v: &vector<Element#39>, f: |..|..<&Element#39, ()>): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow(v, i));
            i = i + 1
        }
    }
    #[]public fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64) {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return (true, i) else ();
            i = i + 1;
            /*()*/
        };
        (false, 0)
    }
    #[]public fun is_empty<Element#41>(v: &vector<Element#41>): bool {
        (std=0x1)::vector::length(v) == 0
    }
    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[]public inline fun map<Element#43, NewElement#44>(v: vector<Element#43>, f: |..|..<Element#43, NewElement#44>): vector<NewElement#44> {
        let result = vector<NewElement#44>[];
        (std=0x1)::vector::for_each(v, |elem|(std=0x1)::vector::push_back(&mut result, f(elem)));
        result
    }
    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47 {
        let len = (std=0x1)::vector::length(v);
        if (i >= len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len = len - 1;
        while (i < len)(std=0x1)::vector::swap(v, i,  {
            i = i + 1;
            i
        });
        (std=0x1)::vector::pop_back(v)
    }
    #[]public fun reverse<Element#48>(v: &mut vector<Element#48>): () {
        let len = (std=0x1)::vector::length(v);
        if (len == 0) return () else ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            (std=0x1)::vector::swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;
            /*()*/
        }
    }
    #[]public fun singleton<Element#49>(e: Element#49): vector<Element#49> {
        let v = (std=0x1)::vector::empty();
        (std=0x1)::vector::push_back(&mut v, e);
        v
    }
    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51 {
        assert(! (std=0x1)::vector::is_empty(v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS);
        let last_idx = (std=0x1)::vector::length(v) - 1;
        (std=0x1)::vector::swap(v, i, last_idx);
        (std=0x1)::vector::pop_back(v)
    }

}
After typing: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536u64;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy string.bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [i (i), len (len), string (string)];
            copy i <@u64 copy len
        }) {
            let byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char[parameter_types: [u8]<>(copy byte)) return false else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 uses [i (i), len (len), string (string)];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char<>{0#byte: byte}: ((std=0x1)::ascii::Char) = copy char;
        copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert(((std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::ascii::Char<>{(0#byte:u8): copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String<>{0#bytes: bytes}: ((std=0x1)::ascii::String) = copy string;
        copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        copy byte >=@u8 32u8 &&@bool copy byte <=@u8 126u8
    }
    #[]public fun is_valid_char(b: u8): bool {
        copy b <=@u8 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>((std=0x1)::ascii::as_bytes[parameter_types: [&(std=0x1)::ascii::String]<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char<>{(0#byte:u8): (std=0x1)::vector::pop_back[parameter_types: [&mut vector<u8>]<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<u8>, u8]<u8>((&mut copy string.bytes, *&&char.byte));
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x: ((std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string[parameter_types: [vector<u8>]<>(copy bytes);
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [bytes (bytes), i (i), len (len)];
            copy i <@u64 copy len
        }) {
            let possible_byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy possible_byte)) return (std=0x1)::option::none<(std=0x1)::ascii::String>(()) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 uses [bytes (bytes), i (i), len (len)];
        (std=0x1)::option::some[parameter_types: [(std=0x1)::ascii::String]<(std=0x1)::ascii::String>((std=0x1)::ascii::String<>{(0#bytes:vector<u8>): copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072u64;
    #[]const ELENGTH:u64 = 131073u64;
    #[]const MAX_SIZE:u64 = 1024u64;
    #[]const WORD_SIZE:u64 = 1u64;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        *(std=0x1)::vector::borrow[parameter_types: [&vector<bool>, u64]<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert((copy start_index <@u64 *&copy bitvector.length, (std=0x1)::bit_vector::EINDEX));
        let index: (u64) = copy start_index;
        while (copy index <@u64 *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy index))) break else ();
            index: (u64) = copy index +@u64 1u64;
            /*()*/
        };
        copy index -@u64 copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert((copy length >@u64 0u64, (std=0x1)::bit_vector::ELENGTH));
        assert((copy length <@u64 (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH));
        let counter: (u64) = 0u64;
        let bit_field: (vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            spec #0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter <@u64 copy length
        }) {
            (std=0x1)::vector::push_back[parameter_types: [&mut vector<bool>, bool]<bool>((&mut bit_field, false));
            counter: (u64) = copy counter +@u64 1u64;
            /*()*/
        };
        spec #1 uses [bit_field (bit_field), counter (counter), length (length)];
        (std=0x1)::bit_vector::BitVector<>{(1#bit_field:vector<bool>): copy bit_field, (0#length:u64): copy length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (copy amount >=@u64 *&copy bitvector.length)  {
            let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field);
            let i: (u64) = 0u64;
            while (copy i <@u64 copy len) {
                let elem: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        } else  {
            let i: (u64) = copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i))) (std=0x1)::bit_vector::set[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount)) else (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            i: (u64) = *&copy bitvector.length -@u64 copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7u64;
    #[]const ALREADY_EXISTS:u64 = 8u64;
    #[]const CANCELLED:u64 = 10u64;
    #[]const INTERNAL:u64 = 11u64;
    #[]const INVALID_ARGUMENT:u64 = 1u64;
    #[]const INVALID_STATE:u64 = 3u64;
    #[]const NOT_FOUND:u64 = 6u64;
    #[]const NOT_IMPLEMENTED:u64 = 12u64;
    #[]const OUT_OF_RANGE:u64 = 2u64;
    #[]const PERMISSION_DENIED:u64 = 5u64;
    #[]const RESOURCE_EXHAUSTED:u64 = 9u64;
    #[]const UNAUTHENTICATED:u64 = 4u64;
    #[]const UNAVAILABLE:u64 = 13u64;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        copy category <<@u64 16u8 +@u64 copy reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537u64;
    #[]const EDIVISION:u64 = 131074u64;
    #[]const EDIVISION_BY_ZERO:u64 = 65540u64;
    #[]const EMULTIPLICATION:u64 = 131075u64;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077u64;
    #[]const MAX_U64:u128 = 18446744073709551615u128;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        if (*&&num.value ==@u64 copy floored_num)  {
            return copy floored_num >>@u64 32u8
        } else ();
        let val: (u128) = (copy floored_num as u128) +@u128 1u128 <<@u128 32u8;
        (copy val >>@u128 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator: (u128) = (copy numerator as u128) <<@u128 64u8;
        let scaled_denominator: (u128) = (copy denominator as u128) <<@u128 32u8;
        assert((copy scaled_denominator !=@u128 0u128, (std=0x1)::fixed_point32::EDENOMINATOR));
        let quotient: (u128) = copy scaled_numerator /@u128 copy scaled_denominator;
        assert((copy quotient !=@u128 0u128 ||@bool copy numerator ==@u64 0u64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value: (u128) = (copy val as u128) <<@u128 32u8;
        assert((copy value <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((*&&divisor.value !=@u64 0u64, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO));
        let scaled_value: (u128) = (copy val as u128) <<@u128 32u8;
        let quotient: (u128) = copy scaled_value /@u128 (*&&divisor.value as u128);
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION));
        (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value >>@u64 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        *&&num.value ==@u64 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value >@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value <@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product: (u128) = (copy val as u128) *@u128 (*&&multiplier.value as u128);
        let product: (u128) = copy unscaled_product >>@u128 32u8;
        assert((copy product <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION));
        (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        let boundary: (u64) = copy floored_num +@u64 1u64 <<@u64 32u8 /@u64 2u64;
        if (*&&num.value <@u64 copy boundary)  {
            copy floored_num >>@u64 32u8
        } else  {
            (std=0x1)::fixed_point32::ceil[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#1> has copy drop store {
        0#vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144u64;
    #[]const EOPTION_NOT_SET:u64 = 262145u64;
    #[]public fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#2>]<Element#2>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow[parameter_types: [&vector<Element#2>, u64]<Element#2>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#3>]<Element#3>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#3>, u64]<Element#3>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4 {
        let vec_ref: (&vector<Element#4>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#4>]<Element#4>(copy vec_ref)) copy default_ref else (std=0x1)::vector::borrow[parameter_types: [&vector<Element#4>, u64]<Element#4>((copy vec_ref, 0u64))
    }
    #[]public fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool {
        (std=0x1)::vector::contains[parameter_types: [&vector<Element#5>, &Element#5]<Element#5>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): () {
        assert(((std=0x1)::option::is_none[parameter_types: [&(std=0x1)::option::Option<Element#6>]<Element#6>(&t), (std=0x1)::option::EOPTION_IS_SET));
        let (std=0x1)::option::Option<Element#6>{0#vec: vec}: ((std=0x1)::option::Option<Element#6>) = move t;
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#6>]<Element#6>(move vec)
    }
    #[]public fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#7>]<Element#7>(&t), (std=0x1)::option::EOPTION_NOT_SET));
        let (std=0x1)::option::Option<Element#7>{0#vec: vec}: ((std=0x1)::option::Option<Element#7>) = move t;
        let elem: (Element#7) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#7>]<Element#7>(&mut vec);
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#7>]<Element#7>(move vec);
        move elem
    }
    #[]public fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop {
        let (std=0x1)::option::Option<Element#8: drop>{0#vec: vec}: ((std=0x1)::option::Option<Element#8: drop>) = move t;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#8: drop>]<Element#8: drop>(&mut vec)) move default else (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#8: drop>]<Element#8: drop>(&mut vec)
    }
    #[]public fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#9>]<Element#9>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#9>]<Element#9>(&mut copy t.vec)
    }
    #[]public fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): () {
        let vec_ref: (&mut vector<Element#10>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#10>]<Element#10>(copy vec_ref)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#10>, Element#10]<Element#10>((copy vec_ref, move e)) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public fun filter!<Element#11: drop>(o: (std=0x1)::option::Option<Element#11: drop>, f: |..|..<&Element#11: drop, bool>): (std=0x1)::option::Option<Element#11: drop> {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#11: drop>]<Element#11: drop>(&o) &&@bool f((std=0x1)::option::borrow[parameter_types: [&(std=0x1)::option::Option<Element#11: drop>]<Element#11: drop>(&o)))  {
            move o
        } else  {
            (std=0x1)::option::none<Element#11: drop>(())
        }
    }
    #[]public fun fold!<Accumulator#12, Element#13>(o: (std=0x1)::option::Option<Element#13>, init: Accumulator#12, f: |..|..<Accumulator#12, Element#13, Accumulator#12>): Accumulator#12 {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#13>]<Element#13>(&o))  {
            f((move init, (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#13>]<Element#13>(move o)))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#13>]<Element#13>(move o);
            move init
        }
    }
    #[]public fun for_each!<Element#14>(o: (std=0x1)::option::Option<Element#14>, f: |..|..<Element#14, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#14>]<Element#14>(&o))  {
            f((std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#14>]<Element#14>(move o))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#14>]<Element#14>(move o)
        }
    }
    #[]public fun for_each_mut!<Element#15>(o: &mut (std=0x1)::option::Option<Element#15>, f: |..|..<&mut Element#15, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#15>]<Element#15>(copy o))  {
            f((std=0x1)::option::borrow_mut[parameter_types: [&mut (std=0x1)::option::Option<Element#15>]<Element#15>(copy o))
        } else ()
    }
    #[]public fun for_each_ref!<Element#16>(o: &(std=0x1)::option::Option<Element#16>, f: |..|..<&Element#16, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#16>]<Element#16>(copy o))  {
            f((std=0x1)::option::borrow[parameter_types: [&(std=0x1)::option::Option<Element#16>]<Element#16>(copy o))
        } else ()
    }
    #[]public fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop {
        let vec_ref: (&vector<Element#17: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#17: copy+drop>]<Element#17: copy+drop>(copy vec_ref)) copy default else *(std=0x1)::vector::borrow[parameter_types: [&vector<Element#17: copy+drop>, u64]<Element#17: copy+drop>((copy vec_ref, 0u64))
    }
    #[]public fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#18>]<Element#18>(&copy t.vec)
    }
    #[]public fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool {
        ! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#19>]<Element#19>(&copy t.vec)
    }
    #[]public fun map!<Element#20, OtherElement#21>(o: (std=0x1)::option::Option<Element#20>, f: |..|..<Element#20, OtherElement#21>): (std=0x1)::option::Option<OtherElement#21> {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#20>]<Element#20>(&o))  {
            (std=0x1)::option::some[parameter_types: [OtherElement#21]<OtherElement#21>(f((std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#20>]<Element#20>(move o)))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#20>]<Element#20>(move o);
            (std=0x1)::option::none<OtherElement#21>(())
        }
    }
    #[]public fun none<Element#22>(): (std=0x1)::option::Option<Element#22> {
        (std=0x1)::option::Option<Element#22>{(0#vec:vector<Element#22>): (std=0x1)::vector::empty<Element#22>(())}
    }
    #[]public fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23> {
        (std=0x1)::option::Option<Element#23>{(0#vec:vector<Element#23>): (std=0x1)::vector::singleton[parameter_types: [Element#23]<Element#23>(move e)}
    }
    #[]public fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#24>]<Element#24>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        let vec_ref: (&mut vector<Element#24>) = &mut copy t.vec;
        let old_value: (Element#24) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#24>]<Element#24>(copy vec_ref);
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#24>, Element#24]<Element#24>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25> {
        let vec_ref: (&mut vector<Element#25>) = &mut copy t.vec;
        let old_value: ((std=0x1)::option::Option<Element#25>) = if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#25>]<Element#25>(copy vec_ref)) (std=0x1)::option::none<Element#25>(()) else (std=0x1)::option::some[parameter_types: [Element#25]<Element#25>((std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#25>]<Element#25>(copy vec_ref));
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#25>, Element#25]<Element#25>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26> {
        let (std=0x1)::option::Option<Element#26>{0#vec: vec}: ((std=0x1)::option::Option<Element#26>) = move t;
        move vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address[parameter_types: [&signer]<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2u64;
    #[]const EINVALID_UTF8:u64 = 1u64;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append[parameter_types: [&mut vector<u8>, vector<u8>]<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((copy s, (std=0x1)::string::utf8[parameter_types: [vector<u8>]<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of[parameter_types: [&vector<u8>, &vector<u8>]<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes: (&vector<u8>) = &copy s.bytes;
        assert((copy at <=@u64 (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy at)), (std=0x1)::string::EINVALID_INDEX));
        let l: (u64) = (std=0x1)::string::length[parameter_types: [&(std=0x1)::string::String]<>(copy s);
        let front: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, 0u64, copy at));
        let end: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, copy at, copy l));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy o));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy end));
        *copy s = copy front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes: (&vector<u8>) = &copy s.bytes;
        let l: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes);
        assert((copy j <=@u64 copy l &&@bool copy i <=@u64 copy j &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy i)) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy j)), (std=0x1)::string::EINVALID_INDEX));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): (std=0x1)::string::internal_sub_string[parameter_types: [&vector<u8>, u64, u64]<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes))  {
            (std=0x1)::option::some[parameter_types: [(std=0x1)::string::String]<(std=0x1)::string::String>((std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes})
        } else  {
            (std=0x1)::option::none<(std=0x1)::string::String>(())
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert(((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes), (std=0x1)::string::EINVALID_UTF8));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &copy self.name
    }
    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072u64;
    #[]public fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#28>]<Element#28>(&mut other);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#28>]<Element#28>(&other))(std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#28>, Element#28]<Element#28>((copy lhs, (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#28>]<Element#28>(&mut other)));
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#28>]<Element#28>(move other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#31>]<Element#31>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#31>, u64]<Element#31>((copy v, copy i)) ==@&Element#31 copy e) return true else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public fun filter!<Element#34: drop>(v: vector<Element#34: drop>, p: |..|..<&Element#34: drop, bool>): vector<Element#34: drop> {
        let result: (vector<Element#34: drop>) = vector#0<Element#34: drop>[()];
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#34: drop>, |..|..<Element#34: drop, ()>]<Element#34: drop>((move v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#34: drop>, Element#34: drop]<Element#34: drop>((&mut result, move elem)) else ();
            /*()*/
        }));
        move result
    }
    #[]public fun fold!<Accumulator#35, Element#36>(v: vector<Element#36>, init: Accumulator#35, f: |..|..<Accumulator#35, Element#36, Accumulator#35>): Accumulator#35 {
        let accu: (Accumulator#35) = move init;
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#36>, |..|..<Element#36, ()>]<Element#36>((move v, |elem|accu: (Accumulator#35) = f((move accu, move elem))));
        move accu
    }
    #[]public fun for_each!<Element#37>(v: vector<Element#37>, f: |..|..<Element#37, ()>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#37>]<Element#37>(&mut v);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#37>]<Element#37>(&v)) {
            let e: (Element#37) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#37>]<Element#37>(&mut v);
            f(move e);
            /*()*/
        };
        /*()*/
    }
    #[]public fun for_each_mut!<Element#38>(v: &mut vector<Element#38>, f: |..|..<&mut Element#38, ()>): () {
        let i: (u64) = 0u64;
        while (copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<Element#38>]<Element#38>(copy v)) {
            f((std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#38>, u64]<Element#38>((copy v, copy i)));
            i: (u64) = copy i +@u64 1u64
        }
    }
    #[]public fun for_each_ref!<Element#39>(v: &vector<Element#39>, f: |..|..<&Element#39, ()>): () {
        let i: (u64) = 0u64;
        while (copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<Element#39>]<Element#39>(copy v)) {
            f((std=0x1)::vector::borrow[parameter_types: [&vector<Element#39>, u64]<Element#39>((copy v, copy i)));
            i: (u64) = copy i +@u64 1u64
        }
    }
    #[]public fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64) {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#40>]<Element#40>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#40>, u64]<Element#40>((copy v, copy i)) ==@&Element#40 copy e) return (true, copy i) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        (false, 0u64)
    }
    #[]public fun is_empty<Element#41>(v: &vector<Element#41>): bool {
        (std=0x1)::vector::length[parameter_types: [&vector<Element#41>]<Element#41>(copy v) ==@u64 0u64
    }
    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[]public fun map!<Element#43, NewElement#44>(v: vector<Element#43>, f: |..|..<Element#43, NewElement#44>): vector<NewElement#44> {
        let result: (vector<NewElement#44>) = vector#0<NewElement#44>[()];
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#43>, |..|..<Element#43, ()>]<Element#43>((move v, |elem|(std=0x1)::vector::push_back[parameter_types: [&mut vector<NewElement#44>, NewElement#44]<NewElement#44>((&mut result, f(move elem)))));
        move result
    }
    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47 {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#47>]<Element#47>(copy v);
        if (copy i >=@u64 copy len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len: (u64) = copy len -@u64 1u64;
        while (copy i <@u64 copy len)(std=0x1)::vector::swap[parameter_types: [&mut vector<Element#47>, u64, u64]<Element#47>((copy v, copy i,  {
            i: (u64) = copy i +@u64 1u64;
            copy i
        }));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#47>]<Element#47>(copy v)
    }
    #[]public fun reverse<Element#48>(v: &mut vector<Element#48>): () {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#48>]<Element#48>(copy v);
        if (copy len ==@u64 0u64) return () else ();
        let front_index: (u64) = 0u64;
        let back_index: (u64) = copy len -@u64 1u64;
        while (copy front_index <@u64 copy back_index) {
            (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#48>, u64, u64]<Element#48>((copy v, copy front_index, copy back_index));
            front_index: (u64) = copy front_index +@u64 1u64;
            back_index: (u64) = copy back_index -@u64 1u64;
            /*()*/
        }
    }
    #[]public fun singleton<Element#49>(e: Element#49): vector<Element#49> {
        let v: (vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#49>, Element#49]<Element#49>((&mut v, move e));
        move v
    }
    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51 {
        assert((! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#51>]<Element#51>(copy v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS));
        let last_idx: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#51>]<Element#51>(copy v) -@u64 1u64;
        (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#51>, u64, u64]<Element#51>((copy v, copy i, copy last_idx));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#51>]<Element#51>(copy v)
    }

}
After inlining: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536u64;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy string.bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            copy i <@u64 copy len
        }) {
            let byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char[parameter_types: [u8]<>(copy byte)) return false else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char<>{0#byte: byte}: ((std=0x1)::ascii::Char) = copy char;
        copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert(((std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::ascii::Char<>{(0#byte:u8): copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String<>{0#bytes: bytes}: ((std=0x1)::ascii::String) = copy string;
        copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        copy byte >=@u8 32u8 &&@bool copy byte <=@u8 126u8
    }
    #[]public fun is_valid_char(b: u8): bool {
        copy b <=@u8 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>((std=0x1)::ascii::as_bytes[parameter_types: [&(std=0x1)::ascii::String]<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char<>{(0#byte:u8): (std=0x1)::vector::pop_back[parameter_types: [&mut vector<u8>]<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<u8>, u8]<u8>((&mut copy string.bytes, *&&char.byte));
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x: ((std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string[parameter_types: [vector<u8>]<>(copy bytes);
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            copy i <@u64 copy len
        }) {
            let possible_byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy possible_byte)) return (std=0x1)::option::none<(std=0x1)::ascii::String>(()) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        (std=0x1)::option::some[parameter_types: [(std=0x1)::ascii::String]<(std=0x1)::ascii::String>((std=0x1)::ascii::String<>{(0#bytes:vector<u8>): copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072u64;
    #[]const ELENGTH:u64 = 131073u64;
    #[]const MAX_SIZE:u64 = 1024u64;
    #[]const WORD_SIZE:u64 = 1u64;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        *(std=0x1)::vector::borrow[parameter_types: [&vector<bool>, u64]<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert((copy start_index <@u64 *&copy bitvector.length, (std=0x1)::bit_vector::EINDEX));
        let index: (u64) = copy start_index;
        while (copy index <@u64 *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy index))) break else ();
            index: (u64) = copy index +@u64 1u64;
            /*()*/
        };
        copy index -@u64 copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert((copy length >@u64 0u64, (std=0x1)::bit_vector::ELENGTH));
        assert((copy length <@u64 (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH));
        let counter: (u64) = 0u64;
        let bit_field: (vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter <@u64 copy length
        }) {
            (std=0x1)::vector::push_back[parameter_types: [&mut vector<bool>, bool]<bool>((&mut bit_field, false));
            counter: (u64) = copy counter +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        (std=0x1)::bit_vector::BitVector<>{(1#bit_field:vector<bool>): copy bit_field, (0#length:u64): copy length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (copy amount >=@u64 *&copy bitvector.length)  {
            let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field);
            let i: (u64) = 0u64;
            while (copy i <@u64 copy len) {
                let elem: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        } else  {
            let i: (u64) = copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i))) (std=0x1)::bit_vector::set[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount)) else (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            i: (u64) = *&copy bitvector.length -@u64 copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7u64;
    #[]const ALREADY_EXISTS:u64 = 8u64;
    #[]const CANCELLED:u64 = 10u64;
    #[]const INTERNAL:u64 = 11u64;
    #[]const INVALID_ARGUMENT:u64 = 1u64;
    #[]const INVALID_STATE:u64 = 3u64;
    #[]const NOT_FOUND:u64 = 6u64;
    #[]const NOT_IMPLEMENTED:u64 = 12u64;
    #[]const OUT_OF_RANGE:u64 = 2u64;
    #[]const PERMISSION_DENIED:u64 = 5u64;
    #[]const RESOURCE_EXHAUSTED:u64 = 9u64;
    #[]const UNAUTHENTICATED:u64 = 4u64;
    #[]const UNAVAILABLE:u64 = 13u64;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        copy category <<@u64 16u8 +@u64 copy reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537u64;
    #[]const EDIVISION:u64 = 131074u64;
    #[]const EDIVISION_BY_ZERO:u64 = 65540u64;
    #[]const EMULTIPLICATION:u64 = 131075u64;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077u64;
    #[]const MAX_U64:u128 = 18446744073709551615u128;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        if (*&&num.value ==@u64 copy floored_num)  {
            return copy floored_num >>@u64 32u8
        } else ();
        let val: (u128) = (copy floored_num as u128) +@u128 1u128 <<@u128 32u8;
        (copy val >>@u128 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator: (u128) = (copy numerator as u128) <<@u128 64u8;
        let scaled_denominator: (u128) = (copy denominator as u128) <<@u128 32u8;
        assert((copy scaled_denominator !=@u128 0u128, (std=0x1)::fixed_point32::EDENOMINATOR));
        let quotient: (u128) = copy scaled_numerator /@u128 copy scaled_denominator;
        assert((copy quotient !=@u128 0u128 ||@bool copy numerator ==@u64 0u64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value: (u128) = (copy val as u128) <<@u128 32u8;
        assert((copy value <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((*&&divisor.value !=@u64 0u64, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO));
        let scaled_value: (u128) = (copy val as u128) <<@u128 32u8;
        let quotient: (u128) = copy scaled_value /@u128 (*&&divisor.value as u128);
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION));
        (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value >>@u64 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        *&&num.value ==@u64 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value >@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value <@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product: (u128) = (copy val as u128) *@u128 (*&&multiplier.value as u128);
        let product: (u128) = copy unscaled_product >>@u128 32u8;
        assert((copy product <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION));
        (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        let boundary: (u64) = copy floored_num +@u64 1u64 <<@u64 32u8 /@u64 2u64;
        if (*&&num.value <@u64 copy boundary)  {
            copy floored_num >>@u64 32u8
        } else  {
            (std=0x1)::fixed_point32::ceil[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#1> has copy drop store {
        0#vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144u64;
    #[]const EOPTION_NOT_SET:u64 = 262145u64;
    #[]public fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#2>]<Element#2>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow[parameter_types: [&vector<Element#2>, u64]<Element#2>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#3>]<Element#3>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#3>, u64]<Element#3>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4 {
        let vec_ref: (&vector<Element#4>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#4>]<Element#4>(copy vec_ref)) copy default_ref else (std=0x1)::vector::borrow[parameter_types: [&vector<Element#4>, u64]<Element#4>((copy vec_ref, 0u64))
    }
    #[]public fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool {
        (std=0x1)::vector::contains[parameter_types: [&vector<Element#5>, &Element#5]<Element#5>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): () {
        assert(((std=0x1)::option::is_none[parameter_types: [&(std=0x1)::option::Option<Element#6>]<Element#6>(&t), (std=0x1)::option::EOPTION_IS_SET));
        let (std=0x1)::option::Option<Element#6>{0#vec: vec}: ((std=0x1)::option::Option<Element#6>) = move t;
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#6>]<Element#6>(move vec)
    }
    #[]public fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#7>]<Element#7>(&t), (std=0x1)::option::EOPTION_NOT_SET));
        let (std=0x1)::option::Option<Element#7>{0#vec: vec}: ((std=0x1)::option::Option<Element#7>) = move t;
        let elem: (Element#7) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#7>]<Element#7>(&mut vec);
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#7>]<Element#7>(move vec);
        move elem
    }
    #[]public fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop {
        let (std=0x1)::option::Option<Element#8: drop>{0#vec: vec}: ((std=0x1)::option::Option<Element#8: drop>) = move t;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#8: drop>]<Element#8: drop>(&mut vec)) move default else (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#8: drop>]<Element#8: drop>(&mut vec)
    }
    #[]public fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#9>]<Element#9>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#9>]<Element#9>(&mut copy t.vec)
    }
    #[]public fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): () {
        let vec_ref: (&mut vector<Element#10>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#10>]<Element#10>(copy vec_ref)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#10>, Element#10]<Element#10>((copy vec_ref, move e)) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop {
        let vec_ref: (&vector<Element#17: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#17: copy+drop>]<Element#17: copy+drop>(copy vec_ref)) copy default else *(std=0x1)::vector::borrow[parameter_types: [&vector<Element#17: copy+drop>, u64]<Element#17: copy+drop>((copy vec_ref, 0u64))
    }
    #[]public fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#18>]<Element#18>(&copy t.vec)
    }
    #[]public fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool {
        ! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#19>]<Element#19>(&copy t.vec)
    }
    #[]public fun none<Element#22>(): (std=0x1)::option::Option<Element#22> {
        (std=0x1)::option::Option<Element#22>{(0#vec:vector<Element#22>): (std=0x1)::vector::empty<Element#22>(())}
    }
    #[]public fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23> {
        (std=0x1)::option::Option<Element#23>{(0#vec:vector<Element#23>): (std=0x1)::vector::singleton[parameter_types: [Element#23]<Element#23>(move e)}
    }
    #[]public fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#24>]<Element#24>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        let vec_ref: (&mut vector<Element#24>) = &mut copy t.vec;
        let old_value: (Element#24) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#24>]<Element#24>(copy vec_ref);
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#24>, Element#24]<Element#24>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25> {
        let vec_ref: (&mut vector<Element#25>) = &mut copy t.vec;
        let old_value: ((std=0x1)::option::Option<Element#25>) = if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#25>]<Element#25>(copy vec_ref)) (std=0x1)::option::none<Element#25>(()) else (std=0x1)::option::some[parameter_types: [Element#25]<Element#25>((std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#25>]<Element#25>(copy vec_ref));
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#25>, Element#25]<Element#25>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26> {
        let (std=0x1)::option::Option<Element#26>{0#vec: vec}: ((std=0x1)::option::Option<Element#26>) = move t;
        move vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address[parameter_types: [&signer]<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2u64;
    #[]const EINVALID_UTF8:u64 = 1u64;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append[parameter_types: [&mut vector<u8>, vector<u8>]<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((copy s, (std=0x1)::string::utf8[parameter_types: [vector<u8>]<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of[parameter_types: [&vector<u8>, &vector<u8>]<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes: (&vector<u8>) = &copy s.bytes;
        assert((copy at <=@u64 (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy at)), (std=0x1)::string::EINVALID_INDEX));
        let l: (u64) = (std=0x1)::string::length[parameter_types: [&(std=0x1)::string::String]<>(copy s);
        let front: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, 0u64, copy at));
        let end: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, copy at, copy l));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy o));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy end));
        *copy s = copy front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes: (&vector<u8>) = &copy s.bytes;
        let l: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes);
        assert((copy j <=@u64 copy l &&@bool copy i <=@u64 copy j &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy i)) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy j)), (std=0x1)::string::EINVALID_INDEX));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): (std=0x1)::string::internal_sub_string[parameter_types: [&vector<u8>, u64, u64]<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes))  {
            (std=0x1)::option::some[parameter_types: [(std=0x1)::string::String]<(std=0x1)::string::String>((std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes})
        } else  {
            (std=0x1)::option::none<(std=0x1)::string::String>(())
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert(((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes), (std=0x1)::string::EINVALID_UTF8));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &copy self.name
    }
    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072u64;
    #[]public fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#28>]<Element#28>(&mut other);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#28>]<Element#28>(&other))(std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#28>, Element#28]<Element#28>((copy lhs, (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#28>]<Element#28>(&mut other)));
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#28>]<Element#28>(move other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#31>]<Element#31>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#31>, u64]<Element#31>((copy v, copy i)) ==@&Element#31 copy e) return true else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64) {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#40>]<Element#40>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#40>, u64]<Element#40>((copy v, copy i)) ==@&Element#40 copy e) return (true, copy i) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        (false, 0u64)
    }
    #[]public fun is_empty<Element#41>(v: &vector<Element#41>): bool {
        (std=0x1)::vector::length[parameter_types: [&vector<Element#41>]<Element#41>(copy v) ==@u64 0u64
    }
    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47 {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#47>]<Element#47>(copy v);
        if (copy i >=@u64 copy len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len: (u64) = copy len -@u64 1u64;
        while (copy i <@u64 copy len)(std=0x1)::vector::swap[parameter_types: [&mut vector<Element#47>, u64, u64]<Element#47>((copy v, copy i,  {
            i: (u64) = copy i +@u64 1u64;
            copy i
        }));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#47>]<Element#47>(copy v)
    }
    #[]public fun reverse<Element#48>(v: &mut vector<Element#48>): () {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#48>]<Element#48>(copy v);
        if (copy len ==@u64 0u64) return () else ();
        let front_index: (u64) = 0u64;
        let back_index: (u64) = copy len -@u64 1u64;
        while (copy front_index <@u64 copy back_index) {
            (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#48>, u64, u64]<Element#48>((copy v, copy front_index, copy back_index));
            front_index: (u64) = copy front_index +@u64 1u64;
            back_index: (u64) = copy back_index -@u64 1u64;
            /*()*/
        }
    }
    #[]public fun singleton<Element#49>(e: Element#49): vector<Element#49> {
        let v: (vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#49>, Element#49]<Element#49>((&mut v, move e));
        move v
    }
    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51 {
        assert((! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#51>]<Element#51>(copy v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS));
        let last_idx: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#51>]<Element#51>(copy v) -@u64 1u64;
        (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#51>, u64, u64]<Element#51>((copy v, copy i, copy last_idx));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#51>]<Element#51>(copy v)
    }

}
After hlir: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        byte: u8
    }
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 =  {
        locals:


        return 65536u64
    };
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        locals:
            byte: u8,
            i: u64,
            len: u64,
            string: &(std=0x1)::ascii::String

        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        while ( {
            pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            copy i < copy len
        }) {
            (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char<>(copy byte))  {
                return@false
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        locals:
            string: &(std=0x1)::ascii::String

        return &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        locals:
            byte: u8,
            char: (std=0x1)::ascii::Char

        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        locals:
            byte: u8

        if ((std=0x1)::ascii::is_valid_char<>(copy byte))  {
            pop  = ()
        } else  {
            abort EINVALID_ASCII_CHARACTER
        };
        pop  = /*()*/;
        return Char<>{byte: copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        locals:
            bytes: vector<u8>,
            string: (std=0x1)::ascii::String

        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        locals:
            %#1: bool,
            byte: u8

        if (copy byte >= 32u8)  {
            (%#1: bool) = copy byte <= 126u8
        } else  {
            (%#1: bool) = false
        };
        return move#last %#1
    }
    #[]public fun is_valid_char(b: u8): bool {
        locals:
            b: u8

        return copy b <= 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        locals:
            string: &(std=0x1)::ascii::String

        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        locals:
            string: &mut (std=0x1)::ascii::String

        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        locals:
            char: (std=0x1)::ascii::Char,
            string: &mut (std=0x1)::ascii::String

        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        locals:
            bytes: vector<u8>,
            x: (std=0x1)::option::Option<(std=0x1)::ascii::String>

        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        if ((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x))  {
            pop  = ()
        } else  {
            abort EINVALID_ASCII_CHARACTER
        };
        pop  = /*()*/;
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        locals:
            bytes: vector<u8>,
            i: u64,
            len: u64,
            possible_byte: u8

        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        while ( {
            pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            copy i < copy len
        }) {
            (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char<>(copy possible_byte))  {
                return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        length: u64;
        bit_field: vector<bool>
    }
    #[]const EINDEX:u64 =  {
        locals:


        return 131072u64
    };
    #[]const ELENGTH:u64 =  {
        locals:


        return 131073u64
    };
    #[]const MAX_SIZE:u64 =  {
        locals:


        return 1024u64
    };
    #[]const WORD_SIZE:u64 =  {
        locals:


        return 1u64
    };
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        locals:
            bit_index: u64,
            bitvector: &(std=0x1)::bit_vector::BitVector

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector

        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector,
            index: u64,
            start_index: u64

        if (copy start_index < *&copy bitvector.length)  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (index: u64) = copy start_index;
        while (copy index < *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index)))  {
                break
            } else  {
                pop  = ()
            };
            (index: u64) = copy index + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return copy index - copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        locals:
            bit_field: vector<bool>,
            counter: u64,
            length: u64

        if (copy length > 0u64)  {
            pop  = ()
        } else  {
            abort ELENGTH
        };
        pop  = /*()*/;
        if (copy length < MAX_SIZE)  {
            pop  = ()
        } else  {
            abort ELENGTH
        };
        pop  = /*()*/;
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter < copy length
        }) {
            pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
            (counter: u64) = copy counter + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        pop  = /*()*/;
        return /*;()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        locals:
            %#2: &mut (std=0x1)::bit_vector::BitVector,
            %#3: u64,
            amount: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            elem: &mut bool,
            i: u64,
            i#1: u64,
            len: u64

        if (copy amount >= *&copy bitvector.length)  {
            (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
            (i: u64) = 0u64;
            while (copy i < copy len) {
                (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                pop  = /*()*/;
                (i: u64) = copy i + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        } else  {
            (i#1: u64) = copy amount;
            while (copy i#1 < *&copy bitvector.length) {
                ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
                if ((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3)))  {
                    pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount))
                } else  {
                    pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount))
                };
                (i#1: u64) = copy i#1 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            (i#1: u64) = *&copy bitvector.length - copy amount;
            pop  = /*()*/;
            while (copy i#1 < *&copy bitvector.length) {
                pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
                (i#1: u64) = copy i#1 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        };
        return /*()*/
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        pop  = /*()*/;
        return /*;()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 =  {
        locals:


        return 7u64
    };
    #[]const ALREADY_EXISTS:u64 =  {
        locals:


        return 8u64
    };
    #[]const CANCELLED:u64 =  {
        locals:


        return 10u64
    };
    #[]const INTERNAL:u64 =  {
        locals:


        return 11u64
    };
    #[]const INVALID_ARGUMENT:u64 =  {
        locals:


        return 1u64
    };
    #[]const INVALID_STATE:u64 =  {
        locals:


        return 3u64
    };
    #[]const NOT_FOUND:u64 =  {
        locals:


        return 6u64
    };
    #[]const NOT_IMPLEMENTED:u64 =  {
        locals:


        return 12u64
    };
    #[]const OUT_OF_RANGE:u64 =  {
        locals:


        return 2u64
    };
    #[]const PERMISSION_DENIED:u64 =  {
        locals:


        return 5u64
    };
    #[]const RESOURCE_EXHAUSTED:u64 =  {
        locals:


        return 9u64
    };
    #[]const UNAUTHENTICATED:u64 =  {
        locals:


        return 4u64
    };
    #[]const UNAVAILABLE:u64 =  {
        locals:


        return 13u64
    };
    #[]public fun aborted(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        locals:
            category: u64,
            reason: u64

        return copy category << 16u8 + copy reason
    }
    #[]public fun internal(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        value: u64
    }
    #[]const EDENOMINATOR:u64 =  {
        locals:


        return 65537u64
    };
    #[]const EDIVISION:u64 =  {
        locals:


        return 131074u64
    };
    #[]const EDIVISION_BY_ZERO:u64 =  {
        locals:


        return 65540u64
    };
    #[]const EMULTIPLICATION:u64 =  {
        locals:


        return 131075u64
    };
    #[]const ERATIO_OUT_OF_RANGE:u64 =  {
        locals:


        return 131077u64
    };
    #[]const MAX_U64:u128 =  {
        locals:


        return 18446744073709551615u128
    };
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32,
            val: u128

        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        if (*&&num.value == copy floored_num)  {
            return@copy floored_num >> 32u8
        } else  {
            pop  = ()
        };
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: bool,
            denominator: u64,
            numerator: u64,
            quotient: u128,
            scaled_denominator: u128,
            scaled_numerator: u128

        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        if (copy scaled_denominator != 0u128)  {
            pop  = ()
        } else  {
            abort EDENOMINATOR
        };
        pop  = /*()*/;
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        if (copy quotient != 0u128)  {
            (%#1: bool) = true
        } else  {
            (%#1: bool) = copy numerator == 0u64
        };
        if (move#last %#1)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        if (copy quotient <= MAX_U64)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        return FixedPoint32<>{value: (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            value: u64

        return FixedPoint32<>{value: copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            val: u64,
            value: u128

        (value: u128) = (copy val as u128) << 32u8;
        if (copy value <= MAX_U64)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        return FixedPoint32<>{value: (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            divisor: (std=0x1)::fixed_point32::FixedPoint32,
            quotient: u128,
            scaled_value: u128,
            val: u64

        if (*&&divisor.value != 0u64)  {
            pop  = ()
        } else  {
            abort EDIVISION_BY_ZERO
        };
        pop  = /*()*/;
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        if (copy quotient <= MAX_U64)  {
            pop  = ()
        } else  {
            abort EDIVISION
        };
        pop  = /*()*/;
        return (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value >> 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value == 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        if (*&&num1.value > *&&num2.value)  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1
        } else  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2
        };
        return move#last %#1
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        if (*&&num1.value < *&&num2.value)  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1
        } else  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2
        };
        return move#last %#1
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            multiplier: (std=0x1)::fixed_point32::FixedPoint32,
            product: u128,
            unscaled_product: u128,
            val: u64

        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        if (copy product <= MAX_U64)  {
            pop  = ()
        } else  {
            abort EMULTIPLICATION
        };
        pop  = /*()*/;
        return (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            %#1: u64,
            boundary: u64,
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32

        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        if (*&&num.value < copy boundary)  {
            (%#1: u64) = copy floored_num >> 32u8
        } else  {
            (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num)
        };
        return move#last %#1
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#1> has copy drop store {
        vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 =  {
        locals:


        return 262144u64
    };
    #[]const EOPTION_NOT_SET:u64 =  {
        locals:


        return 262145u64
    };
    #[]public fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2 {
        locals:
            t: &(std=0x1)::option::Option<Element#2>

        if ((std=0x1)::option::is_some<Element#2>(copy t))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::borrow<Element#2>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#3>

        if ((std=0x1)::option::is_some<Element#3>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::borrow_mut<Element#3>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4 {
        locals:
            %#1: &Element#4,
            default_ref: &Element#4,
            t: &(std=0x1)::option::Option<Element#4>,
            vec_ref: &vector<Element#4>

        (vec_ref: &vector<Element#4>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#4>(copy vec_ref))  {
            (%#1: &Element#4) = copy default_ref
        } else  {
            (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((copy vec_ref, 0u64))
        };
        return move#last %#1
    }
    #[]public fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool {
        locals:
            e_ref: &Element#5,
            t: &(std=0x1)::option::Option<Element#5>

        return (std=0x1)::vector::contains<Element#5>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): () {
        locals:
            t: (std=0x1)::option::Option<Element#6>,
            vec: vector<Element#6>

        if ((std=0x1)::option::is_none<Element#6>(&t))  {
            pop  = ()
        } else  {
            abort EOPTION_IS_SET
        };
        pop  = /*()*/;
        Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)
    }
    #[]public fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7 {
        locals:
            elem: Element#7,
            t: (std=0x1)::option::Option<Element#7>,
            vec: vector<Element#7>

        if ((std=0x1)::option::is_some<Element#7>(&t))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
        (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
        return move#no-copy elem
    }
    #[]public fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop {
        locals:
            %#1: Element#8: drop,
            default: Element#8: drop,
            t: (std=0x1)::option::Option<Element#8: drop>,
            vec: vector<Element#8: drop>

        Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
        if ((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec)))  {
            (%#1: Element#8: drop) = move#no-copy default
        } else  {
            (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec)
        };
        return move#last %#1
    }
    #[]public fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#9>

        if ((std=0x1)::option::is_some<Element#9>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::pop_back<Element#9>(&mut copy t.vec)
    }
    #[]public fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): () {
        locals:
            e: Element#10,
            t: &mut (std=0x1)::option::Option<Element#10>,
            vec_ref: &mut vector<Element#10>

        (vec_ref: &mut vector<Element#10>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref)))  {
            pop  = (std=0x1)::vector::push_back<Element#10>((copy vec_ref, move#no-copy e))
        } else  {
            abort EOPTION_IS_SET
        };
        return /*()*/
    }
    #[]public fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop {
        locals:
            %#1: Element#17: copy+drop,
            default: Element#17: copy+drop,
            t: &(std=0x1)::option::Option<Element#17: copy+drop>,
            vec_ref: &vector<Element#17: copy+drop>

        (vec_ref: &vector<Element#17: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref))  {
            (%#1: Element#17: copy+drop) = copy default
        } else  {
            (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((copy vec_ref, 0u64))
        };
        return move#last %#1
    }
    #[]public fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#18>

        return (std=0x1)::vector::is_empty<Element#18>(&copy t.vec)
    }
    #[]public fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#19>

        return ! (std=0x1)::vector::is_empty<Element#19>(&copy t.vec)
    }
    #[]public fun none<Element#22>(): (std=0x1)::option::Option<Element#22> {
        locals:


        return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}
    }
    #[]public fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23> {
        locals:
            e: Element#23

        return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}
    }
    #[]public fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24 {
        locals:
            e: Element#24,
            old_value: Element#24,
            t: &mut (std=0x1)::option::Option<Element#24>,
            vec_ref: &mut vector<Element#24>

        if ((std=0x1)::option::is_some<Element#24>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        (vec_ref: &mut vector<Element#24>) = &mut copy t.vec;
        (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#24>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
    }
    #[]public fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25> {
        locals:
            %#1: (std=0x1)::option::Option<Element#25>,
            e: Element#25,
            old_value: (std=0x1)::option::Option<Element#25>,
            t: &mut (std=0x1)::option::Option<Element#25>,
            vec_ref: &mut vector<Element#25>

        (vec_ref: &mut vector<Element#25>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref)))  {
            (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(())
        } else  {
            (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref))
        };
        (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#25>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
    }
    #[]public fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26> {
        locals:
            t: (std=0x1)::option::Option<Element#26>,
            vec: vector<Element#26>

        Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
        return move#no-copy vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        locals:
            s: &signer

        return *(std=0x1)::signer::borrow_address<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 =  {
        locals:


        return 2u64
    };
    #[]const EINVALID_UTF8:u64 =  {
        locals:


        return 1u64
    };
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        locals:
            r: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        locals:
            bytes: vector<u8>,
            s: &mut (std=0x1)::string::String

        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        locals:
            s: &(std=0x1)::string::String

        return &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        locals:
            r: &(std=0x1)::string::String,
            s: &(std=0x1)::string::String

        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        locals:
            %#1: bool,
            %#2: &mut (std=0x1)::string::String,
            %#3: u64,
            %#4: u64,
            %#5: &mut (std=0x1)::string::String,
            %#6: u64,
            %#7: u64,
            at: u64,
            bytes: &vector<u8>,
            end: (std=0x1)::string::String,
            front: (std=0x1)::string::String,
            l: u64,
            o: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        (bytes: &vector<u8>) = &copy s.bytes;
        if (copy at <= (std=0x1)::vector::length<u8>(copy bytes))  {
            (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at))
        } else  {
            (%#1: bool) = false
        };
        if (move#last %#1)  {
            pop  = ()
        } else  {
            abort EINVALID_INDEX
        };
        pop  = /*()*/;
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        pop  = /*()*/;
        return /*;()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        locals:
            s: &(std=0x1)::string::String

        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        locals:
            s: &(std=0x1)::string::String

        return (std=0x1)::vector::length<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        locals:
            %#1: bool,
            %#2: bool,
            %#3: bool,
            bytes: &vector<u8>,
            i: u64,
            j: u64,
            l: u64,
            s: &(std=0x1)::string::String

        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        if (copy j <= copy l)  {
            (%#1: bool) = copy i <= copy j
        } else  {
            (%#1: bool) = false
        };
        if (move#last %#1)  {
            (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i))
        } else  {
            (%#2: bool) = false
        };
        if (move#last %#2)  {
            (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j))
        } else  {
            (%#3: bool) = false
        };
        if (move#last %#3)  {
            pop  = ()
        } else  {
            abort EINVALID_INDEX
        };
        pop  = /*()*/;
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        locals:
            %#1: (std=0x1)::option::Option<(std=0x1)::string::String>,
            bytes: vector<u8>

        if ((std=0x1)::string::internal_check_utf8<>(&bytes))  {
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes})
        } else  {
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(())
        };
        return move#last %#1
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        locals:
            bytes: vector<u8>

        if ((std=0x1)::string::internal_check_utf8<>(&bytes))  {
            pop  = ()
        } else  {
            abort EINVALID_UTF8
        };
        pop  = /*()*/;
        return String<>{bytes: copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        locals:
            self: &(std=0x1)::type_name::TypeName

        return &copy self.name
    }
    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        locals:
            self: (std=0x1)::type_name::TypeName

        return *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 =  {
        locals:


        return 131072u64
    };
    #[]public fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): () {
        locals:
            lhs: &mut vector<Element#28>,
            other: vector<Element#28>

        pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
        while (! (std=0x1)::vector::is_empty<Element#28>(&other)) {
            pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)))
        };
        pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
        return /*;()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool {
        locals:
            e: &Element#31,
            i: u64,
            len: u64,
            v: &vector<Element#31>

        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
        while (copy i < copy len) {
            if ((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e)  {
                return@true
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64) {
        locals:
            e: &Element#40,
            i: u64,
            len: u64,
            v: &vector<Element#40>

        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
        while (copy i < copy len) {
            if ((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e)  {
                return@(true, copy i)
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return (false, 0u64)
    }
    #[]public fun is_empty<Element#41>(v: &vector<Element#41>): bool {
        locals:
            v: &vector<Element#41>

        return (std=0x1)::vector::length<Element#41>(copy v) == 0u64
    }
    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47 {
        locals:
            %#1: u64,
            %#2: &mut vector<Element#47>,
            i: u64,
            len: u64,
            v: &mut vector<Element#47>

        (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
        if (copy i >= copy len)  {
            abort EINDEX_OUT_OF_BOUNDS
        } else  {
            pop  = ()
        };
        (len: u64) = copy len - 1u64;
        pop  = /*()*/;
        while (copy i < copy len) {
            (%#2: &mut vector<Element#47>) = copy v;
            (%#1: u64) = copy i;
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i))
        };
        return (std=0x1)::vector::pop_back<Element#47>(copy v)
    }
    #[]public fun reverse<Element#48>(v: &mut vector<Element#48>): () {
        locals:
            back_index: u64,
            front_index: u64,
            len: u64,
            v: &mut vector<Element#48>

        (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
        if (copy len == 0u64)  {
            return@()
        } else  {
            pop  = ()
        };
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        while (copy front_index < copy back_index) {
            pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
            (front_index: u64) = copy front_index + 1u64;
            pop  = /*()*/;
            (back_index: u64) = copy back_index - 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return /*()*/
    }
    #[]public fun singleton<Element#49>(e: Element#49): vector<Element#49> {
        locals:
            e: Element#49,
            v: vector<Element#49>

        (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
        return move#no-copy v
    }
    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51 {
        locals:
            i: u64,
            last_idx: u64,
            v: &mut vector<Element#51>

        if (! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v)))  {
            pop  = ()
        } else  {
            abort EINDEX_OUT_OF_BOUNDS
        };
        pop  = /*()*/;
        (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#51>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#51>(copy v)
    }

}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(copy byte)) 3 else 4

    
    label 3:
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(copy byte)) 3 else 4

    
    label 3:
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 4

    
    label 3:
        pop _ = move#last string;
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 5

    
    label 3:
        pop _ = move#last string;
        return@false

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy string.bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy string.bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last string.bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last string.bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = move#last char;
        return move#last byte
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = move#last char;
        return move#last byte
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: copy byte}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: copy byte}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: move#last byte}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 3 else 2

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: move#last byte}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = move#last string;
        return move#last bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = move#last string;
        return move#last bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = copy byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = copy byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = move#last byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = move#last byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy b <= 127u8
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy b <= 127u8
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last b <= 127u8
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last b <= 127u8
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 3 else 2

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(copy possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(copy possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 5

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 9]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [4, 6]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 2

loop heads:
    loop head: 4. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 9

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 9]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [4, 6]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 2

loop heads:
    loop head: 4. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index

    
    label 13:
        jump 9
After recompute, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 7
    7 => 8
    8 => 13
    13 => 2

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index

    
    label 13:
        jump 9
dead_blocks is 
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 7
    7 => 8
    8 => 13
    13 => 2

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        pop _ = move#last bitvector;
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = move#last index + 1u64;
        jump 4

    
    label 9:
        return move#last index - move#last start_index

    
    label 13:
        pop _ = move#last bitvector;
        jump 9
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 8]
    6 => [9]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    8 <= [5]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 8
    8 => 13

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 8

    
    label 6:
        pop _ = move#last bitvector;
        jump@9

    
    label 8:
        (index: u64) = move#last index + 1u64;
        jump 4

    
    label 9:
        return move#last index - move#last start_index

    
    label 13:
        pop _ = move#last bitvector;
        jump 9
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = copy counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = copy counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = move#last counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: move#last length, bit_field: move#last bit_field}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [5, 6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    5 <= [3]
    6 <= [3]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 2
    2 => 3
    3 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 3 else 2

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 6 else 5

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = move#last counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: move#last length, bit_field: move#last bit_field}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = true;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = true;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *copy elem = false;
        (i: u64) = copy i + 1u64;
        jump 2

    
    label 4:
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = copy i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - copy amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = copy i#1 + 1u64;
        jump 12

    
    label 14:
        jump 15

    
    label 15:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *copy elem = false;
        (i: u64) = copy i + 1u64;
        jump 2

    
    label 4:
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = copy i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - copy amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = copy i#1 + 1u64;
        jump 12

    
    label 14:
        jump 15

    
    label 15:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *move#last elem = false;
        (i: u64) = move#last i + 1u64;
        jump 2

    
    label 4:
        pop _ = move#last bitvector;
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = move#last i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - move#last amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = move#last i#1 + 1u64;
        jump 12

    
    label 14:
        pop _ = move#last bitvector;
        jump 15

    
    label 15:
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *move#last elem = false;
        (i: u64) = move#last i + 1u64;
        jump 2

    
    label 4:
        pop _ = move#last bitvector;
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = move#last i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - move#last amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = move#last i#1 + 1u64;
        jump 12

    
    label 14:
        pop _ = move#last bitvector;
        jump 15

    
    label 15:
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = false;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = false;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy category << 16u8 + copy reason
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy category << 16u8 + copy reason
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last category << 16u8 + move#last reason
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last category << 16u8 + move#last reason
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@copy floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@copy floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@move#last floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (move#last floored_num as u128) + 1u128 << 32u8;
        return (move#last val >> 32u8 as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]

traversal:
    0 => 1
    1 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 3

    
    label 1:
        return@move#last floored_num >> 32u8

    
    label 3:
        (val: u128) = (move#last floored_num as u128) + 4294967296u128;
        return (move#last val >> 32u8 as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = copy numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (copy quotient as u64)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = copy numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (copy quotient as u64)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = move#last numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (move#last quotient as u64)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [8, 9]
    8 => []
    9 => [11, 12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    8 <= [6]
    9 <= [6]
    11 <= [9]
    12 <= [9]

traversal:
    0 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 8
    8 => 9
    9 => 11
    11 => 12

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 3 else 2

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = move#last numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 9 else 8

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 12 else 11

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (move#last quotient as u64)}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: copy value}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: copy value}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: move#last value}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: move#last value}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (copy val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (copy value as u64)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (copy val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (copy value as u64)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (move#last val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (move#last value as u64)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (move#last val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 3 else 2

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (move#last value as u64)}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (copy quotient as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (copy quotient as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (move#last val as u128) << 32u8;
        (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (move#last quotient as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [5, 6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    5 <= [3]
    6 <= [3]

traversal:
    0 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 3 else 2

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (move#last val as u128) << 32u8;
        (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 6 else 5

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (move#last quotient as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (copy product as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (copy product as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
        (product: u128) = move#last unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (move#last product as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
        (product: u128) = move#last unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 3 else 2

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (move#last product as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < copy boundary) 1 else 2

    
    label 1:
        (%#1: u64) = copy floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num);
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < copy boundary) 1 else 2

    
    label 1:
        (%#1: u64) = copy floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num);
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < move#last boundary) 1 else 2

    
    label 1:
        (%#1: u64) = move#last floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 2147483648u64;
        jump_if(*&&num.value < move#last boundary) 1 else 2

    
    label 1:
        (%#1: u64) = move#last floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#2>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#2>((&copy t.vec, 0u64))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#2>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#2>((&copy t.vec, 0u64))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#2>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#2>((&move#last t.vec, 0u64))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#2>(copy t)) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#2>((&move#last t.vec, 0u64))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#3>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#3>((&mut copy t.vec, 0u64))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#3>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#3>((&mut copy t.vec, 0u64))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#3>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#3>((&mut move#last t.vec, 0u64))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#3>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#3>((&mut move#last t.vec, 0u64))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#4>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#4>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: &Element#4) = copy default_ref;
        jump 3

    
    label 2:
        (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#4>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#4>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: &Element#4) = copy default_ref;
        jump 3

    
    label 2:
        (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#4>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#4>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: &Element#4) = move#last default_ref;
        jump 3

    
    label 2:
        pop _ = move#last default_ref;
        (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#4>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#4>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: &Element#4) = move#last default_ref;
        jump 3

    
    label 2:
        pop _ = move#last default_ref;
        (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#5>((&copy t.vec, copy e_ref))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#5>((&copy t.vec, copy e_ref))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#5>((&move#last t.vec, move#last e_ref))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#5>((&move#last t.vec, move#last e_ref))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#6>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#6>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#6>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#6>(&t)) 3 else 2

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#7>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
        (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
        return move#no-copy elem
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#7>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
        (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
        return move#no-copy elem
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#7>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
        (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
        return move#no-copy elem
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#7>(&t)) 3 else 2

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
        (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
        return move#no-copy elem
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#8: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#8: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#8: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#8: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#9>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#9>(&mut copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#9>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#9>(&mut copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#9>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#9>(&mut move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#9>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#9>(&mut move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#10>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#10>((copy vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#10>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#10>((copy vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#10>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#10>((move#last vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        pop _ = move#last vec_ref;
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#10>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref))) 3 else 2

    
    label 2:
        pop _ = move#last vec_ref;
        abort EOPTION_IS_SET

    
    label 3:
        pop  = (std=0x1)::vector::push_back<Element#10>((move#last vec_ref, move#no-copy e));
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#17: copy+drop>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: Element#17: copy+drop) = copy default;
        jump 3

    
    label 2:
        (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#17: copy+drop>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: Element#17: copy+drop) = copy default;
        jump 3

    
    label 2:
        (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#17: copy+drop>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: Element#17: copy+drop) = move#last default;
        jump 3

    
    label 2:
        (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#17: copy+drop>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: Element#17: copy+drop) = move#last default;
        jump 3

    
    label 2:
        (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#18>(&copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#18>(&copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#18>(&move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#18>(&move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#19>(&copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#19>(&copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#19>(&move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#19>(&move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#24>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#24>) = &mut copy t.vec;
        (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#24>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#24>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#24>) = &mut copy t.vec;
        (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#24>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#24>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#24>) = &mut move#last t.vec;
        (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#24>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#24>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#24>) = &mut move#last t.vec;
        (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#24>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#25>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#25>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#25>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#25>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#25>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#25>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#25>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#25>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
        return move#no-copy vec
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
        return move#no-copy vec
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
        return move#no-copy vec
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
        return move#no-copy vec
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(copy s)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(copy s)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(move#last s)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(move#last s)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy s.bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy s.bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last s.bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last s.bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at));
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at));
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
        jump 3

    
    label 2:
        pop _ = move#last bytes;
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        pop _ = move#last s;
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, move#last o));
        pop  = (std=0x1)::string::append<>((&mut front, move#last end));
        *move#last s = move#last front;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [5, 6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    5 <= [3]
    6 <= [3]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
        jump 3

    
    label 2:
        pop _ = move#last bytes;
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 6 else 5

    
    label 5:
        pop _ = move#last s;
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#4: u64)) = (copy s, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), 0u64, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, move#last o));
        pop  = (std=0x1)::string::append<>((&mut front, move#last end));
        *move#last s = move#last front;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&copy s.bytes)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&copy s.bytes)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&move#last s.bytes)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&move#last s.bytes)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= copy l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= copy l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &move#last s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= move#last l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        pop _ = move#last bytes;
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [11, 12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    11 <= [9]
    12 <= [9]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 11
    11 => 12

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &move#last s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= move#last l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 12 else 11

    
    label 11:
        pop _ = move#last bytes;
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: copy bytes}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: copy bytes}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: move#last bytes}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 3 else 2

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: move#last bytes}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy self.name
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy self.name
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last self.name
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last self.name
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#28>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)));
        jump 1

    
    label 3:
        pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#28>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)));
        jump 1

    
    label 3:
        pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#28>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)));
        jump 1

    
    label 3:
        pop _ = move#last lhs;
        pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#28>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)));
        jump 1

    
    label 3:
        pop _ = move#last lhs;
        pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return false
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return false
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return false
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e) 3 else 5

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@true

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return false
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@(true, copy i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return (false, 0u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@(true, copy i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return (false, 0u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@(true, move#last i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return (false, 0u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e) 3 else 5

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@(true, move#last i)

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return (false, 0u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#41>(copy v) == 0u64
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#41>(copy v) == 0u64
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#41>(move#last v) == 0u64
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#41>(move#last v) == 0u64
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#47>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = copy i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#47>(copy v)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#47>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = copy i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#47>(copy v)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#47>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = move#last i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#47>(move#last v)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 3

    
    label 1:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (len: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#47>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = move#last i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#47>(move#last v)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
        (front_index: u64) = copy front_index + 1u64;
        (back_index: u64) = copy back_index - 1u64;
        jump 4

    
    label 6:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
        (front_index: u64) = copy front_index + 1u64;
        (back_index: u64) = copy back_index - 1u64;
        jump 4

    
    label 6:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        pop _ = move#last v;
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
        (front_index: u64) = move#last front_index + 1u64;
        (back_index: u64) = move#last back_index - 1u64;
        jump 4

    
    label 6:
        pop _ = move#last v;
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 3

    
    label 1:
        pop _ = move#last v;
        return@()

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
        (front_index: u64) = move#last front_index + 1u64;
        (back_index: u64) = move#last back_index - 1u64;
        jump 4

    
    label 6:
        pop _ = move#last v;
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
        return move#no-copy v
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
        return move#no-copy v
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
        return move#no-copy v
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
        return move#no-copy v
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#51>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#51>(copy v)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#51>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#51>(copy v)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#51>((copy v, move#last i, move#last last_idx));
        return (std=0x1)::vector::pop_back<Element#51>(move#last v)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v))) 3 else 2

    
    label 2:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#51>((copy v, move#last i, move#last last_idx));
        return (std=0x1)::vector::pop_back<Element#51>(move#last v)
After cfgir: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        byte: u8
    }
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        locals:
            byte: u8,
            i: u64,
            len: u64,
            string: &(std=0x1)::ascii::String

        loop heads:

            1

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
            (i: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
            jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 5

        
        label 3:
            pop _ = move#last string;
            return@false

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
            return true


    }
    #[]public as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        locals:
            string: &(std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return &move#last string.bytes


    }
    #[]public byte(char: (std=0x1)::ascii::Char): u8 {
        locals:
            byte: u8,
            char: (std=0x1)::ascii::Char

        loop heads:


        start=0

        label 0:
            Char<>{byte: (byte: u8)} = move#last char;
            return move#last byte


    }
    #[]public char(byte: u8): (std=0x1)::ascii::Char {
        locals:
            byte: u8

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 3 else 2

        
        label 2:
            abort EINVALID_ASCII_CHARACTER

        
        label 3:
            return Char<>{byte: move#last byte}


    }
    #[]public into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        locals:
            bytes: vector<u8>,
            string: (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            String<>{bytes: (bytes: vector<u8>)} = move#last string;
            return move#last bytes


    }
    #[]public is_printable_char(byte: u8): bool {
        locals:
            %#1: bool,
            byte: u8

        loop heads:


        start=0

        label 0:
            jump_if(copy byte >= 32u8) 1 else 2

        
        label 1:
            (%#1: bool) = move#last byte <= 126u8;
            jump 3

        
        label 2:
            (%#1: bool) = false;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public is_valid_char(b: u8): bool {
        locals:
            b: u8

        loop heads:


        start=0

        label 0:
            return move#last b <= 127u8


    }
    #[]public length(string: &(std=0x1)::ascii::String): u64 {
        locals:
            string: &(std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))


    }
    #[]public pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        locals:
            string: &mut (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}


    }
    #[]public push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        locals:
            char: (std=0x1)::ascii::Char,
            string: &mut (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
            return /*;()*/


    }
    #[]public string(bytes: vector<u8>): (std=0x1)::ascii::String {
        locals:
            bytes: vector<u8>,
            x: (std=0x1)::option::Option<(std=0x1)::ascii::String>

        loop heads:


        start=0

        label 0:
            (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
            jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 3 else 2

        
        label 2:
            abort EINVALID_ASCII_CHARACTER

        
        label 3:
            return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)


    }
    #[]public try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        locals:
            bytes: vector<u8>,
            i: u64,
            len: u64,
            possible_byte: u8

        loop heads:

            1

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
            (i: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
            jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 5

        
        label 3:
            return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
            return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})


    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        length: u64;
        bit_field: vector<bool>
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        locals:
            bit_index: u64,
            bitvector: &(std=0x1)::bit_vector::BitVector

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))


    }
    #[]public length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)


    }
    #[]public longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector,
            index: u64,
            start_index: u64

        loop heads:

            4

        start=0

        label 0:
            jump_if(copy start_index < *&copy bitvector.length) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (index: u64) = copy start_index;
            jump 4

        
        label 4:
            jump_if(copy index < *&copy bitvector.length) 5 else 13

        
        label 5:
            jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 8

        
        label 6:
            pop _ = move#last bitvector;
            jump@9

        
        label 8:
            (index: u64) = move#last index + 1u64;
            jump 4

        
        label 9:
            return move#last index - move#last start_index

        
        label 13:
            pop _ = move#last bitvector;
            jump 9


    }
    #[]public new(length: u64): (std=0x1)::bit_vector::BitVector {
        locals:
            bit_field: vector<bool>,
            counter: u64,
            length: u64

        loop heads:

            7

        start=0

        label 0:
            jump_if(copy length > 0u64) 3 else 2

        
        label 2:
            abort ELENGTH

        
        label 3:
            jump_if(copy length < MAX_SIZE) 6 else 5

        
        label 5:
            abort ELENGTH

        
        label 6:
            (counter: u64) = 0u64;
            (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
            jump 7

        
        label 7:
            pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            jump_if(copy counter < copy length) 8 else 9

        
        label 8:
            pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
            (counter: u64) = move#last counter + 1u64;
            jump 7

        
        label 9:
            pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
            return BitVector<>{length: move#last length, bit_field: move#last bit_field}


    }
    #[]public set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
            *move#last x = true;
            return /*;()*/


    }
    #[]public shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        locals:
            %#2: &mut (std=0x1)::bit_vector::BitVector,
            %#3: u64,
            amount: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            elem: &mut bool,
            i: u64,
            i#1: u64,
            len: u64

        loop heads:

            2
            6
            12

        start=0

        label 0:
            jump_if(copy amount >= *&copy bitvector.length) 1 else 5

        
        label 1:
            (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
            (i: u64) = 0u64;
            jump 2

        
        label 2:
            jump_if(copy i < copy len) 3 else 4

        
        label 3:
            (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
            *move#last elem = false;
            (i: u64) = move#last i + 1u64;
            jump 2

        
        label 4:
            pop _ = move#last bitvector;
            jump 15

        
        label 5:
            (i#1: u64) = copy amount;
            jump 6

        
        label 6:
            jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

        
        label 7:
            ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
            jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

        
        label 8:
            pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
            jump 10

        
        label 9:
            pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
            jump 10

        
        label 10:
            (i#1: u64) = move#last i#1 + 1u64;
            jump 6

        
        label 11:
            (i#1: u64) = *&copy bitvector.length - move#last amount;
            jump 12

        
        label 12:
            jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

        
        label 13:
            pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
            (i#1: u64) = move#last i#1 + 1u64;
            jump 12

        
        label 14:
            pop _ = move#last bitvector;
            jump 15

        
        label 15:
            return /*()*/


    }
    #[]public unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
            *move#last x = false;
            return /*;()*/


    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public aborted(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((ABORTED, move#last r))


    }
    #[]public already_exists(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))


    }
    #[]public canonical(category: u64, reason: u64): u64 {
        locals:
            category: u64,
            reason: u64

        loop heads:


        start=0

        label 0:
            return move#last category << 16u8 + move#last reason


    }
    #[]public internal(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INTERNAL, move#last r))


    }
    #[]public invalid_argument(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))


    }
    #[]public invalid_state(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))


    }
    #[]public not_found(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))


    }
    #[]public not_implemented(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))


    }
    #[]public out_of_range(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))


    }
    #[]public permission_denied(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))


    }
    #[]public resource_exhausted(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))


    }
    #[]public unauthenticated(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))


    }
    #[]public unavailable(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))


    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32,
            val: u128

        loop heads:


        start=0

        label 0:
            (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
            jump_if(*&&num.value == copy floored_num) 1 else 3

        
        label 1:
            return@move#last floored_num >> 32u8

        
        label 3:
            (val: u128) = (move#last floored_num as u128) + 4294967296u128;
            return (move#last val >> 32u8 as u64)


    }
    #[]public create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: bool,
            denominator: u64,
            numerator: u64,
            quotient: u128,
            scaled_denominator: u128,
            scaled_numerator: u128

        loop heads:


        start=0

        label 0:
            (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
            (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
            jump_if(copy scaled_denominator != 0u128) 3 else 2

        
        label 2:
            abort EDENOMINATOR

        
        label 3:
            (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
            jump_if(copy quotient != 0u128) 4 else 5

        
        label 4:
            (%#1: bool) = true;
            jump 6

        
        label 5:
            (%#1: bool) = move#last numerator == 0u64;
            jump 6

        
        label 6:
            jump_if(move#last %#1) 9 else 8

        
        label 8:
            abort ERATIO_OUT_OF_RANGE

        
        label 9:
            jump_if(copy quotient <= MAX_U64) 12 else 11

        
        label 11:
            abort ERATIO_OUT_OF_RANGE

        
        label 12:
            return FixedPoint32<>{value: (move#last quotient as u64)}


    }
    #[]public create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            value: u64

        loop heads:


        start=0

        label 0:
            return FixedPoint32<>{value: move#last value}


    }
    #[]public create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            val: u64,
            value: u128

        loop heads:


        start=0

        label 0:
            (value: u128) = (move#last val as u128) << 32u8;
            jump_if(copy value <= MAX_U64) 3 else 2

        
        label 2:
            abort ERATIO_OUT_OF_RANGE

        
        label 3:
            return FixedPoint32<>{value: (move#last value as u64)}


    }
    #[]public divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            divisor: (std=0x1)::fixed_point32::FixedPoint32,
            quotient: u128,
            scaled_value: u128,
            val: u64

        loop heads:


        start=0

        label 0:
            jump_if(*&&divisor.value != 0u64) 3 else 2

        
        label 2:
            abort EDIVISION_BY_ZERO

        
        label 3:
            (scaled_value: u128) = (move#last val as u128) << 32u8;
            (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
            jump_if(copy quotient <= MAX_U64) 6 else 5

        
        label 5:
            abort EDIVISION

        
        label 6:
            return (move#last quotient as u64)


    }
    #[]public floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value >> 32u8


    }
    #[]public get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value


    }
    #[]public is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value == 0u64


    }
    #[]public max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            jump_if(*&&num1.value > *&&num2.value) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
            jump 3

        
        label 2:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            jump_if(*&&num1.value < *&&num2.value) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
            jump 3

        
        label 2:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            multiplier: (std=0x1)::fixed_point32::FixedPoint32,
            product: u128,
            unscaled_product: u128,
            val: u64

        loop heads:


        start=0

        label 0:
            (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
            (product: u128) = move#last unscaled_product >> 32u8;
            jump_if(copy product <= MAX_U64) 3 else 2

        
        label 2:
            abort EMULTIPLICATION

        
        label 3:
            return (move#last product as u64)


    }
    #[]public round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            %#1: u64,
            boundary: u64,
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
            (boundary: u64) = copy floored_num + 2147483648u64;
            jump_if(*&&num.value < move#last boundary) 1 else 2

        
        label 1:
            (%#1: u64) = move#last floored_num >> 32u8;
            jump 3

        
        label 2:
            (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
            jump 3

        
        label 3:
            return move#last %#1


    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native sha2_256(data: vector<u8>): vector<u8>;

    #[]public native sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#1> has copy drop store {
        vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2 {
        locals:
            t: &(std=0x1)::option::Option<Element#2>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#2>(copy t)) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::borrow<Element#2>((&move#last t.vec, 0u64))


    }
    #[]public borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#3>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#3>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::borrow_mut<Element#3>((&mut move#last t.vec, 0u64))


    }
    #[]public borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4 {
        locals:
            %#1: &Element#4,
            default_ref: &Element#4,
            t: &(std=0x1)::option::Option<Element#4>,
            vec_ref: &vector<Element#4>

        loop heads:


        start=0

        label 0:
            (vec_ref: &vector<Element#4>) = &move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#4>(copy vec_ref)) 1 else 2

        
        label 1:
            pop _ = move#last vec_ref;
            (%#1: &Element#4) = move#last default_ref;
            jump 3

        
        label 2:
            pop _ = move#last default_ref;
            (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((move#last vec_ref, 0u64));
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool {
        locals:
            e_ref: &Element#5,
            t: &(std=0x1)::option::Option<Element#5>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::contains<Element#5>((&move#last t.vec, move#last e_ref))


    }
    #[]public destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): () {
        locals:
            t: (std=0x1)::option::Option<Element#6>,
            vec: vector<Element#6>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_none<Element#6>(&t)) 3 else 2

        
        label 2:
            abort EOPTION_IS_SET

        
        label 3:
            Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
            return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)


    }
    #[]public destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7 {
        locals:
            elem: Element#7,
            t: (std=0x1)::option::Option<Element#7>,
            vec: vector<Element#7>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#7>(&t)) 3 else 2

        
        label 2:
            abort EOPTION_NOT_SET

        
        label 3:
            Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
            (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
            pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
            return move#no-copy elem


    }
    #[]public destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop {
        locals:
            %#1: Element#8: drop,
            default: Element#8: drop,
            t: (std=0x1)::option::Option<Element#8: drop>,
            vec: vector<Element#8: drop>

        loop heads:


        start=0

        label 0:
            Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
            jump_if((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec))) 1 else 2

        
        label 1:
            (%#1: Element#8: drop) = move#no-copy default;
            jump 3

        
        label 2:
            (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec);
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#9>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#9>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::pop_back<Element#9>(&mut move#last t.vec)


    }
    #[]public fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): () {
        locals:
            e: Element#10,
            t: &mut (std=0x1)::option::Option<Element#10>,
            vec_ref: &mut vector<Element#10>

        loop heads:


        start=0

        label 0:
            (vec_ref: &mut vector<Element#10>) = &mut move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref))) 3 else 2

        
        label 2:
            pop _ = move#last vec_ref;
            abort EOPTION_IS_SET

        
        label 3:
            pop  = (std=0x1)::vector::push_back<Element#10>((move#last vec_ref, move#no-copy e));
            return /*()*/


    }
    #[]public get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop {
        locals:
            %#1: Element#17: copy+drop,
            default: Element#17: copy+drop,
            t: &(std=0x1)::option::Option<Element#17: copy+drop>,
            vec_ref: &vector<Element#17: copy+drop>

        loop heads:


        start=0

        label 0:
            (vec_ref: &vector<Element#17: copy+drop>) = &move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref)) 1 else 2

        
        label 1:
            pop _ = move#last vec_ref;
            (%#1: Element#17: copy+drop) = move#last default;
            jump 3

        
        label 2:
            (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((move#last vec_ref, 0u64));
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#18>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::is_empty<Element#18>(&move#last t.vec)


    }
    #[]public is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#19>

        loop heads:


        start=0

        label 0:
            return ! (std=0x1)::vector::is_empty<Element#19>(&move#last t.vec)


    }
    #[]public none<Element#22>(): (std=0x1)::option::Option<Element#22> {
        locals:


        loop heads:


        start=0

        label 0:
            return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}


    }
    #[]public some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23> {
        locals:
            e: Element#23

        loop heads:


        start=0

        label 0:
            return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}


    }
    #[]public swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24 {
        locals:
            e: Element#24,
            old_value: Element#24,
            t: &mut (std=0x1)::option::Option<Element#24>,
            vec_ref: &mut vector<Element#24>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#24>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            (vec_ref: &mut vector<Element#24>) = &mut move#last t.vec;
            (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
            pop  = (std=0x1)::vector::push_back<Element#24>((move#last vec_ref, move#no-copy e));
            return move#no-copy old_value


    }
    #[]public swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25> {
        locals:
            %#1: (std=0x1)::option::Option<Element#25>,
            e: Element#25,
            old_value: (std=0x1)::option::Option<Element#25>,
            t: &mut (std=0x1)::option::Option<Element#25>,
            vec_ref: &mut vector<Element#25>

        loop heads:


        start=0

        label 0:
            (vec_ref: &mut vector<Element#25>) = &mut move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref))) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(());
            jump 3

        
        label 2:
            (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref));
            jump 3

        
        label 3:
            (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
            pop  = (std=0x1)::vector::push_back<Element#25>((move#last vec_ref, move#no-copy e));
            return move#no-copy old_value


    }
    #[]public to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26> {
        locals:
            t: (std=0x1)::option::Option<Element#26>,
            vec: vector<Element#26>

        loop heads:


        start=0

        label 0:
            Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
            return move#no-copy vec


    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public address_of(s: &signer): address {
        locals:
            s: &signer

        loop heads:


        start=0

        label 0:
            return *(std=0x1)::signer::borrow_address<>(move#last s)


    }
    #[]public native borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        locals:
            r: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))


    }
    #[]public append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        locals:
            bytes: vector<u8>,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))


    }
    #[]public bytes(s: &(std=0x1)::string::String): &vector<u8> {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return &move#last s.bytes


    }
    #[]public index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        locals:
            r: &(std=0x1)::string::String,
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))


    }
    #[]public insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        locals:
            %#1: bool,
            %#2: &mut (std=0x1)::string::String,
            %#3: u64,
            %#4: u64,
            %#5: &mut (std=0x1)::string::String,
            %#6: u64,
            %#7: u64,
            at: u64,
            bytes: &vector<u8>,
            end: (std=0x1)::string::String,
            front: (std=0x1)::string::String,
            l: u64,
            o: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            (bytes: &vector<u8>) = &copy s.bytes;
            jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

        
        label 1:
            (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
            jump 3

        
        label 2:
            pop _ = move#last bytes;
            (%#1: bool) = false;
            jump 3

        
        label 3:
            jump_if(move#last %#1) 6 else 5

        
        label 5:
            pop _ = move#last s;
            abort EINVALID_INDEX

        
        label 6:
            (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
            ((%#2: &mut (std=0x1)::string::String), (%#4: u64)) = (copy s, copy at);
            (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), 0u64, move#last %#4));
            ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
            (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
            pop  = (std=0x1)::string::append<>((&mut front, move#last o));
            pop  = (std=0x1)::string::append<>((&mut front, move#last end));
            *move#last s = move#last front;
            return /*;()*/


    }
    #[] native internal_check_utf8(v: &vector<u8>): bool;

    #[] native internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public is_empty(s: &(std=0x1)::string::String): bool {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)


    }
    #[]public length(s: &(std=0x1)::string::String): u64 {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<u8>(&move#last s.bytes)


    }
    #[]public sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        locals:
            %#1: bool,
            %#2: bool,
            %#3: bool,
            bytes: &vector<u8>,
            i: u64,
            j: u64,
            l: u64,
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            (bytes: &vector<u8>) = &move#last s.bytes;
            (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
            jump_if(copy j <= move#last l) 1 else 2

        
        label 1:
            (%#1: bool) = copy i <= copy j;
            jump 3

        
        label 2:
            (%#1: bool) = false;
            jump 3

        
        label 3:
            jump_if(move#last %#1) 4 else 5

        
        label 4:
            (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
            jump 6

        
        label 5:
            (%#2: bool) = false;
            jump 6

        
        label 6:
            jump_if(move#last %#2) 7 else 8

        
        label 7:
            (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
            jump 9

        
        label 8:
            (%#3: bool) = false;
            jump 9

        
        label 9:
            jump_if(move#last %#3) 12 else 11

        
        label 11:
            pop _ = move#last bytes;
            abort EINVALID_INDEX

        
        label 12:
            return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}


    }
    #[]public try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        locals:
            %#1: (std=0x1)::option::Option<(std=0x1)::string::String>,
            bytes: vector<u8>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
            jump 3

        
        label 2:
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public utf8(bytes: vector<u8>): (std=0x1)::string::String {
        locals:
            bytes: vector<u8>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 3 else 2

        
        label 2:
            abort EINVALID_UTF8

        
        label 3:
            return String<>{bytes: move#last bytes}


    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        name: (std=0x1)::ascii::String
    }
    #[]public borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        locals:
            self: &(std=0x1)::type_name::TypeName

        loop heads:


        start=0

        label 0:
            return &move#last self.name


    }
    #[]public native get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        locals:
            self: (std=0x1)::type_name::TypeName

        loop heads:


        start=0

        label 0:
            return *&&self.name


    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): () {
        locals:
            lhs: &mut vector<Element#28>,
            other: vector<Element#28>

        loop heads:

            1

        start=0

        label 0:
            pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
            jump 1

        
        label 1:
            jump_if(! (std=0x1)::vector::is_empty<Element#28>(&other)) 2 else 3

        
        label 2:
            pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)));
            jump 1

        
        label 3:
            pop _ = move#last lhs;
            pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
            return /*;()*/


    }
    #[bytecode_instruction]public native borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool {
        locals:
            e: &Element#31,
            i: u64,
            len: u64,
            v: &vector<Element#31>

        loop heads:

            1

        start=0

        label 0:
            (i: u64) = 0u64;
            (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
            jump 1

        
        label 1:
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            jump_if((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e) 3 else 5

        
        label 3:
            pop _ = move#last v;
            pop _ = move#last e;
            return@true

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop _ = move#last v;
            pop _ = move#last e;
            return false


    }
    #[bytecode_instruction]public native destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native empty<Element#33>(): vector<Element#33>;

    #[]public index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64) {
        locals:
            e: &Element#40,
            i: u64,
            len: u64,
            v: &vector<Element#40>

        loop heads:

            1

        start=0

        label 0:
            (i: u64) = 0u64;
            (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
            jump 1

        
        label 1:
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            jump_if((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e) 3 else 5

        
        label 3:
            pop _ = move#last v;
            pop _ = move#last e;
            return@(true, move#last i)

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop _ = move#last v;
            pop _ = move#last e;
            return (false, 0u64)


    }
    #[]public is_empty<Element#41>(v: &vector<Element#41>): bool {
        locals:
            v: &vector<Element#41>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<Element#41>(move#last v) == 0u64


    }
    #[bytecode_instruction]public native length<Element#42>(v: &vector<Element#42>): u64;

    #[bytecode_instruction]public native pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47 {
        locals:
            %#1: u64,
            %#2: &mut vector<Element#47>,
            i: u64,
            len: u64,
            v: &mut vector<Element#47>

        loop heads:

            4

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
            jump_if(copy i >= copy len) 1 else 3

        
        label 1:
            pop _ = move#last v;
            abort EINDEX_OUT_OF_BOUNDS

        
        label 3:
            (len: u64) = move#last len - 1u64;
            jump 4

        
        label 4:
            jump_if(copy i < copy len) 5 else 6

        
        label 5:
            (%#2: &mut vector<Element#47>) = copy v;
            (%#1: u64) = copy i;
            (i: u64) = move#last i + 1u64;
            pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i));
            jump 4

        
        label 6:
            return (std=0x1)::vector::pop_back<Element#47>(move#last v)


    }
    #[]public reverse<Element#48>(v: &mut vector<Element#48>): () {
        locals:
            back_index: u64,
            front_index: u64,
            len: u64,
            v: &mut vector<Element#48>

        loop heads:

            4

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
            jump_if(copy len == 0u64) 1 else 3

        
        label 1:
            pop _ = move#last v;
            return@()

        
        label 3:
            (front_index: u64) = 0u64;
            (back_index: u64) = move#last len - 1u64;
            jump 4

        
        label 4:
            jump_if(copy front_index < copy back_index) 5 else 6

        
        label 5:
            pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
            (front_index: u64) = move#last front_index + 1u64;
            (back_index: u64) = move#last back_index - 1u64;
            jump 4

        
        label 6:
            pop _ = move#last v;
            return /*()*/


    }
    #[]public singleton<Element#49>(e: Element#49): vector<Element#49> {
        locals:
            e: Element#49,
            v: vector<Element#49>

        loop heads:


        start=0

        label 0:
            (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
            pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
            return move#no-copy v


    }
    #[bytecode_instruction]public native swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51 {
        locals:
            i: u64,
            last_idx: u64,
            v: &mut vector<Element#51>

        loop heads:


        start=0

        label 0:
            jump_if(! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v))) 3 else 2

        
        label 2:
            pop _ = move#last v;
            abort EINDEX_OUT_OF_BOUNDS

        
        label 3:
            (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
            pop  = (std=0x1)::vector::swap<Element#51>((copy v, move#last i, move#last last_idx));
            return (std=0x1)::vector::pop_back<Element#51>(move#last v)


    }

}
Before expansion: program = ------ Lib Defs: ------

------ Source Defs: ------
no package
std => 0x1
module std::ascii {
    use std::vector;use std::option:: {
        Self, Option
    };const EINVALID_ASCII_CHARACTER:u64 = 0x10000;copy drop storestruct String {
        bytes: vector<u8>
    }spec String{invariant forall i in 0 .. len(bytes) : is_valid_char(bytes[i])}copy drop storestruct Char {
        byte: u8
    }spec Char{invariant is_valid_char(byte)}public fun char(byte: u8): Char {
        assert!(is_valid_char(byte), EINVALID_ASCII_CHARACTER);
        Char{byte: byte}
    }spec char{aborts_if ! is_valid_char(byte)EINVALID_ASCII_CHARACTER}public fun string(bytes: vector<u8>): String {
        let x = try_string(bytes);
        assert!(option::is_some(&x), EINVALID_ASCII_CHARACTER);
        option::destroy_some(x)
    }spec string{aborts_if exists i in 0 .. len(bytes) : ! is_valid_char(bytes[i])EINVALID_ASCII_CHARACTER}public fun try_string(bytes: vector<u8>): Option<String> {
        let len = vector::length(&bytes);
        let i = 0;
        while ( {
            spec {spec {invariant i <= len;
            invariant forall j in 0 .. i : is_valid_char(bytes[j])}};
            i < len
        }) {
            let possible_byte = *vector::borrow(&bytes, i);
            if (! is_valid_char(possible_byte)) return option::none();
            i = i + 1;

        };
        spec {spec {assert i == len;
        assert forall j in 0 .. len : is_valid_char(bytes[j])}};
        option::some(String{bytes: bytes})
    }public fun all_characters_printable(string: &String): bool {
        let len = vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec {spec {invariant i <= len;
            invariant forall j in 0 .. i : is_printable_char(string.bytes[j])}};
            i < len
        }) {
            let byte = *vector::borrow(&string.bytes, i);
            if (! is_printable_char(byte)) return false;
            i = i + 1;

        };
        spec {spec {assert i == len;
        assert forall j in 0 .. len : is_printable_char(string.bytes[j])}};
        true
    }spec all_characters_printable{ensures result ==> forall j in 0 .. len(string.bytes) : is_printable_char(string.bytes[j])}public fun push_char(string: &mut String, char: Char): () {
        vector::push_back(&mut string.bytes, char.byte);

    }spec push_char{ensures len(string.bytes) == len(old(string.bytes)) + 1}public fun pop_char(string: &mut String): Char {
        Char{byte: vector::pop_back(&mut string.bytes)}
    }spec pop_char{ensures len(string.bytes) == len(old(string.bytes)) - 1}public fun length(string: &String): u64 {
        vector::length(as_bytes(string))
    }public fun as_bytes(string: &String): &vector<u8> {
        &string.bytes
    }public fun into_bytes(string: String): vector<u8> {
        let String{bytes: bytes} = string;
        bytes
    }public fun byte(char: Char): u8 {
        let Char{byte: byte} = char;
        byte
    }public fun is_valid_char(b: u8): bool {
        b <= 0x7F
    }public fun is_printable_char(byte: u8): bool {
        byte >= 0x20 && byte <= 0x7E
    }
}no package
std => 0x1
module std::bcs {
    public native fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;
    spec module {}spec module {native fun serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }
}no package
std => 0x1
module std::bit_vector {
    use std::vector;const EINDEX:u64 = 0x20000;const ELENGTH:u64 = 0x20001;const WORD_SIZE:u64 = 1;const MAX_SIZE:u64 = 1024;copy drop storestruct BitVector {
        length: u64;
        bit_field: vector<bool>
    }public fun new(length: u64): BitVector {
        assert!(length > 0, ELENGTH);
        assert!(length < MAX_SIZE, ELENGTH);
        let counter = 0;
        let bit_field = vector::empty();
        while ( {
            spec {spec {invariant counter <= length;
            invariant len(bit_field) == counter}};
            counter < length
        }) {
            vector::push_back(&mut bit_field, false);
            counter = counter + 1;

        };
        spec {spec {assert counter == length;
        assert len(bit_field) == length}};
        BitVector{length: length, bit_field: bit_field}
    }spec new{include NewAbortsIf;
    ensures result.length == length;
    ensures len(result.bit_field) == length}spec schema NewAbortsIf{locallength: u64;
    aborts_if length <= 0ELENGTH;
    aborts_if length >= MAX_SIZEELENGTH}public fun set(bitvector: &mut BitVector, bit_index: u64): () {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;

    }spec set{include SetAbortsIf;
    ensures bitvector.bit_field[bit_index]}spec schema SetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}public fun unset(bitvector: &mut BitVector, bit_index: u64): () {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;

    }spec unset{include UnsetAbortsIf;
    ensures ! bitvector.bit_field[bit_index]}spec schema UnsetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}public fun shift_left(bitvector: &mut BitVector, amount: u64): () {
        if (amount >= bitvector.length)  {
            let len = vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;

            };

        } else  {
            let i = amount;
            while (i < bitvector.length) {
                if (is_index_set(bitvector, i)) set(bitvector, i - amount) else unset(bitvector, i - amount);
                i = i + 1;

            };
            i = bitvector.length - amount;
            while (i < bitvector.length) {
                unset(bitvector, i);
                i = i + 1;

            };

        }
    }public fun is_index_set(bitvector: &BitVector, bit_index: u64): bool {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        *vector::borrow(&bitvector.bit_field, bit_index)
    }spec is_index_set{include IsIndexSetAbortsIf;
    ensures result == bitvector.bit_field[bit_index]}spec schema IsIndexSetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}spec module {fun spec_is_index_set(bitvector: BitVector, bit_index: u64): bool {
        if (bit_index >= length(bitvector))  {
            false
        } else  {
            bitvector.bit_field[bit_index]
        }
    }}public fun length(bitvector: &BitVector): u64 {
        vector::length(&bitvector.bit_field)
    }public fun longest_set_sequence_starting_at(bitvector: &BitVector, start_index: u64): u64 {
        assert!(start_index < bitvector.length, EINDEX);
        let index = start_index;
        while (index < bitvector.length) {
            if (! is_index_set(bitvector, index)) break;
            index = index + 1;

        };
        index - start_index
    }
}no package
std => 0x1
module std::error {
    const INVALID_ARGUMENT:u64 = 0x1;const OUT_OF_RANGE:u64 = 0x2;const INVALID_STATE:u64 = 0x3;const UNAUTHENTICATED:u64 = 0x4;const PERMISSION_DENIED:u64 = 0x5;const NOT_FOUND:u64 = 0x6;const ABORTED:u64 = 0x7;const ALREADY_EXISTS:u64 = 0x8;const RESOURCE_EXHAUSTED:u64 = 0x9;const CANCELLED:u64 = 0xA;const INTERNAL:u64 = 0xB;const NOT_IMPLEMENTED:u64 = 0xC;const UNAVAILABLE:u64 = 0xD;public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }public fun invalid_argument(r: u64): u64 {
        canonical(INVALID_ARGUMENT, r)
    }public fun out_of_range(r: u64): u64 {
        canonical(OUT_OF_RANGE, r)
    }public fun invalid_state(r: u64): u64 {
        canonical(INVALID_STATE, r)
    }public fun unauthenticated(r: u64): u64 {
        canonical(UNAUTHENTICATED, r)
    }public fun permission_denied(r: u64): u64 {
        canonical(PERMISSION_DENIED, r)
    }public fun not_found(r: u64): u64 {
        canonical(NOT_FOUND, r)
    }public fun aborted(r: u64): u64 {
        canonical(ABORTED, r)
    }public fun already_exists(r: u64): u64 {
        canonical(ALREADY_EXISTS, r)
    }public fun resource_exhausted(r: u64): u64 {
        canonical(RESOURCE_EXHAUSTED, r)
    }public fun internal(r: u64): u64 {
        canonical(INTERNAL, r)
    }public fun not_implemented(r: u64): u64 {
        canonical(NOT_IMPLEMENTED, r)
    }public fun unavailable(r: u64): u64 {
        canonical(UNAVAILABLE, r)
    }
}no package
std => 0x1
module std::fixed_point32 {
    copy drop storestruct FixedPoint32 {
        value: u64
    }const MAX_U64:u128 = 18446744073709551615;const EDENOMINATOR:u64 = 0x10001;const EDIVISION:u64 = 0x20002;const EMULTIPLICATION:u64 = 0x20003;const EDIVISION_BY_ZERO:u64 = 0x10004;const ERATIO_OUT_OF_RANGE:u64 = 0x20005;public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64 {
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert!(product <= MAX_U64, EMULTIPLICATION);
        (product as u64)
    }spec multiply_u64{pragma opaque;
    include MultiplyAbortsIf;
    ensures result == spec_multiply_u64(val, multiplier)}spec schema MultiplyAbortsIf{localval: num;
    localmultiplier: FixedPoint32;
    aborts_if spec_multiply_u64(val, multiplier) > MAX_U64EMULTIPLICATION}spec module {fun spec_multiply_u64(val: num, multiplier: FixedPoint32): num {
        val * multiplier.value >> 32
    }}public fun divide_u64(val: u64, divisor: FixedPoint32): u64 {
        assert!(divisor.value != 0, EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / (divisor.value as u128);
        assert!(quotient <= MAX_U64, EDIVISION);
        (quotient as u64)
    }spec divide_u64{pragma opaque;
    include DivideAbortsIf;
    ensures result == spec_divide_u64(val, divisor)}spec schema DivideAbortsIf{localval: num;
    localdivisor: FixedPoint32;
    aborts_if divisor.value == 0EDIVISION_BY_ZERO;
    aborts_if spec_divide_u64(val, divisor) > MAX_U64EDIVISION}spec module {fun spec_divide_u64(val: num, divisor: FixedPoint32): num {
        val << 32 / divisor.value
    }}public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert!(scaled_denominator != 0, EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);
        assert!(quotient <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32{value: (quotient as u64)}
    }spec create_from_rational{pragma verify = false;
    pragma opaque;
    include CreateFromRationalAbortsIf;
    ensures result == spec_create_from_rational(numerator, denominator)}spec schema CreateFromRationalAbortsIf{localnumerator: u64;
    localdenominator: u64;
    let scaled_numerator = (numerator as u128) << 64;
    let scaled_denominator = (denominator as u128) << 32;
    let quotient = scaled_numerator / scaled_denominator;
    aborts_if scaled_denominator == 0EDENOMINATOR;
    aborts_if quotient == 0 && scaled_numerator != 0ERATIO_OUT_OF_RANGE;
    aborts_if quotient > MAX_U64ERATIO_OUT_OF_RANGE}spec module {fun spec_create_from_rational(numerator: num, denominator: num): FixedPoint32 {
        FixedPoint32{value: numerator << 64 / denominator << 32}
    }}public fun create_from_raw_value(value: u64): FixedPoint32 {
        FixedPoint32{value: value}
    }spec create_from_raw_value{pragma opaque;
    aborts_if false;
    ensures result.value == value}public fun get_raw_value(num: FixedPoint32): u64 {
        num.value
    }public fun is_zero(num: FixedPoint32): bool {
        num.value == 0
    }public fun min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }spec min{pragma opaque;
    aborts_if false;
    ensures result == spec_min(num1, num2)}spec module {fun spec_min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }}public fun max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }spec max{pragma opaque;
    aborts_if false;
    ensures result == spec_max(num1, num2)}spec module {fun spec_max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }}public fun create_from_u64(val: u64): FixedPoint32 {
        let value = (val as u128) << 32;
        assert!(value <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32{value: (value as u64)}
    }spec create_from_u64{pragma opaque;
    include CreateFromU64AbortsIf;
    ensures result == spec_create_from_u64(val)}spec schema CreateFromU64AbortsIf{localval: num;
    let scaled_value = (val as u128) << 32;
    aborts_if scaled_value > MAX_U64}spec module {fun spec_create_from_u64(val: num): FixedPoint32 {
        FixedPoint32{value: val << 32}
    }}public fun floor(num: FixedPoint32): u64 {
        num.value >> 32
    }spec floor{pragma opaque;
    aborts_if false;
    ensures result == spec_floor(num)}spec module {fun spec_floor(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional >> 32
        }
    }}public fun ceil(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        if (num.value == floored_num)  {
            return floored_num >> 32
        };
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }spec ceil{pragma verify = false;
    pragma opaque;
    aborts_if false;
    ensures result == spec_ceil(num)}spec module {fun spec_ceil(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let one = 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}public fun round(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if (num.value < boundary)  {
            floored_num >> 32
        } else  {
            ceil(num)
        }
    }spec round{pragma opaque;
    pragma timeout = 120;
    aborts_if false;
    ensures result == spec_round(num)}spec module {fun spec_round(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let boundary = 1 << 32 / 2;
        let one = 1 << 32;
        if (fractional < boundary)  {
            val.value - fractional >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}spec module {}spec module {pragma aborts_if_is_strict}
}no package
std => 0x1
module std::hash {
    public native fun sha2_256(data: vector<u8>): vector<u8>;
    public native fun sha3_256(data: vector<u8>): vector<u8>;

}no package
std => 0x1
module std::option {
    use std::vector;copy drop storestruct Option<Element> {
        vec: vector<Element>
    }spec Option{invariant len(vec) <= 1}const EOPTION_IS_SET:u64 = 0x40000;const EOPTION_NOT_SET:u64 = 0x40001;public fun none<Element>(): Option<Element> {
        Option{vec: vector::empty()}
    }spec none{pragma opaque;
    aborts_if false;
    ensures result == spec_none<Element>()}spec module {fun spec_none<Element>(): Option<Element> {
        Option{vec: vec()}
    }}public fun some<Element>(e: Element): Option<Element> {
        Option{vec: vector::singleton(e)}
    }spec some{pragma opaque;
    aborts_if false;
    ensures result == spec_some(e)}spec module {fun spec_some<Element>(e: Element): Option<Element> {
        Option{vec: vec(e)}
    }}public fun is_none<Element>(t: &Option<Element>): bool {
        vector::is_empty(&t.vec)
    }spec is_none{pragma opaque;
    aborts_if false;
    ensures result == is_none(t)}public fun is_some<Element>(t: &Option<Element>): bool {
        ! vector::is_empty(&t.vec)
    }spec is_some{pragma opaque;
    aborts_if false;
    ensures result == is_some(t)}public fun contains<Element>(t: &Option<Element>, e_ref: &Element): bool {
        vector::contains(&t.vec, e_ref)
    }spec contains{pragma opaque;
    aborts_if false;
    ensures result == spec_contains(t, e_ref)}spec module {fun spec_contains<Element>(t: Option<Element>, e: Element): bool {
        is_some(t) && borrow(t) == e
    }}public fun borrow<Element>(t: &Option<Element>): &Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow(&t.vec, 0)
    }spec borrow{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t)}public fun borrow_with_default<Element>(t: &Option<Element>, default_ref: &Element): &Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default_ref else vector::borrow(vec_ref, 0)
    }spec borrow_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default_ref}public fun get_with_default<Element: copy+drop>(t: &Option<Element>, default: Element): Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default else *vector::borrow(vec_ref, 0)
    }spec get_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default}public fun fill<Element>(t: &mut Option<Element>, e: Element): () {
        let vec_ref = &mut t.vec;
        if (vector::is_empty(vec_ref)) vector::push_back(vec_ref, e) else abort EOPTION_IS_SET
    }spec fill{pragma opaque;
    aborts_if is_some(t)EOPTION_IS_SET;
    ensures is_some(t);
    ensures borrow(t) == e}public fun extract<Element>(t: &mut Option<Element>): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::pop_back(&mut t.vec)
    }spec extract{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(old(t));
    ensures is_none(t)}public fun borrow_mut<Element>(t: &mut Option<Element>): &mut Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow_mut(&mut t.vec, 0)
    }spec borrow_mut{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t);
    ensures t == old(t)}public fun swap<Element>(t: &mut Option<Element>, e: Element): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = vector::pop_back(vec_ref);
        vector::push_back(vec_ref, e);
        old_value
    }spec swap{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(old(t));
    ensures is_some(t);
    ensures borrow(t) == e}public fun swap_or_fill<Element>(t: &mut Option<Element>, e: Element): Option<Element> {
        let vec_ref = &mut t.vec;
        let old_value = if (vector::is_empty(vec_ref)) none() else some(vector::pop_back(vec_ref));
        vector::push_back(vec_ref, e);
        old_value
    }spec swap_or_fill{pragma opaque;
    ensures result == old(t);
    ensures borrow(t) == e}public fun destroy_with_default<Element: drop>(t: Option<Element>, default: Element): Element {
        let Option{vec: vec} = t;
        if (vector::is_empty(&mut vec)) default else vector::pop_back(&mut vec)
    }spec destroy_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default}public fun destroy_some<Element>(t: Option<Element>): Element {
        assert!(is_some(&t), EOPTION_NOT_SET);
        let Option{vec: vec} = t;
        let elem = vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
        elem
    }spec destroy_some{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t)}public fun destroy_none<Element>(t: Option<Element>): () {
        assert!(is_none(&t), EOPTION_IS_SET);
        let Option{vec: vec} = t;
        vector::destroy_empty(vec)
    }spec destroy_none{pragma opaque;
    aborts_if is_some(t)EOPTION_IS_SET}public fun to_vec<Element>(t: Option<Element>): vector<Element> {
        let Option{vec: vec} = t;
        vec
    }spec to_vec{pragma opaque;
    aborts_if false;
    ensures result == t.vec}public inline fun for_each<Element>(o: Option<Element>, f: (Element):()): () {
        if (is_some(&o))  {
            f(destroy_some(o))
        } else  {
            destroy_none(o)
        }
    }public inline fun for_each_ref<Element>(o: &Option<Element>, f: (&Element):()): () {
        if (is_some(o))  {
            f(borrow(o))
        }
    }public inline fun for_each_mut<Element>(o: &mut Option<Element>, f: (&mut Element):()): () {
        if (is_some(o))  {
            f(borrow_mut(o))
        }
    }public inline fun fold<Accumulator, Element>(o: Option<Element>, init: Accumulator, f: (Accumulator, Element):Accumulator): Accumulator {
        if (is_some(&o))  {
            f(init, destroy_some(o))
        } else  {
            destroy_none(o);
            init
        }
    }public inline fun map<Element, OtherElement>(o: Option<Element>, f: (Element):OtherElement): Option<OtherElement> {
        if (is_some(&o))  {
            some(f(destroy_some(o)))
        } else  {
            destroy_none(o);
            none()
        }
    }public inline fun filter<Element: drop>(o: Option<Element>, f: (&Element):bool): Option<Element> {
        if (is_some(&o) && f(borrow(&o)))  {
            o
        } else  {
            none()
        }
    }spec module {}spec module {pragma aborts_if_is_strict}spec schema AbortsIfNone<Element>{localt: Option<Element>;
    aborts_if is_none(t)EOPTION_NOT_SET}
}no package
std => 0x1
module std::signer {
    public native fun borrow_address(s: &signer): &address;
    public fun address_of(s: &signer): address {
        *borrow_address(s)
    }spec module {native fun is_txn_signer(s: signer): bool;
    }spec module {native fun is_txn_signer_addr(a: address): bool;
    }
}no package
std => 0x1
module std::string {
    use std::vector;use std::option:: {
        Self, Option
    };const EINVALID_UTF8:u64 = 1;const EINVALID_INDEX:u64 = 2;copy drop storestruct String {
        bytes: vector<u8>
    }public fun utf8(bytes: vector<u8>): String {
        assert!(internal_check_utf8(&bytes), EINVALID_UTF8);
        String{bytes: bytes}
    }public fun try_utf8(bytes: vector<u8>): Option<String> {
        if (internal_check_utf8(&bytes))  {
            option::some(String{bytes: bytes})
        } else  {
            option::none()
        }
    }public fun bytes(s: &String): &vector<u8> {
        &s.bytes
    }public fun is_empty(s: &String): bool {
        vector::is_empty(&s.bytes)
    }public fun length(s: &String): u64 {
        vector::length(&s.bytes)
    }public fun append(s: &mut String, r: String): () {
        vector::append(&mut s.bytes, r.bytes)
    }public fun append_utf8(s: &mut String, bytes: vector<u8>): () {
        append(s, utf8(bytes))
    }public fun insert(s: &mut String, at: u64, o: String): () {
        let bytes = &s.bytes;
        assert!(at <= vector::length(bytes) && internal_is_char_boundary(bytes, at), EINVALID_INDEX);
        let l = length(s);
        let front = sub_string(s, 0, at);
        let end = sub_string(s, at, l);
        append(&mut front, o);
        append(&mut front, end);
        *s = front;

    }public fun sub_string(s: &String, i: u64, j: u64): String {
        let bytes = &s.bytes;
        let l = vector::length(bytes);
        assert!(j <= l && i <= j && internal_is_char_boundary(bytes, i) && internal_is_char_boundary(bytes, j), EINVALID_INDEX);
        String{bytes: internal_sub_string(bytes, i, j)}
    }public fun index_of(s: &String, r: &String): u64 {
        internal_index_of(&s.bytes, &r.bytes)
    } native fun internal_check_utf8(v: &vector<u8>): bool;
     native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;
     native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;
     native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

}no package
std => 0x1
module std::type_name {
    use std::ascii:: {
        String
    };copy drop storestruct TypeName {
        name: String
    }public native fun get<T>(): TypeName;
    public fun borrow_string(self: &TypeName): &String {
        &self.name
    }public fun into_string(self: TypeName): String {
        self.name
    }
}no package
std => 0x1
module std::vector {
    const EINDEX_OUT_OF_BOUNDS:u64 = 0x20000;#[bytecode_instruction]public native fun empty<Element>(): vector<Element>;
    #[bytecode_instruction]public native fun length<Element>(v: &vector<Element>): u64;
    #[bytecode_instruction]public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;
    #[bytecode_instruction]public native fun push_back<Element>(v: &mut vector<Element>, e: Element): ();
    #[bytecode_instruction]public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;
    #[bytecode_instruction]public native fun pop_back<Element>(v: &mut vector<Element>): Element;
    #[bytecode_instruction]public native fun destroy_empty<Element>(v: vector<Element>): ();
    #[bytecode_instruction]public native fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64): ();
    public fun singleton<Element>(e: Element): vector<Element> {
        let v = empty();
        push_back(&mut v, e);
        v
    }spec singleton{aborts_if false;
    ensures result == vec(e)}public fun reverse<Element>(v: &mut vector<Element>): () {
        let len = length(v);
        if (len == 0) return ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;

        }
    }spec reverse{pragma intrinsic = true}public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>): () {
        reverse(&mut other);
        while (! is_empty(&other))push_back(lhs, pop_back(&mut other));
        destroy_empty(other);

    }spec append{pragma intrinsic = true}spec is_empty{pragma intrinsic = true}public fun is_empty<Element>(v: &vector<Element>): bool {
        length(v) == 0
    }public fun contains<Element>(v: &vector<Element>, e: &Element): bool {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return true;
            i = i + 1;

        };
        false
    }spec contains{pragma intrinsic = true}public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return (true, i);
            i = i + 1;

        };
        (false, 0)
    }spec index_of{pragma intrinsic = true}public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {
        let len = length(v);
        if (i >= len) abort EINDEX_OUT_OF_BOUNDS;
        len = len - 1;
        while (i < len)swap(v, i,  {
            i = i + 1;
            i
        });
        pop_back(v)
    }spec remove{pragma intrinsic = true}public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {
        assert!(! is_empty(v), EINDEX_OUT_OF_BOUNDS);
        let last_idx = length(v) - 1;
        swap(v, i, last_idx);
        pop_back(v)
    }spec swap_remove{pragma intrinsic = true}public inline fun for_each<Element>(v: vector<Element>, f: (Element):()): () {
        reverse(&mut v);
        while (! is_empty(&v)) {
            let e = pop_back(&mut v);
            f(e);

        };

    }public inline fun for_each_ref<Element>(v: &vector<Element>, f: (&Element):()): () {
        let i = 0;
        while (i < length(v)) {
            f(borrow(v, i));
            i = i + 1
        }
    }public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: (&mut Element):()): () {
        let i = 0;
        while (i < length(v)) {
            f(borrow_mut(v, i));
            i = i + 1
        }
    }public inline fun fold<Accumulator, Element>(v: vector<Element>, init: Accumulator, f: (Accumulator, Element):Accumulator): Accumulator {
        let accu = init;
        for_each(v, |elem|accu = f(accu, elem));
        accu
    }public inline fun map<Element, NewElement>(v: vector<Element>, f: (Element):NewElement): vector<NewElement> {
        let result = vector<NewElement>[];
        for_each(v, |elem|push_back(&mut result, f(elem)));
        result
    }public inline fun filter<Element: drop>(v: vector<Element>, p: (&Element):bool): vector<Element> {
        let result = vector<Element>[];
        for_each(v, |elem| {
            if (p(&elem)) push_back(&mut result, elem);

        });
        result
    }spec module {}spec module {fun eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
        len(v1) == len(v2) + 1 && v1[len(v1) - 1] == e && v1[0 .. len(v1) - 1] == v2[0 .. len(v2)]
    };
    fun eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
        len(v) == len(v1) + len(v2) && v[0 .. len(v1)] == v1 && v[len(v1) .. len(v)] == v2
    };
    fun eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1 == v2[1 .. len(v2)]
    };
    fun eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1[0 .. i] == v2[0 .. i] && v1[i .. len(v1)] == v2[i + 1 .. len(v2)]
    }}
}
After expansion: program = module (std=0x1)::ascii {
    #[]source module
    dependency order #2
    neighbor#dependency (std=0x1)::option;
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len = (std=0x1)::vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec #0 uses [i, len, string];
            i < len
        }) {
            let byte = *(std=0x1)::vector::borrow(&string.bytes, i);
            if (! (std=0x1)::ascii::is_printable_char(byte)) return false else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [i, len, string];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char{0#byte: byte} = char;
        byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert!((std=0x1)::ascii::is_valid_char(byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::ascii::Char{0#byte: byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String{0#bytes: bytes} = string;
        bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        byte >= 32 && byte <= 126
    }
    #[]public fun is_valid_char(b: u8): bool {
        b <= 127
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length((std=0x1)::ascii::as_bytes(string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char{0#byte: (std=0x1)::vector::pop_back(&mut string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back(&mut string.bytes, char.byte);
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x = (std=0x1)::ascii::try_string(bytes);
        assert!((std=0x1)::option::is_some(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::option::destroy_some(x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len = (std=0x1)::vector::length(&bytes);
        let i = 0;
        while ( {
            spec #0 uses [bytes, i, len];
            i < len
        }) {
            let possible_byte = *(std=0x1)::vector::borrow(&bytes, i);
            if (! (std=0x1)::ascii::is_valid_char(possible_byte)) return (std=0x1)::option::none() else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [bytes, i, len];
        (std=0x1)::option::some((std=0x1)::ascii::String{0#bytes: bytes})
    }
     spec String{invariant forall i in 0 .. len(bytes) : (std=0x1)::ascii::is_valid_char(bytes[i])}
     spec Char{invariant (std=0x1)::ascii::is_valid_char(byte)}
     spec char{aborts_if ! (std=0x1)::ascii::is_valid_char(byte)(std=0x1)::ascii::EINVALID_ASCII_CHARACTER}
     spec string{aborts_if exists i in 0 .. len(bytes) : ! (std=0x1)::ascii::is_valid_char(bytes[i])(std=0x1)::ascii::EINVALID_ASCII_CHARACTER}
     spec all_characters_printable{ensures result ==> forall j in 0 .. len(string.bytes) : (std=0x1)::ascii::is_printable_char(string.bytes[j])}
     spec push_char{ensures len(string.bytes) == len(old(string.bytes)) + 1}
     spec pop_char{ensures len(string.bytes) == len(old(string.bytes)) - 1}

}
module (std=0x1)::bcs {
    #[]source module
    dependency order #0
    #[]public native fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;

     spec module {}
     spec module {native define serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }

}
module (std=0x1)::bit_vector {
    #[]source module
    dependency order #3
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        *(std=0x1)::vector::borrow(&bitvector.bit_field, bit_index)
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length(&bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert!(start_index < bitvector.length, (std=0x1)::bit_vector::EINDEX);
        let index = start_index;
        while (index < bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set(bitvector, index)) break else ();
            index = index + 1;
            /*()*/
        };
        index - start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert!(length > 0, (std=0x1)::bit_vector::ELENGTH);
        assert!(length < (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH);
        let counter = 0;
        let bit_field = (std=0x1)::vector::empty();
        while ( {
            spec #0 uses [bit_field, counter, length] applies [len];
            counter < length
        }) {
            (std=0x1)::vector::push_back(&mut bit_field, false);
            counter = counter + 1;
            /*()*/
        };
        spec #1 uses [bit_field, counter, length] applies [len];
        (std=0x1)::bit_vector::BitVector{1#bit_field: bit_field, 0#length: length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (amount >= bitvector.length)  {
            let len = (std=0x1)::vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;
                /*()*/
            };
            /*()*/
        } else  {
            let i = amount;
            while (i < bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set(bitvector, i)) (std=0x1)::bit_vector::set(bitvector, i - amount) else (std=0x1)::bit_vector::unset(bitvector, i - amount);
                i = i + 1;
                /*()*/
            };
            i = bitvector.length - amount;
            while (i < bitvector.length) {
                (std=0x1)::bit_vector::unset(bitvector, i);
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;
        /*()*/
    }
     spec new{include (std=0x1)::bit_vector::NewAbortsIf;
    ensures result.length == length;
    ensures len(result.bit_field) == length}
     spec schema NewAbortsIf{locallength: u64;
    aborts_if length <= 0(std=0x1)::bit_vector::ELENGTH;
    aborts_if length >= (std=0x1)::bit_vector::MAX_SIZE(std=0x1)::bit_vector::ELENGTH}
     spec set{include (std=0x1)::bit_vector::SetAbortsIf;
    ensures bitvector.bit_field[bit_index]}
     spec schema SetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec unset{include (std=0x1)::bit_vector::UnsetAbortsIf;
    ensures ! bitvector.bit_field[bit_index]}
     spec schema UnsetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec is_index_set{include (std=0x1)::bit_vector::IsIndexSetAbortsIf;
    ensures result == bitvector.bit_field[bit_index]}
     spec schema IsIndexSetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec module {define spec_is_index_set(bitvector: (std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        if (bit_index >= (std=0x1)::bit_vector::length(bitvector))  {
            false
        } else  {
            bitvector.bit_field[bit_index]
        }
    }}

}
module (std=0x1)::error {
    #[]source module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ABORTED, r)
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ALREADY_EXISTS, r)
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INTERNAL, r)
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_ARGUMENT, r)
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_STATE, r)
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_FOUND, r)
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_IMPLEMENTED, r)
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::OUT_OF_RANGE, r)
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::PERMISSION_DENIED, r)
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::RESOURCE_EXHAUSTED, r)
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAUTHENTICATED, r)
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAVAILABLE, r)
    }

}
module (std=0x1)::fixed_point32 {
    #[]source module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        if (num.value == floored_num)  {
            return floored_num >> 32
        } else ();
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert!(scaled_denominator != 0, (std=0x1)::fixed_point32::EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert!(quotient != 0 || numerator == 0, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        assert!(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value = (val as u128) << 32;
        assert!(value <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert!(divisor.value != 0, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / (divisor.value as u128);
        assert!(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION);
        (quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        num.value >> 32
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        num.value == 0
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert!(product <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION);
        (product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if (num.value < boundary)  {
            floored_num >> 32
        } else  {
            (std=0x1)::fixed_point32::ceil(num)
        }
    }
     spec multiply_u64{pragma opaque;
    include (std=0x1)::fixed_point32::MultiplyAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_multiply_u64(val, multiplier)}
     spec schema MultiplyAbortsIf{localval: num;
    localmultiplier: (std=0x1)::fixed_point32::FixedPoint32;
    aborts_if (std=0x1)::fixed_point32::spec_multiply_u64(val, multiplier) > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::EMULTIPLICATION}
     spec module {define spec_multiply_u64(val: num, multiplier: (std=0x1)::fixed_point32::FixedPoint32): num {
        val * multiplier.value >> 32
    }}
     spec divide_u64{pragma opaque;
    include (std=0x1)::fixed_point32::DivideAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_divide_u64(val, divisor)}
     spec schema DivideAbortsIf{localval: num;
    localdivisor: (std=0x1)::fixed_point32::FixedPoint32;
    aborts_if divisor.value == 0(std=0x1)::fixed_point32::EDIVISION_BY_ZERO;
    aborts_if (std=0x1)::fixed_point32::spec_divide_u64(val, divisor) > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::EDIVISION}
     spec module {define spec_divide_u64(val: num, divisor: (std=0x1)::fixed_point32::FixedPoint32): num {
        val << 32 / divisor.value
    }}
     spec create_from_rational{pragma verify = false;
    pragma opaque;
    include (std=0x1)::fixed_point32::CreateFromRationalAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_create_from_rational(numerator, denominator)}
     spec schema CreateFromRationalAbortsIf{localnumerator: u64;
    localdenominator: u64;
    let scaled_numerator = (numerator as u128) << 64;
    let scaled_denominator = (denominator as u128) << 32;
    let quotient = scaled_numerator / scaled_denominator;
    aborts_if scaled_denominator == 0(std=0x1)::fixed_point32::EDENOMINATOR;
    aborts_if quotient == 0 && scaled_numerator != 0(std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE;
    aborts_if quotient > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE}
     spec module {define spec_create_from_rational(numerator: num, denominator: num): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: numerator << 64 / denominator << 32}
    }}
     spec create_from_raw_value{pragma opaque;
    aborts_if false;
    ensures result.value == value}
     spec min{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_min(num1, num2)}
     spec module {define spec_min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }}
     spec max{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_max(num1, num2)}
     spec module {define spec_max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }}
     spec create_from_u64{pragma opaque;
    include (std=0x1)::fixed_point32::CreateFromU64AbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_create_from_u64(val)}
     spec schema CreateFromU64AbortsIf{localval: num;
    let scaled_value = (val as u128) << 32;
    aborts_if scaled_value > (std=0x1)::fixed_point32::MAX_U64}
     spec module {define spec_create_from_u64(val: num): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: val << 32}
    }}
     spec floor{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_floor(num)}
     spec module {define spec_floor(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional >> 32
        }
    }}
     spec ceil{pragma verify = false;
    pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_ceil(num)}
     spec module {define spec_ceil(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let one = 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}
     spec round{pragma opaque;
    pragma timeout = 120;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_round(num)}
     spec module {define spec_round(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let boundary = 1 << 32 / 2;
        let one = 1 << 32;
        if (fractional < boundary)  {
            val.value - fractional >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}
     spec module {}
     spec module {pragma aborts_if_is_strict}

}
module (std=0x1)::hash {
    #[]source module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]source module
    dependency order #1
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct Option<Element> has copy drop store {
        0#vec: vector<Element>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public fun borrow<Element>(t: &(std=0x1)::option::Option<Element>): &Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow(&t.vec, 0)
    }
    #[]public fun borrow_mut<Element>(t: &mut (std=0x1)::option::Option<Element>): &mut Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow_mut(&mut t.vec, 0)
    }
    #[]public fun borrow_with_default<Element>(t: &(std=0x1)::option::Option<Element>, default_ref: &Element): &Element {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default_ref else (std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun contains<Element>(t: &(std=0x1)::option::Option<Element>, e_ref: &Element): bool {
        (std=0x1)::vector::contains(&t.vec, e_ref)
    }
    #[]public fun destroy_none<Element>(t: (std=0x1)::option::Option<Element>): () {
        assert!((std=0x1)::option::is_none(&t), (std=0x1)::option::EOPTION_IS_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        (std=0x1)::vector::destroy_empty(vec)
    }
    #[]public fun destroy_some<Element>(t: (std=0x1)::option::Option<Element>): Element {
        assert!((std=0x1)::option::is_some(&t), (std=0x1)::option::EOPTION_NOT_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        let elem = (std=0x1)::vector::pop_back(&mut vec);
        (std=0x1)::vector::destroy_empty(vec);
        elem
    }
    #[]public fun destroy_with_default<Element: drop>(t: (std=0x1)::option::Option<Element>, default: Element): Element {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        if ((std=0x1)::vector::is_empty(&mut vec)) default else (std=0x1)::vector::pop_back(&mut vec)
    }
    #[]public fun extract<Element>(t: &mut (std=0x1)::option::Option<Element>): Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::pop_back(&mut t.vec)
    }
    #[]public fun fill<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): () {
        let vec_ref = &mut t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::vector::push_back(vec_ref, e) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public inline fun filter<Element: drop>(o: (std=0x1)::option::Option<Element>, f: |&Element|bool): (std=0x1)::option::Option<Element> {
        if ((std=0x1)::option::is_some(&o) && f((std=0x1)::option::borrow(&o)))  {
            o
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public inline fun fold<Accumulator, Element>(o: (std=0x1)::option::Option<Element>, init: Accumulator, f: |Accumulator, Element|Accumulator): Accumulator {
        if ((std=0x1)::option::is_some(&o))  {
            f(init, (std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o);
            init
        }
    }
    #[]public inline fun for_each<Element>(o: (std=0x1)::option::Option<Element>, f: |Element|()): () {
        if ((std=0x1)::option::is_some(&o))  {
            f((std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o)
        }
    }
    #[]public inline fun for_each_mut<Element>(o: &mut (std=0x1)::option::Option<Element>, f: |&mut Element|()): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow_mut(o))
        } else ()
    }
    #[]public inline fun for_each_ref<Element>(o: &(std=0x1)::option::Option<Element>, f: |&Element|()): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow(o))
        } else ()
    }
    #[]public fun get_with_default<Element: copy+drop>(t: &(std=0x1)::option::Option<Element>, default: Element): Element {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default else *(std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun is_none<Element>(t: &(std=0x1)::option::Option<Element>): bool {
        (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public fun is_some<Element>(t: &(std=0x1)::option::Option<Element>): bool {
        ! (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public inline fun map<Element, OtherElement>(o: (std=0x1)::option::Option<Element>, f: |Element|OtherElement): (std=0x1)::option::Option<OtherElement> {
        if ((std=0x1)::option::is_some(&o))  {
            (std=0x1)::option::some(f((std=0x1)::option::destroy_some(o)))
        } else  {
            (std=0x1)::option::destroy_none(o);
            (std=0x1)::option::none()
        }
    }
    #[]public fun none<Element>(): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::empty()}
    }
    #[]public fun some<Element>(e: Element): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::singleton(e)}
    }
    #[]public fun swap<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = (std=0x1)::vector::pop_back(vec_ref);
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun swap_or_fill<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): (std=0x1)::option::Option<Element> {
        let vec_ref = &mut t.vec;
        let old_value = if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::option::none() else (std=0x1)::option::some((std=0x1)::vector::pop_back(vec_ref));
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun to_vec<Element>(t: (std=0x1)::option::Option<Element>): vector<Element> {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        vec
    }
     spec Option{invariant len(vec) <= 1}
     spec none{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_none<Element>()}
     spec module {define spec_none<Element>(): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: vec()}
    }}
     spec some{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_some(e)}
     spec module {define spec_some<Element>(e: Element): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: vec(e)}
    }}
     spec is_none{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::is_none(t)}
     spec is_some{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::is_some(t)}
     spec contains{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_contains(t, e_ref)}
     spec module {define spec_contains<Element>(t: (std=0x1)::option::Option<Element>, e: Element): bool {
        (std=0x1)::option::is_some(t) && (std=0x1)::option::borrow(t) == e
    }}
     spec borrow{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t)}
     spec borrow_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default_ref}
     spec get_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default}
     spec fill{pragma opaque;
    aborts_if (std=0x1)::option::is_some(t)(std=0x1)::option::EOPTION_IS_SET;
    ensures (std=0x1)::option::is_some(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec extract{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(old(t));
    ensures (std=0x1)::option::is_none(t)}
     spec borrow_mut{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t);
    ensures t == old(t)}
     spec swap{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(old(t));
    ensures (std=0x1)::option::is_some(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec swap_or_fill{pragma opaque;
    ensures result == old(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec destroy_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default}
     spec destroy_some{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t)}
     spec destroy_none{pragma opaque;
    aborts_if (std=0x1)::option::is_some(t)(std=0x1)::option::EOPTION_IS_SET}
     spec to_vec{pragma opaque;
    aborts_if false;
    ensures result == t.vec}
     spec module {}
     spec module {pragma aborts_if_is_strict}
     spec schema AbortsIfNone<Element>{localt: (std=0x1)::option::Option<Element>;
    aborts_if (std=0x1)::option::is_none(t)(std=0x1)::option::EOPTION_NOT_SET}

}
module (std=0x1)::signer {
    #[]source module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address(s)
    }
    #[]public native fun borrow_address(s: &signer): &address;

     spec module {native define is_txn_signer(s: signer): bool;
    }
     spec module {native define is_txn_signer_addr(a: address): bool;
    }

}
module (std=0x1)::string {
    #[]source module
    dependency order #4
    neighbor#dependency (std=0x1)::option;
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append(&mut s.bytes, r.bytes)
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append(s, (std=0x1)::string::utf8(bytes))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of(&s.bytes, &r.bytes)
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes = &s.bytes;
        assert!(at <= (std=0x1)::vector::length(bytes) && (std=0x1)::string::internal_is_char_boundary(bytes, at), (std=0x1)::string::EINVALID_INDEX);
        let l = (std=0x1)::string::length(s);
        let front = (std=0x1)::string::sub_string(s, 0, at);
        let end = (std=0x1)::string::sub_string(s, at, l);
        (std=0x1)::string::append(&mut front, o);
        (std=0x1)::string::append(&mut front, end);
        *s = front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty(&s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length(&s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes = &s.bytes;
        let l = (std=0x1)::vector::length(bytes);
        assert!(j <= l && i <= j && (std=0x1)::string::internal_is_char_boundary(bytes, i) && (std=0x1)::string::internal_is_char_boundary(bytes, j), (std=0x1)::string::EINVALID_INDEX);
        (std=0x1)::string::String{0#bytes: (std=0x1)::string::internal_sub_string(bytes, i, j)}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8(&bytes))  {
            (std=0x1)::option::some((std=0x1)::string::String{0#bytes: bytes})
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert!((std=0x1)::string::internal_check_utf8(&bytes), (std=0x1)::string::EINVALID_UTF8);
        (std=0x1)::string::String{0#bytes: bytes}
    }

}
module (std=0x1)::type_name {
    #[]source module
    dependency order #5
    neighbor#dependency (std=0x1)::ascii;
    uses address (std=0x1);
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &self.name
    }
    #[]public native fun get<T>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        self.name
    }

}
module (std=0x1)::vector {
    #[]source module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>): () {
        (std=0x1)::vector::reverse(&mut other);
        while (! (std=0x1)::vector::is_empty(&other))(std=0x1)::vector::push_back(lhs, (std=0x1)::vector::pop_back(&mut other));
        (std=0x1)::vector::destroy_empty(other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;

    #[bytecode_instruction]public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;

    #[]public fun contains<Element>(v: &vector<Element>, e: &Element): bool {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return true else ();
            i = i + 1;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element>(v: vector<Element>): ();

    #[bytecode_instruction]public native fun empty<Element>(): vector<Element>;

    #[]public inline fun filter<Element: drop>(v: vector<Element>, p: |&Element|bool): vector<Element> {
        let result = vector<Element>[];
        (std=0x1)::vector::for_each(v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back(&mut result, elem) else ();
            /*()*/
        });
        result
    }
    #[]public inline fun fold<Accumulator, Element>(v: vector<Element>, init: Accumulator, f: |Accumulator, Element|Accumulator): Accumulator {
        let accu = init;
        (std=0x1)::vector::for_each(v, |elem|accu = f(accu, elem));
        accu
    }
    #[]public inline fun for_each<Element>(v: vector<Element>, f: |Element|()): () {
        (std=0x1)::vector::reverse(&mut v);
        while (! (std=0x1)::vector::is_empty(&v)) {
            let e = (std=0x1)::vector::pop_back(&mut v);
            f(e);
            /*()*/
        };
        /*()*/
    }
    #[]public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: |&mut Element|()): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow_mut(v, i));
            i = i + 1
        }
    }
    #[]public inline fun for_each_ref<Element>(v: &vector<Element>, f: |&Element|()): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow(v, i));
            i = i + 1
        }
    }
    #[]public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return (true, i) else ();
            i = i + 1;
            /*()*/
        };
        (false, 0)
    }
    #[]public fun is_empty<Element>(v: &vector<Element>): bool {
        (std=0x1)::vector::length(v) == 0
    }
    #[bytecode_instruction]public native fun length<Element>(v: &vector<Element>): u64;

    #[]public inline fun map<Element, NewElement>(v: vector<Element>, f: |Element|NewElement): vector<NewElement> {
        let result = vector<NewElement>[];
        (std=0x1)::vector::for_each(v, |elem|(std=0x1)::vector::push_back(&mut result, f(elem)));
        result
    }
    #[bytecode_instruction]public native fun pop_back<Element>(v: &mut vector<Element>): Element;

    #[bytecode_instruction]public native fun push_back<Element>(v: &mut vector<Element>, e: Element): ();

    #[]public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {
        let len = (std=0x1)::vector::length(v);
        if (i >= len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len = len - 1;
        while (i < len)(std=0x1)::vector::swap(v, i,  {
            i = i + 1;
            i
        });
        (std=0x1)::vector::pop_back(v)
    }
    #[]public fun reverse<Element>(v: &mut vector<Element>): () {
        let len = (std=0x1)::vector::length(v);
        if (len == 0) return () else ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            (std=0x1)::vector::swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;
            /*()*/
        }
    }
    #[]public fun singleton<Element>(e: Element): vector<Element> {
        let v = (std=0x1)::vector::empty();
        (std=0x1)::vector::push_back(&mut v, e);
        v
    }
    #[bytecode_instruction]public native fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {
        assert!(! (std=0x1)::vector::is_empty(v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS);
        let last_idx = (std=0x1)::vector::length(v) - 1;
        (std=0x1)::vector::swap(v, i, last_idx);
        (std=0x1)::vector::pop_back(v)
    }
     spec singleton{aborts_if false;
    ensures result == vec(e)}
     spec reverse{pragma intrinsic = true}
     spec append{pragma intrinsic = true}
     spec is_empty{pragma intrinsic = true}
     spec contains{pragma intrinsic = true}
     spec index_of{pragma intrinsic = true}
     spec remove{pragma intrinsic = true}
     spec swap_remove{pragma intrinsic = true}
     spec module {}
     spec module {define eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
        len(v1) == len(v2) + 1 && v1[len(v1) - 1] == e && v1[0 .. len(v1) - 1] == v2[0 .. len(v2)]
    };
    define eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
        len(v) == len(v1) + len(v2) && v[0 .. len(v1)] == v1 && v[len(v1) .. len(v)] == v2
    };
    define eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1 == v2[1 .. len(v2)]
    };
    define eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1[0 .. i] == v2[0 .. i] && v1[i .. len(v1)] == v2[i + 1 .. len(v2)]
    }}

}
After naming: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len = (std=0x1)::vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec #0 uses [i, len, string];
            i < len
        }) {
            let byte = *(std=0x1)::vector::borrow(&string.bytes, i);
            if (! (std=0x1)::ascii::is_printable_char(byte)) return false else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [i, len, string];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char{0#byte: byte} = char;
        byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert((std=0x1)::ascii::is_valid_char(byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::ascii::Char{0#byte: byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String{0#bytes: bytes} = string;
        bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        byte >= 32 && byte <= 126
    }
    #[]public fun is_valid_char(b: u8): bool {
        b <= 127
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length((std=0x1)::ascii::as_bytes(string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char{0#byte: (std=0x1)::vector::pop_back(&mut string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back(&mut string.bytes, (&*)char.byte);
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x = (std=0x1)::ascii::try_string(bytes);
        assert((std=0x1)::option::is_some(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::option::destroy_some(x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len = (std=0x1)::vector::length(&bytes);
        let i = 0;
        while ( {
            spec #0 uses [bytes, i, len];
            i < len
        }) {
            let possible_byte = *(std=0x1)::vector::borrow(&bytes, i);
            if (! (std=0x1)::ascii::is_valid_char(possible_byte)) return (std=0x1)::option::none() else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [bytes, i, len];
        (std=0x1)::option::some((std=0x1)::ascii::String{0#bytes: bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#483>(v: &MoveValue#483): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        *(std=0x1)::vector::borrow(&bitvector.bit_field, bit_index)
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length(&bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert(start_index < (&*)bitvector.length, (std=0x1)::bit_vector::EINDEX);
        let index = start_index;
        while (index < (&*)bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set(bitvector, index)) break else ();
            index = index + 1;
            /*()*/
        };
        index - start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert(length > 0, (std=0x1)::bit_vector::ELENGTH);
        assert(length < (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH);
        let counter = 0;
        let bit_field = (std=0x1)::vector::empty();
        while ( {
            spec #0 uses [bit_field, counter, length] applies [len];
            counter < length
        }) {
            (std=0x1)::vector::push_back(&mut bit_field, false);
            counter = counter + 1;
            /*()*/
        };
        spec #1 uses [bit_field, counter, length] applies [len];
        (std=0x1)::bit_vector::BitVector{1#bit_field: bit_field, 0#length: length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (amount >= (&*)bitvector.length)  {
            let len = (std=0x1)::vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;
                /*()*/
            };
            /*()*/
        } else  {
            let i = amount;
            while (i < (&*)bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set(bitvector, i)) (std=0x1)::bit_vector::set(bitvector, i - amount) else (std=0x1)::bit_vector::unset(bitvector, i - amount);
                i = i + 1;
                /*()*/
            };
            i = (&*)bitvector.length - amount;
            while (i < (&*)bitvector.length) {
                (std=0x1)::bit_vector::unset(bitvector, i);
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ABORTED, r)
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ALREADY_EXISTS, r)
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INTERNAL, r)
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_ARGUMENT, r)
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_STATE, r)
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_FOUND, r)
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_IMPLEMENTED, r)
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::OUT_OF_RANGE, r)
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::PERMISSION_DENIED, r)
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::RESOURCE_EXHAUSTED, r)
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAUTHENTICATED, r)
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAVAILABLE, r)
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        if ((&*)num.value == floored_num)  {
            return floored_num >> 32
        } else ();
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert(scaled_denominator != 0, (std=0x1)::fixed_point32::EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert(quotient != 0 || numerator == 0, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        assert(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value = (val as u128) << 32;
        assert(value <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((&*)divisor.value != 0, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / ((&*)divisor.value as u128);
        assert(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION);
        (quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        (&*)num.value >> 32
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        (&*)num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        (&*)num.value == 0
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if ((&*)num1.value > (&*)num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if ((&*)num1.value < (&*)num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product = (val as u128) * ((&*)multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert(product <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION);
        (product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if ((&*)num.value < boundary)  {
            floored_num >> 32
        } else  {
            (std=0x1)::fixed_point32::ceil(num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#484> has copy drop store {
        0#vec: vector<Element#484>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public fun borrow<Element#485>(t: &(std=0x1)::option::Option<Element#485>): &Element#485 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow(&t.vec, 0)
    }
    #[]public fun borrow_mut<Element#486>(t: &mut (std=0x1)::option::Option<Element#486>): &mut Element#486 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow_mut(&mut t.vec, 0)
    }
    #[]public fun borrow_with_default<Element#487>(t: &(std=0x1)::option::Option<Element#487>, default_ref: &Element#487): &Element#487 {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default_ref else (std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun contains<Element#488>(t: &(std=0x1)::option::Option<Element#488>, e_ref: &Element#488): bool {
        (std=0x1)::vector::contains(&t.vec, e_ref)
    }
    #[]public fun destroy_none<Element#489>(t: (std=0x1)::option::Option<Element#489>): () {
        assert((std=0x1)::option::is_none(&t), (std=0x1)::option::EOPTION_IS_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        (std=0x1)::vector::destroy_empty(vec)
    }
    #[]public fun destroy_some<Element#490>(t: (std=0x1)::option::Option<Element#490>): Element#490 {
        assert((std=0x1)::option::is_some(&t), (std=0x1)::option::EOPTION_NOT_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        let elem = (std=0x1)::vector::pop_back(&mut vec);
        (std=0x1)::vector::destroy_empty(vec);
        elem
    }
    #[]public fun destroy_with_default<Element#491: drop>(t: (std=0x1)::option::Option<Element#491: drop>, default: Element#491: drop): Element#491: drop {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        if ((std=0x1)::vector::is_empty(&mut vec)) default else (std=0x1)::vector::pop_back(&mut vec)
    }
    #[]public fun extract<Element#492>(t: &mut (std=0x1)::option::Option<Element#492>): Element#492 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::pop_back(&mut t.vec)
    }
    #[]public fun fill<Element#493>(t: &mut (std=0x1)::option::Option<Element#493>, e: Element#493): () {
        let vec_ref = &mut t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::vector::push_back(vec_ref, e) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public inline fun filter<Element#494: drop>(o: (std=0x1)::option::Option<Element#494: drop>, f: |..|..<&Element#494: drop, bool>): (std=0x1)::option::Option<Element#494: drop> {
        if ((std=0x1)::option::is_some(&o) && f((std=0x1)::option::borrow(&o)))  {
            o
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public inline fun fold<Accumulator#495, Element#496>(o: (std=0x1)::option::Option<Element#496>, init: Accumulator#495, f: |..|..<Accumulator#495, Element#496, Accumulator#495>): Accumulator#495 {
        if ((std=0x1)::option::is_some(&o))  {
            f(init, (std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o);
            init
        }
    }
    #[]public inline fun for_each<Element#497>(o: (std=0x1)::option::Option<Element#497>, f: |..|..<Element#497, ()>): () {
        if ((std=0x1)::option::is_some(&o))  {
            f((std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o)
        }
    }
    #[]public inline fun for_each_mut<Element#498>(o: &mut (std=0x1)::option::Option<Element#498>, f: |..|..<&mut Element#498, ()>): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow_mut(o))
        } else ()
    }
    #[]public inline fun for_each_ref<Element#499>(o: &(std=0x1)::option::Option<Element#499>, f: |..|..<&Element#499, ()>): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow(o))
        } else ()
    }
    #[]public fun get_with_default<Element#500: copy+drop>(t: &(std=0x1)::option::Option<Element#500: copy+drop>, default: Element#500: copy+drop): Element#500: copy+drop {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default else *(std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun is_none<Element#501>(t: &(std=0x1)::option::Option<Element#501>): bool {
        (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public fun is_some<Element#502>(t: &(std=0x1)::option::Option<Element#502>): bool {
        ! (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public inline fun map<Element#503, OtherElement#504>(o: (std=0x1)::option::Option<Element#503>, f: |..|..<Element#503, OtherElement#504>): (std=0x1)::option::Option<OtherElement#504> {
        if ((std=0x1)::option::is_some(&o))  {
            (std=0x1)::option::some(f((std=0x1)::option::destroy_some(o)))
        } else  {
            (std=0x1)::option::destroy_none(o);
            (std=0x1)::option::none()
        }
    }
    #[]public fun none<Element#505>(): (std=0x1)::option::Option<Element#505> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::empty()}
    }
    #[]public fun some<Element#506>(e: Element#506): (std=0x1)::option::Option<Element#506> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::singleton(e)}
    }
    #[]public fun swap<Element#507>(t: &mut (std=0x1)::option::Option<Element#507>, e: Element#507): Element#507 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = (std=0x1)::vector::pop_back(vec_ref);
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun swap_or_fill<Element#508>(t: &mut (std=0x1)::option::Option<Element#508>, e: Element#508): (std=0x1)::option::Option<Element#508> {
        let vec_ref = &mut t.vec;
        let old_value = if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::option::none() else (std=0x1)::option::some((std=0x1)::vector::pop_back(vec_ref));
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun to_vec<Element#509>(t: (std=0x1)::option::Option<Element#509>): vector<Element#509> {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address(s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append(&mut s.bytes, (&*)r.bytes)
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append(s, (std=0x1)::string::utf8(bytes))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of(&s.bytes, &r.bytes)
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes = &s.bytes;
        assert(at <= (std=0x1)::vector::length(bytes) && (std=0x1)::string::internal_is_char_boundary(bytes, at), (std=0x1)::string::EINVALID_INDEX);
        let l = (std=0x1)::string::length(s);
        let front = (std=0x1)::string::sub_string(s, 0, at);
        let end = (std=0x1)::string::sub_string(s, at, l);
        (std=0x1)::string::append(&mut front, o);
        (std=0x1)::string::append(&mut front, end);
        *s = front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty(&s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length(&s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes = &s.bytes;
        let l = (std=0x1)::vector::length(bytes);
        assert(j <= l && i <= j && (std=0x1)::string::internal_is_char_boundary(bytes, i) && (std=0x1)::string::internal_is_char_boundary(bytes, j), (std=0x1)::string::EINVALID_INDEX);
        (std=0x1)::string::String{0#bytes: (std=0x1)::string::internal_sub_string(bytes, i, j)}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8(&bytes))  {
            (std=0x1)::option::some((std=0x1)::string::String{0#bytes: bytes})
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert((std=0x1)::string::internal_check_utf8(&bytes), (std=0x1)::string::EINVALID_UTF8);
        (std=0x1)::string::String{0#bytes: bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &self.name
    }
    #[]public native fun get<T#510>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        (&*)self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public fun append<Element#511>(lhs: &mut vector<Element#511>, other: vector<Element#511>): () {
        (std=0x1)::vector::reverse(&mut other);
        while (! (std=0x1)::vector::is_empty(&other))(std=0x1)::vector::push_back(lhs, (std=0x1)::vector::pop_back(&mut other));
        (std=0x1)::vector::destroy_empty(other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#512>(v: &vector<Element#512>, i: u64): &Element#512;

    #[bytecode_instruction]public native fun borrow_mut<Element#513>(v: &mut vector<Element#513>, i: u64): &mut Element#513;

    #[]public fun contains<Element#514>(v: &vector<Element#514>, e: &Element#514): bool {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return true else ();
            i = i + 1;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#515>(v: vector<Element#515>): ();

    #[bytecode_instruction]public native fun empty<Element#516>(): vector<Element#516>;

    #[]public inline fun filter<Element#517: drop>(v: vector<Element#517: drop>, p: |..|..<&Element#517: drop, bool>): vector<Element#517: drop> {
        let result = vector<Element#517: drop>[];
        (std=0x1)::vector::for_each(v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back(&mut result, elem) else ();
            /*()*/
        });
        result
    }
    #[]public inline fun fold<Accumulator#518, Element#519>(v: vector<Element#519>, init: Accumulator#518, f: |..|..<Accumulator#518, Element#519, Accumulator#518>): Accumulator#518 {
        let accu = init;
        (std=0x1)::vector::for_each(v, |elem|accu = f(accu, elem));
        accu
    }
    #[]public inline fun for_each<Element#520>(v: vector<Element#520>, f: |..|..<Element#520, ()>): () {
        (std=0x1)::vector::reverse(&mut v);
        while (! (std=0x1)::vector::is_empty(&v)) {
            let e = (std=0x1)::vector::pop_back(&mut v);
            f(e);
            /*()*/
        };
        /*()*/
    }
    #[]public inline fun for_each_mut<Element#521>(v: &mut vector<Element#521>, f: |..|..<&mut Element#521, ()>): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow_mut(v, i));
            i = i + 1
        }
    }
    #[]public inline fun for_each_ref<Element#522>(v: &vector<Element#522>, f: |..|..<&Element#522, ()>): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow(v, i));
            i = i + 1
        }
    }
    #[]public fun index_of<Element#523>(v: &vector<Element#523>, e: &Element#523): (bool, u64) {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return (true, i) else ();
            i = i + 1;
            /*()*/
        };
        (false, 0)
    }
    #[]public fun is_empty<Element#524>(v: &vector<Element#524>): bool {
        (std=0x1)::vector::length(v) == 0
    }
    #[bytecode_instruction]public native fun length<Element#525>(v: &vector<Element#525>): u64;

    #[]public inline fun map<Element#526, NewElement#527>(v: vector<Element#526>, f: |..|..<Element#526, NewElement#527>): vector<NewElement#527> {
        let result = vector<NewElement#527>[];
        (std=0x1)::vector::for_each(v, |elem|(std=0x1)::vector::push_back(&mut result, f(elem)));
        result
    }
    #[bytecode_instruction]public native fun pop_back<Element#528>(v: &mut vector<Element#528>): Element#528;

    #[bytecode_instruction]public native fun push_back<Element#529>(v: &mut vector<Element#529>, e: Element#529): ();

    #[]public fun remove<Element#530>(v: &mut vector<Element#530>, i: u64): Element#530 {
        let len = (std=0x1)::vector::length(v);
        if (i >= len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len = len - 1;
        while (i < len)(std=0x1)::vector::swap(v, i,  {
            i = i + 1;
            i
        });
        (std=0x1)::vector::pop_back(v)
    }
    #[]public fun reverse<Element#531>(v: &mut vector<Element#531>): () {
        let len = (std=0x1)::vector::length(v);
        if (len == 0) return () else ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            (std=0x1)::vector::swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;
            /*()*/
        }
    }
    #[]public fun singleton<Element#532>(e: Element#532): vector<Element#532> {
        let v = (std=0x1)::vector::empty();
        (std=0x1)::vector::push_back(&mut v, e);
        v
    }
    #[bytecode_instruction]public native fun swap<Element#533>(v: &mut vector<Element#533>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#534>(v: &mut vector<Element#534>, i: u64): Element#534 {
        assert(! (std=0x1)::vector::is_empty(v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS);
        let last_idx = (std=0x1)::vector::length(v) - 1;
        (std=0x1)::vector::swap(v, i, last_idx);
        (std=0x1)::vector::pop_back(v)
    }

}
After typing: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536u64;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy string.bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [i (i), len (len), string (string)];
            copy i <@u64 copy len
        }) {
            let byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char[parameter_types: [u8]<>(copy byte)) return false else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 uses [i (i), len (len), string (string)];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char<>{0#byte: byte}: ((std=0x1)::ascii::Char) = copy char;
        copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert(((std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::ascii::Char<>{(0#byte:u8): copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String<>{0#bytes: bytes}: ((std=0x1)::ascii::String) = copy string;
        copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        copy byte >=@u8 32u8 &&@bool copy byte <=@u8 126u8
    }
    #[]public fun is_valid_char(b: u8): bool {
        copy b <=@u8 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>((std=0x1)::ascii::as_bytes[parameter_types: [&(std=0x1)::ascii::String]<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char<>{(0#byte:u8): (std=0x1)::vector::pop_back[parameter_types: [&mut vector<u8>]<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<u8>, u8]<u8>((&mut copy string.bytes, *&&char.byte));
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x: ((std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string[parameter_types: [vector<u8>]<>(copy bytes);
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [bytes (bytes), i (i), len (len)];
            copy i <@u64 copy len
        }) {
            let possible_byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy possible_byte)) return (std=0x1)::option::none<(std=0x1)::ascii::String>(()) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 uses [bytes (bytes), i (i), len (len)];
        (std=0x1)::option::some[parameter_types: [(std=0x1)::ascii::String]<(std=0x1)::ascii::String>((std=0x1)::ascii::String<>{(0#bytes:vector<u8>): copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#483>(v: &MoveValue#483): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072u64;
    #[]const ELENGTH:u64 = 131073u64;
    #[]const MAX_SIZE:u64 = 1024u64;
    #[]const WORD_SIZE:u64 = 1u64;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        *(std=0x1)::vector::borrow[parameter_types: [&vector<bool>, u64]<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert((copy start_index <@u64 *&copy bitvector.length, (std=0x1)::bit_vector::EINDEX));
        let index: (u64) = copy start_index;
        while (copy index <@u64 *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy index))) break else ();
            index: (u64) = copy index +@u64 1u64;
            /*()*/
        };
        copy index -@u64 copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert((copy length >@u64 0u64, (std=0x1)::bit_vector::ELENGTH));
        assert((copy length <@u64 (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH));
        let counter: (u64) = 0u64;
        let bit_field: (vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            spec #0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter <@u64 copy length
        }) {
            (std=0x1)::vector::push_back[parameter_types: [&mut vector<bool>, bool]<bool>((&mut bit_field, false));
            counter: (u64) = copy counter +@u64 1u64;
            /*()*/
        };
        spec #1 uses [bit_field (bit_field), counter (counter), length (length)];
        (std=0x1)::bit_vector::BitVector<>{(1#bit_field:vector<bool>): copy bit_field, (0#length:u64): copy length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (copy amount >=@u64 *&copy bitvector.length)  {
            let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field);
            let i: (u64) = 0u64;
            while (copy i <@u64 copy len) {
                let elem: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        } else  {
            let i: (u64) = copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i))) (std=0x1)::bit_vector::set[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount)) else (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            i: (u64) = *&copy bitvector.length -@u64 copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7u64;
    #[]const ALREADY_EXISTS:u64 = 8u64;
    #[]const CANCELLED:u64 = 10u64;
    #[]const INTERNAL:u64 = 11u64;
    #[]const INVALID_ARGUMENT:u64 = 1u64;
    #[]const INVALID_STATE:u64 = 3u64;
    #[]const NOT_FOUND:u64 = 6u64;
    #[]const NOT_IMPLEMENTED:u64 = 12u64;
    #[]const OUT_OF_RANGE:u64 = 2u64;
    #[]const PERMISSION_DENIED:u64 = 5u64;
    #[]const RESOURCE_EXHAUSTED:u64 = 9u64;
    #[]const UNAUTHENTICATED:u64 = 4u64;
    #[]const UNAVAILABLE:u64 = 13u64;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        copy category <<@u64 16u8 +@u64 copy reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537u64;
    #[]const EDIVISION:u64 = 131074u64;
    #[]const EDIVISION_BY_ZERO:u64 = 65540u64;
    #[]const EMULTIPLICATION:u64 = 131075u64;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077u64;
    #[]const MAX_U64:u128 = 18446744073709551615u128;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        if (*&&num.value ==@u64 copy floored_num)  {
            return copy floored_num >>@u64 32u8
        } else ();
        let val: (u128) = (copy floored_num as u128) +@u128 1u128 <<@u128 32u8;
        (copy val >>@u128 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator: (u128) = (copy numerator as u128) <<@u128 64u8;
        let scaled_denominator: (u128) = (copy denominator as u128) <<@u128 32u8;
        assert((copy scaled_denominator !=@u128 0u128, (std=0x1)::fixed_point32::EDENOMINATOR));
        let quotient: (u128) = copy scaled_numerator /@u128 copy scaled_denominator;
        assert((copy quotient !=@u128 0u128 ||@bool copy numerator ==@u64 0u64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value: (u128) = (copy val as u128) <<@u128 32u8;
        assert((copy value <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((*&&divisor.value !=@u64 0u64, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO));
        let scaled_value: (u128) = (copy val as u128) <<@u128 32u8;
        let quotient: (u128) = copy scaled_value /@u128 (*&&divisor.value as u128);
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION));
        (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value >>@u64 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        *&&num.value ==@u64 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value >@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value <@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product: (u128) = (copy val as u128) *@u128 (*&&multiplier.value as u128);
        let product: (u128) = copy unscaled_product >>@u128 32u8;
        assert((copy product <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION));
        (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        let boundary: (u64) = copy floored_num +@u64 1u64 <<@u64 32u8 /@u64 2u64;
        if (*&&num.value <@u64 copy boundary)  {
            copy floored_num >>@u64 32u8
        } else  {
            (std=0x1)::fixed_point32::ceil[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#484> has copy drop store {
        0#vec: vector<Element#484>
    }
    #[]const EOPTION_IS_SET:u64 = 262144u64;
    #[]const EOPTION_NOT_SET:u64 = 262145u64;
    #[]public fun borrow<Element#485>(t: &(std=0x1)::option::Option<Element#485>): &Element#485 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#485>]<Element#485>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow[parameter_types: [&vector<Element#485>, u64]<Element#485>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#486>(t: &mut (std=0x1)::option::Option<Element#486>): &mut Element#486 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#486>]<Element#486>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#486>, u64]<Element#486>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#487>(t: &(std=0x1)::option::Option<Element#487>, default_ref: &Element#487): &Element#487 {
        let vec_ref: (&vector<Element#487>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#487>]<Element#487>(copy vec_ref)) copy default_ref else (std=0x1)::vector::borrow[parameter_types: [&vector<Element#487>, u64]<Element#487>((copy vec_ref, 0u64))
    }
    #[]public fun contains<Element#488>(t: &(std=0x1)::option::Option<Element#488>, e_ref: &Element#488): bool {
        (std=0x1)::vector::contains[parameter_types: [&vector<Element#488>, &Element#488]<Element#488>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#489>(t: (std=0x1)::option::Option<Element#489>): () {
        assert(((std=0x1)::option::is_none[parameter_types: [&(std=0x1)::option::Option<Element#489>]<Element#489>(&t), (std=0x1)::option::EOPTION_IS_SET));
        let (std=0x1)::option::Option<Element#489>{0#vec: vec}: ((std=0x1)::option::Option<Element#489>) = move t;
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#489>]<Element#489>(move vec)
    }
    #[]public fun destroy_some<Element#490>(t: (std=0x1)::option::Option<Element#490>): Element#490 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#490>]<Element#490>(&t), (std=0x1)::option::EOPTION_NOT_SET));
        let (std=0x1)::option::Option<Element#490>{0#vec: vec}: ((std=0x1)::option::Option<Element#490>) = move t;
        let elem: (Element#490) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#490>]<Element#490>(&mut vec);
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#490>]<Element#490>(move vec);
        move elem
    }
    #[]public fun destroy_with_default<Element#491: drop>(t: (std=0x1)::option::Option<Element#491: drop>, default: Element#491: drop): Element#491: drop {
        let (std=0x1)::option::Option<Element#491: drop>{0#vec: vec}: ((std=0x1)::option::Option<Element#491: drop>) = move t;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#491: drop>]<Element#491: drop>(&mut vec)) move default else (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#491: drop>]<Element#491: drop>(&mut vec)
    }
    #[]public fun extract<Element#492>(t: &mut (std=0x1)::option::Option<Element#492>): Element#492 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#492>]<Element#492>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#492>]<Element#492>(&mut copy t.vec)
    }
    #[]public fun fill<Element#493>(t: &mut (std=0x1)::option::Option<Element#493>, e: Element#493): () {
        let vec_ref: (&mut vector<Element#493>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#493>]<Element#493>(copy vec_ref)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#493>, Element#493]<Element#493>((copy vec_ref, move e)) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public fun filter!<Element#494: drop>(o: (std=0x1)::option::Option<Element#494: drop>, f: |..|..<&Element#494: drop, bool>): (std=0x1)::option::Option<Element#494: drop> {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#494: drop>]<Element#494: drop>(&o) &&@bool f((std=0x1)::option::borrow[parameter_types: [&(std=0x1)::option::Option<Element#494: drop>]<Element#494: drop>(&o)))  {
            move o
        } else  {
            (std=0x1)::option::none<Element#494: drop>(())
        }
    }
    #[]public fun fold!<Accumulator#495, Element#496>(o: (std=0x1)::option::Option<Element#496>, init: Accumulator#495, f: |..|..<Accumulator#495, Element#496, Accumulator#495>): Accumulator#495 {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#496>]<Element#496>(&o))  {
            f((move init, (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#496>]<Element#496>(move o)))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#496>]<Element#496>(move o);
            move init
        }
    }
    #[]public fun for_each!<Element#497>(o: (std=0x1)::option::Option<Element#497>, f: |..|..<Element#497, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#497>]<Element#497>(&o))  {
            f((std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#497>]<Element#497>(move o))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#497>]<Element#497>(move o)
        }
    }
    #[]public fun for_each_mut!<Element#498>(o: &mut (std=0x1)::option::Option<Element#498>, f: |..|..<&mut Element#498, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#498>]<Element#498>(copy o))  {
            f((std=0x1)::option::borrow_mut[parameter_types: [&mut (std=0x1)::option::Option<Element#498>]<Element#498>(copy o))
        } else ()
    }
    #[]public fun for_each_ref!<Element#499>(o: &(std=0x1)::option::Option<Element#499>, f: |..|..<&Element#499, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#499>]<Element#499>(copy o))  {
            f((std=0x1)::option::borrow[parameter_types: [&(std=0x1)::option::Option<Element#499>]<Element#499>(copy o))
        } else ()
    }
    #[]public fun get_with_default<Element#500: copy+drop>(t: &(std=0x1)::option::Option<Element#500: copy+drop>, default: Element#500: copy+drop): Element#500: copy+drop {
        let vec_ref: (&vector<Element#500: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#500: copy+drop>]<Element#500: copy+drop>(copy vec_ref)) copy default else *(std=0x1)::vector::borrow[parameter_types: [&vector<Element#500: copy+drop>, u64]<Element#500: copy+drop>((copy vec_ref, 0u64))
    }
    #[]public fun is_none<Element#501>(t: &(std=0x1)::option::Option<Element#501>): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#501>]<Element#501>(&copy t.vec)
    }
    #[]public fun is_some<Element#502>(t: &(std=0x1)::option::Option<Element#502>): bool {
        ! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#502>]<Element#502>(&copy t.vec)
    }
    #[]public fun map!<Element#503, OtherElement#504>(o: (std=0x1)::option::Option<Element#503>, f: |..|..<Element#503, OtherElement#504>): (std=0x1)::option::Option<OtherElement#504> {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#503>]<Element#503>(&o))  {
            (std=0x1)::option::some[parameter_types: [OtherElement#504]<OtherElement#504>(f((std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#503>]<Element#503>(move o)))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#503>]<Element#503>(move o);
            (std=0x1)::option::none<OtherElement#504>(())
        }
    }
    #[]public fun none<Element#505>(): (std=0x1)::option::Option<Element#505> {
        (std=0x1)::option::Option<Element#505>{(0#vec:vector<Element#505>): (std=0x1)::vector::empty<Element#505>(())}
    }
    #[]public fun some<Element#506>(e: Element#506): (std=0x1)::option::Option<Element#506> {
        (std=0x1)::option::Option<Element#506>{(0#vec:vector<Element#506>): (std=0x1)::vector::singleton[parameter_types: [Element#506]<Element#506>(move e)}
    }
    #[]public fun swap<Element#507>(t: &mut (std=0x1)::option::Option<Element#507>, e: Element#507): Element#507 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#507>]<Element#507>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        let vec_ref: (&mut vector<Element#507>) = &mut copy t.vec;
        let old_value: (Element#507) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#507>]<Element#507>(copy vec_ref);
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#507>, Element#507]<Element#507>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun swap_or_fill<Element#508>(t: &mut (std=0x1)::option::Option<Element#508>, e: Element#508): (std=0x1)::option::Option<Element#508> {
        let vec_ref: (&mut vector<Element#508>) = &mut copy t.vec;
        let old_value: ((std=0x1)::option::Option<Element#508>) = if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#508>]<Element#508>(copy vec_ref)) (std=0x1)::option::none<Element#508>(()) else (std=0x1)::option::some[parameter_types: [Element#508]<Element#508>((std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#508>]<Element#508>(copy vec_ref));
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#508>, Element#508]<Element#508>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun to_vec<Element#509>(t: (std=0x1)::option::Option<Element#509>): vector<Element#509> {
        let (std=0x1)::option::Option<Element#509>{0#vec: vec}: ((std=0x1)::option::Option<Element#509>) = move t;
        move vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address[parameter_types: [&signer]<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2u64;
    #[]const EINVALID_UTF8:u64 = 1u64;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append[parameter_types: [&mut vector<u8>, vector<u8>]<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((copy s, (std=0x1)::string::utf8[parameter_types: [vector<u8>]<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of[parameter_types: [&vector<u8>, &vector<u8>]<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes: (&vector<u8>) = &copy s.bytes;
        assert((copy at <=@u64 (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy at)), (std=0x1)::string::EINVALID_INDEX));
        let l: (u64) = (std=0x1)::string::length[parameter_types: [&(std=0x1)::string::String]<>(copy s);
        let front: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, 0u64, copy at));
        let end: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, copy at, copy l));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy o));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy end));
        *copy s = copy front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes: (&vector<u8>) = &copy s.bytes;
        let l: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes);
        assert((copy j <=@u64 copy l &&@bool copy i <=@u64 copy j &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy i)) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy j)), (std=0x1)::string::EINVALID_INDEX));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): (std=0x1)::string::internal_sub_string[parameter_types: [&vector<u8>, u64, u64]<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes))  {
            (std=0x1)::option::some[parameter_types: [(std=0x1)::string::String]<(std=0x1)::string::String>((std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes})
        } else  {
            (std=0x1)::option::none<(std=0x1)::string::String>(())
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert(((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes), (std=0x1)::string::EINVALID_UTF8));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &copy self.name
    }
    #[]public native fun get<T#510>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072u64;
    #[]public fun append<Element#511>(lhs: &mut vector<Element#511>, other: vector<Element#511>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#511>]<Element#511>(&mut other);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#511>]<Element#511>(&other))(std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#511>, Element#511]<Element#511>((copy lhs, (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#511>]<Element#511>(&mut other)));
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#511>]<Element#511>(move other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#512>(v: &vector<Element#512>, i: u64): &Element#512;

    #[bytecode_instruction]public native fun borrow_mut<Element#513>(v: &mut vector<Element#513>, i: u64): &mut Element#513;

    #[]public fun contains<Element#514>(v: &vector<Element#514>, e: &Element#514): bool {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#514>]<Element#514>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#514>, u64]<Element#514>((copy v, copy i)) ==@&Element#514 copy e) return true else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#515>(v: vector<Element#515>): ();

    #[bytecode_instruction]public native fun empty<Element#516>(): vector<Element#516>;

    #[]public fun filter!<Element#517: drop>(v: vector<Element#517: drop>, p: |..|..<&Element#517: drop, bool>): vector<Element#517: drop> {
        let result: (vector<Element#517: drop>) = vector#0<Element#517: drop>[()];
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#517: drop>, |..|..<Element#517: drop, ()>]<Element#517: drop>((move v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#517: drop>, Element#517: drop]<Element#517: drop>((&mut result, move elem)) else ();
            /*()*/
        }));
        move result
    }
    #[]public fun fold!<Accumulator#518, Element#519>(v: vector<Element#519>, init: Accumulator#518, f: |..|..<Accumulator#518, Element#519, Accumulator#518>): Accumulator#518 {
        let accu: (Accumulator#518) = move init;
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#519>, |..|..<Element#519, ()>]<Element#519>((move v, |elem|accu: (Accumulator#518) = f((move accu, move elem))));
        move accu
    }
    #[]public fun for_each!<Element#520>(v: vector<Element#520>, f: |..|..<Element#520, ()>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#520>]<Element#520>(&mut v);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#520>]<Element#520>(&v)) {
            let e: (Element#520) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#520>]<Element#520>(&mut v);
            f(move e);
            /*()*/
        };
        /*()*/
    }
    #[]public fun for_each_mut!<Element#521>(v: &mut vector<Element#521>, f: |..|..<&mut Element#521, ()>): () {
        let i: (u64) = 0u64;
        while (copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<Element#521>]<Element#521>(copy v)) {
            f((std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#521>, u64]<Element#521>((copy v, copy i)));
            i: (u64) = copy i +@u64 1u64
        }
    }
    #[]public fun for_each_ref!<Element#522>(v: &vector<Element#522>, f: |..|..<&Element#522, ()>): () {
        let i: (u64) = 0u64;
        while (copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<Element#522>]<Element#522>(copy v)) {
            f((std=0x1)::vector::borrow[parameter_types: [&vector<Element#522>, u64]<Element#522>((copy v, copy i)));
            i: (u64) = copy i +@u64 1u64
        }
    }
    #[]public fun index_of<Element#523>(v: &vector<Element#523>, e: &Element#523): (bool, u64) {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#523>]<Element#523>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#523>, u64]<Element#523>((copy v, copy i)) ==@&Element#523 copy e) return (true, copy i) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        (false, 0u64)
    }
    #[]public fun is_empty<Element#524>(v: &vector<Element#524>): bool {
        (std=0x1)::vector::length[parameter_types: [&vector<Element#524>]<Element#524>(copy v) ==@u64 0u64
    }
    #[bytecode_instruction]public native fun length<Element#525>(v: &vector<Element#525>): u64;

    #[]public fun map!<Element#526, NewElement#527>(v: vector<Element#526>, f: |..|..<Element#526, NewElement#527>): vector<NewElement#527> {
        let result: (vector<NewElement#527>) = vector#0<NewElement#527>[()];
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#526>, |..|..<Element#526, ()>]<Element#526>((move v, |elem|(std=0x1)::vector::push_back[parameter_types: [&mut vector<NewElement#527>, NewElement#527]<NewElement#527>((&mut result, f(move elem)))));
        move result
    }
    #[bytecode_instruction]public native fun pop_back<Element#528>(v: &mut vector<Element#528>): Element#528;

    #[bytecode_instruction]public native fun push_back<Element#529>(v: &mut vector<Element#529>, e: Element#529): ();

    #[]public fun remove<Element#530>(v: &mut vector<Element#530>, i: u64): Element#530 {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#530>]<Element#530>(copy v);
        if (copy i >=@u64 copy len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len: (u64) = copy len -@u64 1u64;
        while (copy i <@u64 copy len)(std=0x1)::vector::swap[parameter_types: [&mut vector<Element#530>, u64, u64]<Element#530>((copy v, copy i,  {
            i: (u64) = copy i +@u64 1u64;
            copy i
        }));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#530>]<Element#530>(copy v)
    }
    #[]public fun reverse<Element#531>(v: &mut vector<Element#531>): () {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#531>]<Element#531>(copy v);
        if (copy len ==@u64 0u64) return () else ();
        let front_index: (u64) = 0u64;
        let back_index: (u64) = copy len -@u64 1u64;
        while (copy front_index <@u64 copy back_index) {
            (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#531>, u64, u64]<Element#531>((copy v, copy front_index, copy back_index));
            front_index: (u64) = copy front_index +@u64 1u64;
            back_index: (u64) = copy back_index -@u64 1u64;
            /*()*/
        }
    }
    #[]public fun singleton<Element#532>(e: Element#532): vector<Element#532> {
        let v: (vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#532>, Element#532]<Element#532>((&mut v, move e));
        move v
    }
    #[bytecode_instruction]public native fun swap<Element#533>(v: &mut vector<Element#533>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#534>(v: &mut vector<Element#534>, i: u64): Element#534 {
        assert((! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#534>]<Element#534>(copy v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS));
        let last_idx: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#534>]<Element#534>(copy v) -@u64 1u64;
        (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#534>, u64, u64]<Element#534>((copy v, copy i, copy last_idx));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#534>]<Element#534>(copy v)
    }

}
After inlining: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536u64;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy string.bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            copy i <@u64 copy len
        }) {
            let byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char[parameter_types: [u8]<>(copy byte)) return false else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char<>{0#byte: byte}: ((std=0x1)::ascii::Char) = copy char;
        copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert(((std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::ascii::Char<>{(0#byte:u8): copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String<>{0#bytes: bytes}: ((std=0x1)::ascii::String) = copy string;
        copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        copy byte >=@u8 32u8 &&@bool copy byte <=@u8 126u8
    }
    #[]public fun is_valid_char(b: u8): bool {
        copy b <=@u8 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>((std=0x1)::ascii::as_bytes[parameter_types: [&(std=0x1)::ascii::String]<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char<>{(0#byte:u8): (std=0x1)::vector::pop_back[parameter_types: [&mut vector<u8>]<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<u8>, u8]<u8>((&mut copy string.bytes, *&&char.byte));
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x: ((std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string[parameter_types: [vector<u8>]<>(copy bytes);
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            copy i <@u64 copy len
        }) {
            let possible_byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy possible_byte)) return (std=0x1)::option::none<(std=0x1)::ascii::String>(()) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        (std=0x1)::option::some[parameter_types: [(std=0x1)::ascii::String]<(std=0x1)::ascii::String>((std=0x1)::ascii::String<>{(0#bytes:vector<u8>): copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#483>(v: &MoveValue#483): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072u64;
    #[]const ELENGTH:u64 = 131073u64;
    #[]const MAX_SIZE:u64 = 1024u64;
    #[]const WORD_SIZE:u64 = 1u64;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        *(std=0x1)::vector::borrow[parameter_types: [&vector<bool>, u64]<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert((copy start_index <@u64 *&copy bitvector.length, (std=0x1)::bit_vector::EINDEX));
        let index: (u64) = copy start_index;
        while (copy index <@u64 *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy index))) break else ();
            index: (u64) = copy index +@u64 1u64;
            /*()*/
        };
        copy index -@u64 copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert((copy length >@u64 0u64, (std=0x1)::bit_vector::ELENGTH));
        assert((copy length <@u64 (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH));
        let counter: (u64) = 0u64;
        let bit_field: (vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter <@u64 copy length
        }) {
            (std=0x1)::vector::push_back[parameter_types: [&mut vector<bool>, bool]<bool>((&mut bit_field, false));
            counter: (u64) = copy counter +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        (std=0x1)::bit_vector::BitVector<>{(1#bit_field:vector<bool>): copy bit_field, (0#length:u64): copy length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (copy amount >=@u64 *&copy bitvector.length)  {
            let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field);
            let i: (u64) = 0u64;
            while (copy i <@u64 copy len) {
                let elem: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        } else  {
            let i: (u64) = copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i))) (std=0x1)::bit_vector::set[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount)) else (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            i: (u64) = *&copy bitvector.length -@u64 copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7u64;
    #[]const ALREADY_EXISTS:u64 = 8u64;
    #[]const CANCELLED:u64 = 10u64;
    #[]const INTERNAL:u64 = 11u64;
    #[]const INVALID_ARGUMENT:u64 = 1u64;
    #[]const INVALID_STATE:u64 = 3u64;
    #[]const NOT_FOUND:u64 = 6u64;
    #[]const NOT_IMPLEMENTED:u64 = 12u64;
    #[]const OUT_OF_RANGE:u64 = 2u64;
    #[]const PERMISSION_DENIED:u64 = 5u64;
    #[]const RESOURCE_EXHAUSTED:u64 = 9u64;
    #[]const UNAUTHENTICATED:u64 = 4u64;
    #[]const UNAVAILABLE:u64 = 13u64;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        copy category <<@u64 16u8 +@u64 copy reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537u64;
    #[]const EDIVISION:u64 = 131074u64;
    #[]const EDIVISION_BY_ZERO:u64 = 65540u64;
    #[]const EMULTIPLICATION:u64 = 131075u64;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077u64;
    #[]const MAX_U64:u128 = 18446744073709551615u128;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        if (*&&num.value ==@u64 copy floored_num)  {
            return copy floored_num >>@u64 32u8
        } else ();
        let val: (u128) = (copy floored_num as u128) +@u128 1u128 <<@u128 32u8;
        (copy val >>@u128 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator: (u128) = (copy numerator as u128) <<@u128 64u8;
        let scaled_denominator: (u128) = (copy denominator as u128) <<@u128 32u8;
        assert((copy scaled_denominator !=@u128 0u128, (std=0x1)::fixed_point32::EDENOMINATOR));
        let quotient: (u128) = copy scaled_numerator /@u128 copy scaled_denominator;
        assert((copy quotient !=@u128 0u128 ||@bool copy numerator ==@u64 0u64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value: (u128) = (copy val as u128) <<@u128 32u8;
        assert((copy value <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((*&&divisor.value !=@u64 0u64, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO));
        let scaled_value: (u128) = (copy val as u128) <<@u128 32u8;
        let quotient: (u128) = copy scaled_value /@u128 (*&&divisor.value as u128);
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION));
        (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value >>@u64 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        *&&num.value ==@u64 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value >@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value <@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product: (u128) = (copy val as u128) *@u128 (*&&multiplier.value as u128);
        let product: (u128) = copy unscaled_product >>@u128 32u8;
        assert((copy product <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION));
        (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        let boundary: (u64) = copy floored_num +@u64 1u64 <<@u64 32u8 /@u64 2u64;
        if (*&&num.value <@u64 copy boundary)  {
            copy floored_num >>@u64 32u8
        } else  {
            (std=0x1)::fixed_point32::ceil[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#484> has copy drop store {
        0#vec: vector<Element#484>
    }
    #[]const EOPTION_IS_SET:u64 = 262144u64;
    #[]const EOPTION_NOT_SET:u64 = 262145u64;
    #[]public fun borrow<Element#485>(t: &(std=0x1)::option::Option<Element#485>): &Element#485 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#485>]<Element#485>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow[parameter_types: [&vector<Element#485>, u64]<Element#485>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#486>(t: &mut (std=0x1)::option::Option<Element#486>): &mut Element#486 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#486>]<Element#486>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#486>, u64]<Element#486>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#487>(t: &(std=0x1)::option::Option<Element#487>, default_ref: &Element#487): &Element#487 {
        let vec_ref: (&vector<Element#487>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#487>]<Element#487>(copy vec_ref)) copy default_ref else (std=0x1)::vector::borrow[parameter_types: [&vector<Element#487>, u64]<Element#487>((copy vec_ref, 0u64))
    }
    #[]public fun contains<Element#488>(t: &(std=0x1)::option::Option<Element#488>, e_ref: &Element#488): bool {
        (std=0x1)::vector::contains[parameter_types: [&vector<Element#488>, &Element#488]<Element#488>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#489>(t: (std=0x1)::option::Option<Element#489>): () {
        assert(((std=0x1)::option::is_none[parameter_types: [&(std=0x1)::option::Option<Element#489>]<Element#489>(&t), (std=0x1)::option::EOPTION_IS_SET));
        let (std=0x1)::option::Option<Element#489>{0#vec: vec}: ((std=0x1)::option::Option<Element#489>) = move t;
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#489>]<Element#489>(move vec)
    }
    #[]public fun destroy_some<Element#490>(t: (std=0x1)::option::Option<Element#490>): Element#490 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#490>]<Element#490>(&t), (std=0x1)::option::EOPTION_NOT_SET));
        let (std=0x1)::option::Option<Element#490>{0#vec: vec}: ((std=0x1)::option::Option<Element#490>) = move t;
        let elem: (Element#490) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#490>]<Element#490>(&mut vec);
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#490>]<Element#490>(move vec);
        move elem
    }
    #[]public fun destroy_with_default<Element#491: drop>(t: (std=0x1)::option::Option<Element#491: drop>, default: Element#491: drop): Element#491: drop {
        let (std=0x1)::option::Option<Element#491: drop>{0#vec: vec}: ((std=0x1)::option::Option<Element#491: drop>) = move t;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#491: drop>]<Element#491: drop>(&mut vec)) move default else (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#491: drop>]<Element#491: drop>(&mut vec)
    }
    #[]public fun extract<Element#492>(t: &mut (std=0x1)::option::Option<Element#492>): Element#492 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#492>]<Element#492>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#492>]<Element#492>(&mut copy t.vec)
    }
    #[]public fun fill<Element#493>(t: &mut (std=0x1)::option::Option<Element#493>, e: Element#493): () {
        let vec_ref: (&mut vector<Element#493>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#493>]<Element#493>(copy vec_ref)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#493>, Element#493]<Element#493>((copy vec_ref, move e)) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public fun get_with_default<Element#500: copy+drop>(t: &(std=0x1)::option::Option<Element#500: copy+drop>, default: Element#500: copy+drop): Element#500: copy+drop {
        let vec_ref: (&vector<Element#500: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#500: copy+drop>]<Element#500: copy+drop>(copy vec_ref)) copy default else *(std=0x1)::vector::borrow[parameter_types: [&vector<Element#500: copy+drop>, u64]<Element#500: copy+drop>((copy vec_ref, 0u64))
    }
    #[]public fun is_none<Element#501>(t: &(std=0x1)::option::Option<Element#501>): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#501>]<Element#501>(&copy t.vec)
    }
    #[]public fun is_some<Element#502>(t: &(std=0x1)::option::Option<Element#502>): bool {
        ! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#502>]<Element#502>(&copy t.vec)
    }
    #[]public fun none<Element#505>(): (std=0x1)::option::Option<Element#505> {
        (std=0x1)::option::Option<Element#505>{(0#vec:vector<Element#505>): (std=0x1)::vector::empty<Element#505>(())}
    }
    #[]public fun some<Element#506>(e: Element#506): (std=0x1)::option::Option<Element#506> {
        (std=0x1)::option::Option<Element#506>{(0#vec:vector<Element#506>): (std=0x1)::vector::singleton[parameter_types: [Element#506]<Element#506>(move e)}
    }
    #[]public fun swap<Element#507>(t: &mut (std=0x1)::option::Option<Element#507>, e: Element#507): Element#507 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#507>]<Element#507>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        let vec_ref: (&mut vector<Element#507>) = &mut copy t.vec;
        let old_value: (Element#507) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#507>]<Element#507>(copy vec_ref);
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#507>, Element#507]<Element#507>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun swap_or_fill<Element#508>(t: &mut (std=0x1)::option::Option<Element#508>, e: Element#508): (std=0x1)::option::Option<Element#508> {
        let vec_ref: (&mut vector<Element#508>) = &mut copy t.vec;
        let old_value: ((std=0x1)::option::Option<Element#508>) = if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#508>]<Element#508>(copy vec_ref)) (std=0x1)::option::none<Element#508>(()) else (std=0x1)::option::some[parameter_types: [Element#508]<Element#508>((std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#508>]<Element#508>(copy vec_ref));
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#508>, Element#508]<Element#508>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun to_vec<Element#509>(t: (std=0x1)::option::Option<Element#509>): vector<Element#509> {
        let (std=0x1)::option::Option<Element#509>{0#vec: vec}: ((std=0x1)::option::Option<Element#509>) = move t;
        move vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address[parameter_types: [&signer]<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2u64;
    #[]const EINVALID_UTF8:u64 = 1u64;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append[parameter_types: [&mut vector<u8>, vector<u8>]<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((copy s, (std=0x1)::string::utf8[parameter_types: [vector<u8>]<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of[parameter_types: [&vector<u8>, &vector<u8>]<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes: (&vector<u8>) = &copy s.bytes;
        assert((copy at <=@u64 (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy at)), (std=0x1)::string::EINVALID_INDEX));
        let l: (u64) = (std=0x1)::string::length[parameter_types: [&(std=0x1)::string::String]<>(copy s);
        let front: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, 0u64, copy at));
        let end: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, copy at, copy l));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy o));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy end));
        *copy s = copy front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes: (&vector<u8>) = &copy s.bytes;
        let l: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes);
        assert((copy j <=@u64 copy l &&@bool copy i <=@u64 copy j &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy i)) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy j)), (std=0x1)::string::EINVALID_INDEX));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): (std=0x1)::string::internal_sub_string[parameter_types: [&vector<u8>, u64, u64]<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes))  {
            (std=0x1)::option::some[parameter_types: [(std=0x1)::string::String]<(std=0x1)::string::String>((std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes})
        } else  {
            (std=0x1)::option::none<(std=0x1)::string::String>(())
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert(((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes), (std=0x1)::string::EINVALID_UTF8));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &copy self.name
    }
    #[]public native fun get<T#510>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072u64;
    #[]public fun append<Element#511>(lhs: &mut vector<Element#511>, other: vector<Element#511>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#511>]<Element#511>(&mut other);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#511>]<Element#511>(&other))(std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#511>, Element#511]<Element#511>((copy lhs, (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#511>]<Element#511>(&mut other)));
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#511>]<Element#511>(move other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#512>(v: &vector<Element#512>, i: u64): &Element#512;

    #[bytecode_instruction]public native fun borrow_mut<Element#513>(v: &mut vector<Element#513>, i: u64): &mut Element#513;

    #[]public fun contains<Element#514>(v: &vector<Element#514>, e: &Element#514): bool {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#514>]<Element#514>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#514>, u64]<Element#514>((copy v, copy i)) ==@&Element#514 copy e) return true else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#515>(v: vector<Element#515>): ();

    #[bytecode_instruction]public native fun empty<Element#516>(): vector<Element#516>;

    #[]public fun index_of<Element#523>(v: &vector<Element#523>, e: &Element#523): (bool, u64) {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#523>]<Element#523>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#523>, u64]<Element#523>((copy v, copy i)) ==@&Element#523 copy e) return (true, copy i) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        (false, 0u64)
    }
    #[]public fun is_empty<Element#524>(v: &vector<Element#524>): bool {
        (std=0x1)::vector::length[parameter_types: [&vector<Element#524>]<Element#524>(copy v) ==@u64 0u64
    }
    #[bytecode_instruction]public native fun length<Element#525>(v: &vector<Element#525>): u64;

    #[bytecode_instruction]public native fun pop_back<Element#528>(v: &mut vector<Element#528>): Element#528;

    #[bytecode_instruction]public native fun push_back<Element#529>(v: &mut vector<Element#529>, e: Element#529): ();

    #[]public fun remove<Element#530>(v: &mut vector<Element#530>, i: u64): Element#530 {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#530>]<Element#530>(copy v);
        if (copy i >=@u64 copy len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len: (u64) = copy len -@u64 1u64;
        while (copy i <@u64 copy len)(std=0x1)::vector::swap[parameter_types: [&mut vector<Element#530>, u64, u64]<Element#530>((copy v, copy i,  {
            i: (u64) = copy i +@u64 1u64;
            copy i
        }));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#530>]<Element#530>(copy v)
    }
    #[]public fun reverse<Element#531>(v: &mut vector<Element#531>): () {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#531>]<Element#531>(copy v);
        if (copy len ==@u64 0u64) return () else ();
        let front_index: (u64) = 0u64;
        let back_index: (u64) = copy len -@u64 1u64;
        while (copy front_index <@u64 copy back_index) {
            (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#531>, u64, u64]<Element#531>((copy v, copy front_index, copy back_index));
            front_index: (u64) = copy front_index +@u64 1u64;
            back_index: (u64) = copy back_index -@u64 1u64;
            /*()*/
        }
    }
    #[]public fun singleton<Element#532>(e: Element#532): vector<Element#532> {
        let v: (vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#532>, Element#532]<Element#532>((&mut v, move e));
        move v
    }
    #[bytecode_instruction]public native fun swap<Element#533>(v: &mut vector<Element#533>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#534>(v: &mut vector<Element#534>, i: u64): Element#534 {
        assert((! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#534>]<Element#534>(copy v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS));
        let last_idx: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#534>]<Element#534>(copy v) -@u64 1u64;
        (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#534>, u64, u64]<Element#534>((copy v, copy i, copy last_idx));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#534>]<Element#534>(copy v)
    }

}
After hlir: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        byte: u8
    }
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 =  {
        locals:


        return 65536u64
    };
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        locals:
            byte: u8,
            i: u64,
            len: u64,
            string: &(std=0x1)::ascii::String

        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        while ( {
            pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            copy i < copy len
        }) {
            (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char<>(copy byte))  {
                return@false
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        locals:
            string: &(std=0x1)::ascii::String

        return &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        locals:
            byte: u8,
            char: (std=0x1)::ascii::Char

        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        locals:
            byte: u8

        if ((std=0x1)::ascii::is_valid_char<>(copy byte))  {
            pop  = ()
        } else  {
            abort EINVALID_ASCII_CHARACTER
        };
        pop  = /*()*/;
        return Char<>{byte: copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        locals:
            bytes: vector<u8>,
            string: (std=0x1)::ascii::String

        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        locals:
            %#1: bool,
            byte: u8

        if (copy byte >= 32u8)  {
            (%#1: bool) = copy byte <= 126u8
        } else  {
            (%#1: bool) = false
        };
        return move#last %#1
    }
    #[]public fun is_valid_char(b: u8): bool {
        locals:
            b: u8

        return copy b <= 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        locals:
            string: &(std=0x1)::ascii::String

        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        locals:
            string: &mut (std=0x1)::ascii::String

        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        locals:
            char: (std=0x1)::ascii::Char,
            string: &mut (std=0x1)::ascii::String

        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        locals:
            bytes: vector<u8>,
            x: (std=0x1)::option::Option<(std=0x1)::ascii::String>

        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        if ((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x))  {
            pop  = ()
        } else  {
            abort EINVALID_ASCII_CHARACTER
        };
        pop  = /*()*/;
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        locals:
            bytes: vector<u8>,
            i: u64,
            len: u64,
            possible_byte: u8

        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        while ( {
            pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            copy i < copy len
        }) {
            (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char<>(copy possible_byte))  {
                return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#483>(v: &MoveValue#483): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        length: u64;
        bit_field: vector<bool>
    }
    #[]const EINDEX:u64 =  {
        locals:


        return 131072u64
    };
    #[]const ELENGTH:u64 =  {
        locals:


        return 131073u64
    };
    #[]const MAX_SIZE:u64 =  {
        locals:


        return 1024u64
    };
    #[]const WORD_SIZE:u64 =  {
        locals:


        return 1u64
    };
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        locals:
            bit_index: u64,
            bitvector: &(std=0x1)::bit_vector::BitVector

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector

        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector,
            index: u64,
            start_index: u64

        if (copy start_index < *&copy bitvector.length)  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (index: u64) = copy start_index;
        while (copy index < *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index)))  {
                break
            } else  {
                pop  = ()
            };
            (index: u64) = copy index + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return copy index - copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        locals:
            bit_field: vector<bool>,
            counter: u64,
            length: u64

        if (copy length > 0u64)  {
            pop  = ()
        } else  {
            abort ELENGTH
        };
        pop  = /*()*/;
        if (copy length < MAX_SIZE)  {
            pop  = ()
        } else  {
            abort ELENGTH
        };
        pop  = /*()*/;
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter < copy length
        }) {
            pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
            (counter: u64) = copy counter + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        pop  = /*()*/;
        return /*;()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        locals:
            %#2: &mut (std=0x1)::bit_vector::BitVector,
            %#3: u64,
            amount: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            elem: &mut bool,
            i: u64,
            i#1: u64,
            len: u64

        if (copy amount >= *&copy bitvector.length)  {
            (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
            (i: u64) = 0u64;
            while (copy i < copy len) {
                (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                pop  = /*()*/;
                (i: u64) = copy i + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        } else  {
            (i#1: u64) = copy amount;
            while (copy i#1 < *&copy bitvector.length) {
                ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
                if ((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3)))  {
                    pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount))
                } else  {
                    pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount))
                };
                (i#1: u64) = copy i#1 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            (i#1: u64) = *&copy bitvector.length - copy amount;
            pop  = /*()*/;
            while (copy i#1 < *&copy bitvector.length) {
                pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
                (i#1: u64) = copy i#1 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        };
        return /*()*/
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        pop  = /*()*/;
        return /*;()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 =  {
        locals:


        return 7u64
    };
    #[]const ALREADY_EXISTS:u64 =  {
        locals:


        return 8u64
    };
    #[]const CANCELLED:u64 =  {
        locals:


        return 10u64
    };
    #[]const INTERNAL:u64 =  {
        locals:


        return 11u64
    };
    #[]const INVALID_ARGUMENT:u64 =  {
        locals:


        return 1u64
    };
    #[]const INVALID_STATE:u64 =  {
        locals:


        return 3u64
    };
    #[]const NOT_FOUND:u64 =  {
        locals:


        return 6u64
    };
    #[]const NOT_IMPLEMENTED:u64 =  {
        locals:


        return 12u64
    };
    #[]const OUT_OF_RANGE:u64 =  {
        locals:


        return 2u64
    };
    #[]const PERMISSION_DENIED:u64 =  {
        locals:


        return 5u64
    };
    #[]const RESOURCE_EXHAUSTED:u64 =  {
        locals:


        return 9u64
    };
    #[]const UNAUTHENTICATED:u64 =  {
        locals:


        return 4u64
    };
    #[]const UNAVAILABLE:u64 =  {
        locals:


        return 13u64
    };
    #[]public fun aborted(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        locals:
            category: u64,
            reason: u64

        return copy category << 16u8 + copy reason
    }
    #[]public fun internal(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        value: u64
    }
    #[]const EDENOMINATOR:u64 =  {
        locals:


        return 65537u64
    };
    #[]const EDIVISION:u64 =  {
        locals:


        return 131074u64
    };
    #[]const EDIVISION_BY_ZERO:u64 =  {
        locals:


        return 65540u64
    };
    #[]const EMULTIPLICATION:u64 =  {
        locals:


        return 131075u64
    };
    #[]const ERATIO_OUT_OF_RANGE:u64 =  {
        locals:


        return 131077u64
    };
    #[]const MAX_U64:u128 =  {
        locals:


        return 18446744073709551615u128
    };
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32,
            val: u128

        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        if (*&&num.value == copy floored_num)  {
            return@copy floored_num >> 32u8
        } else  {
            pop  = ()
        };
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: bool,
            denominator: u64,
            numerator: u64,
            quotient: u128,
            scaled_denominator: u128,
            scaled_numerator: u128

        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        if (copy scaled_denominator != 0u128)  {
            pop  = ()
        } else  {
            abort EDENOMINATOR
        };
        pop  = /*()*/;
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        if (copy quotient != 0u128)  {
            (%#1: bool) = true
        } else  {
            (%#1: bool) = copy numerator == 0u64
        };
        if (move#last %#1)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        if (copy quotient <= MAX_U64)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        return FixedPoint32<>{value: (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            value: u64

        return FixedPoint32<>{value: copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            val: u64,
            value: u128

        (value: u128) = (copy val as u128) << 32u8;
        if (copy value <= MAX_U64)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        return FixedPoint32<>{value: (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            divisor: (std=0x1)::fixed_point32::FixedPoint32,
            quotient: u128,
            scaled_value: u128,
            val: u64

        if (*&&divisor.value != 0u64)  {
            pop  = ()
        } else  {
            abort EDIVISION_BY_ZERO
        };
        pop  = /*()*/;
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        if (copy quotient <= MAX_U64)  {
            pop  = ()
        } else  {
            abort EDIVISION
        };
        pop  = /*()*/;
        return (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value >> 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value == 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        if (*&&num1.value > *&&num2.value)  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1
        } else  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2
        };
        return move#last %#1
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        if (*&&num1.value < *&&num2.value)  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1
        } else  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2
        };
        return move#last %#1
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            multiplier: (std=0x1)::fixed_point32::FixedPoint32,
            product: u128,
            unscaled_product: u128,
            val: u64

        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        if (copy product <= MAX_U64)  {
            pop  = ()
        } else  {
            abort EMULTIPLICATION
        };
        pop  = /*()*/;
        return (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            %#1: u64,
            boundary: u64,
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32

        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        if (*&&num.value < copy boundary)  {
            (%#1: u64) = copy floored_num >> 32u8
        } else  {
            (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num)
        };
        return move#last %#1
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#484> has copy drop store {
        vec: vector<Element#484>
    }
    #[]const EOPTION_IS_SET:u64 =  {
        locals:


        return 262144u64
    };
    #[]const EOPTION_NOT_SET:u64 =  {
        locals:


        return 262145u64
    };
    #[]public fun borrow<Element#485>(t: &(std=0x1)::option::Option<Element#485>): &Element#485 {
        locals:
            t: &(std=0x1)::option::Option<Element#485>

        if ((std=0x1)::option::is_some<Element#485>(copy t))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::borrow<Element#485>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#486>(t: &mut (std=0x1)::option::Option<Element#486>): &mut Element#486 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#486>

        if ((std=0x1)::option::is_some<Element#486>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::borrow_mut<Element#486>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#487>(t: &(std=0x1)::option::Option<Element#487>, default_ref: &Element#487): &Element#487 {
        locals:
            %#1: &Element#487,
            default_ref: &Element#487,
            t: &(std=0x1)::option::Option<Element#487>,
            vec_ref: &vector<Element#487>

        (vec_ref: &vector<Element#487>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#487>(copy vec_ref))  {
            (%#1: &Element#487) = copy default_ref
        } else  {
            (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((copy vec_ref, 0u64))
        };
        return move#last %#1
    }
    #[]public fun contains<Element#488>(t: &(std=0x1)::option::Option<Element#488>, e_ref: &Element#488): bool {
        locals:
            e_ref: &Element#488,
            t: &(std=0x1)::option::Option<Element#488>

        return (std=0x1)::vector::contains<Element#488>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#489>(t: (std=0x1)::option::Option<Element#489>): () {
        locals:
            t: (std=0x1)::option::Option<Element#489>,
            vec: vector<Element#489>

        if ((std=0x1)::option::is_none<Element#489>(&t))  {
            pop  = ()
        } else  {
            abort EOPTION_IS_SET
        };
        pop  = /*()*/;
        Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)
    }
    #[]public fun destroy_some<Element#490>(t: (std=0x1)::option::Option<Element#490>): Element#490 {
        locals:
            elem: Element#490,
            t: (std=0x1)::option::Option<Element#490>,
            vec: vector<Element#490>

        if ((std=0x1)::option::is_some<Element#490>(&t))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
        (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
        return move#no-copy elem
    }
    #[]public fun destroy_with_default<Element#491: drop>(t: (std=0x1)::option::Option<Element#491: drop>, default: Element#491: drop): Element#491: drop {
        locals:
            %#1: Element#491: drop,
            default: Element#491: drop,
            t: (std=0x1)::option::Option<Element#491: drop>,
            vec: vector<Element#491: drop>

        Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
        if ((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec)))  {
            (%#1: Element#491: drop) = move#no-copy default
        } else  {
            (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec)
        };
        return move#last %#1
    }
    #[]public fun extract<Element#492>(t: &mut (std=0x1)::option::Option<Element#492>): Element#492 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#492>

        if ((std=0x1)::option::is_some<Element#492>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::pop_back<Element#492>(&mut copy t.vec)
    }
    #[]public fun fill<Element#493>(t: &mut (std=0x1)::option::Option<Element#493>, e: Element#493): () {
        locals:
            e: Element#493,
            t: &mut (std=0x1)::option::Option<Element#493>,
            vec_ref: &mut vector<Element#493>

        (vec_ref: &mut vector<Element#493>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref)))  {
            pop  = (std=0x1)::vector::push_back<Element#493>((copy vec_ref, move#no-copy e))
        } else  {
            abort EOPTION_IS_SET
        };
        return /*()*/
    }
    #[]public fun get_with_default<Element#500: copy+drop>(t: &(std=0x1)::option::Option<Element#500: copy+drop>, default: Element#500: copy+drop): Element#500: copy+drop {
        locals:
            %#1: Element#500: copy+drop,
            default: Element#500: copy+drop,
            t: &(std=0x1)::option::Option<Element#500: copy+drop>,
            vec_ref: &vector<Element#500: copy+drop>

        (vec_ref: &vector<Element#500: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref))  {
            (%#1: Element#500: copy+drop) = copy default
        } else  {
            (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((copy vec_ref, 0u64))
        };
        return move#last %#1
    }
    #[]public fun is_none<Element#501>(t: &(std=0x1)::option::Option<Element#501>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#501>

        return (std=0x1)::vector::is_empty<Element#501>(&copy t.vec)
    }
    #[]public fun is_some<Element#502>(t: &(std=0x1)::option::Option<Element#502>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#502>

        return ! (std=0x1)::vector::is_empty<Element#502>(&copy t.vec)
    }
    #[]public fun none<Element#505>(): (std=0x1)::option::Option<Element#505> {
        locals:


        return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}
    }
    #[]public fun some<Element#506>(e: Element#506): (std=0x1)::option::Option<Element#506> {
        locals:
            e: Element#506

        return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}
    }
    #[]public fun swap<Element#507>(t: &mut (std=0x1)::option::Option<Element#507>, e: Element#507): Element#507 {
        locals:
            e: Element#507,
            old_value: Element#507,
            t: &mut (std=0x1)::option::Option<Element#507>,
            vec_ref: &mut vector<Element#507>

        if ((std=0x1)::option::is_some<Element#507>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        (vec_ref: &mut vector<Element#507>) = &mut copy t.vec;
        (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#507>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
    }
    #[]public fun swap_or_fill<Element#508>(t: &mut (std=0x1)::option::Option<Element#508>, e: Element#508): (std=0x1)::option::Option<Element#508> {
        locals:
            %#1: (std=0x1)::option::Option<Element#508>,
            e: Element#508,
            old_value: (std=0x1)::option::Option<Element#508>,
            t: &mut (std=0x1)::option::Option<Element#508>,
            vec_ref: &mut vector<Element#508>

        (vec_ref: &mut vector<Element#508>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref)))  {
            (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(())
        } else  {
            (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref))
        };
        (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#508>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
    }
    #[]public fun to_vec<Element#509>(t: (std=0x1)::option::Option<Element#509>): vector<Element#509> {
        locals:
            t: (std=0x1)::option::Option<Element#509>,
            vec: vector<Element#509>

        Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
        return move#no-copy vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        locals:
            s: &signer

        return *(std=0x1)::signer::borrow_address<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 =  {
        locals:


        return 2u64
    };
    #[]const EINVALID_UTF8:u64 =  {
        locals:


        return 1u64
    };
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        locals:
            r: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        locals:
            bytes: vector<u8>,
            s: &mut (std=0x1)::string::String

        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        locals:
            s: &(std=0x1)::string::String

        return &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        locals:
            r: &(std=0x1)::string::String,
            s: &(std=0x1)::string::String

        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        locals:
            %#1: bool,
            %#2: &mut (std=0x1)::string::String,
            %#3: u64,
            %#4: u64,
            %#5: &mut (std=0x1)::string::String,
            %#6: u64,
            %#7: u64,
            at: u64,
            bytes: &vector<u8>,
            end: (std=0x1)::string::String,
            front: (std=0x1)::string::String,
            l: u64,
            o: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        (bytes: &vector<u8>) = &copy s.bytes;
        if (copy at <= (std=0x1)::vector::length<u8>(copy bytes))  {
            (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at))
        } else  {
            (%#1: bool) = false
        };
        if (move#last %#1)  {
            pop  = ()
        } else  {
            abort EINVALID_INDEX
        };
        pop  = /*()*/;
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        pop  = /*()*/;
        return /*;()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        locals:
            s: &(std=0x1)::string::String

        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        locals:
            s: &(std=0x1)::string::String

        return (std=0x1)::vector::length<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        locals:
            %#1: bool,
            %#2: bool,
            %#3: bool,
            bytes: &vector<u8>,
            i: u64,
            j: u64,
            l: u64,
            s: &(std=0x1)::string::String

        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        if (copy j <= copy l)  {
            (%#1: bool) = copy i <= copy j
        } else  {
            (%#1: bool) = false
        };
        if (move#last %#1)  {
            (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i))
        } else  {
            (%#2: bool) = false
        };
        if (move#last %#2)  {
            (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j))
        } else  {
            (%#3: bool) = false
        };
        if (move#last %#3)  {
            pop  = ()
        } else  {
            abort EINVALID_INDEX
        };
        pop  = /*()*/;
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        locals:
            %#1: (std=0x1)::option::Option<(std=0x1)::string::String>,
            bytes: vector<u8>

        if ((std=0x1)::string::internal_check_utf8<>(&bytes))  {
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes})
        } else  {
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(())
        };
        return move#last %#1
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        locals:
            bytes: vector<u8>

        if ((std=0x1)::string::internal_check_utf8<>(&bytes))  {
            pop  = ()
        } else  {
            abort EINVALID_UTF8
        };
        pop  = /*()*/;
        return String<>{bytes: copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        locals:
            self: &(std=0x1)::type_name::TypeName

        return &copy self.name
    }
    #[]public native fun get<T#510>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        locals:
            self: (std=0x1)::type_name::TypeName

        return *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 =  {
        locals:


        return 131072u64
    };
    #[]public fun append<Element#511>(lhs: &mut vector<Element#511>, other: vector<Element#511>): () {
        locals:
            lhs: &mut vector<Element#511>,
            other: vector<Element#511>

        pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
        while (! (std=0x1)::vector::is_empty<Element#511>(&other)) {
            pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)))
        };
        pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
        return /*;()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#512>(v: &vector<Element#512>, i: u64): &Element#512;

    #[bytecode_instruction]public native fun borrow_mut<Element#513>(v: &mut vector<Element#513>, i: u64): &mut Element#513;

    #[]public fun contains<Element#514>(v: &vector<Element#514>, e: &Element#514): bool {
        locals:
            e: &Element#514,
            i: u64,
            len: u64,
            v: &vector<Element#514>

        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
        while (copy i < copy len) {
            if ((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e)  {
                return@true
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#515>(v: vector<Element#515>): ();

    #[bytecode_instruction]public native fun empty<Element#516>(): vector<Element#516>;

    #[]public fun index_of<Element#523>(v: &vector<Element#523>, e: &Element#523): (bool, u64) {
        locals:
            e: &Element#523,
            i: u64,
            len: u64,
            v: &vector<Element#523>

        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
        while (copy i < copy len) {
            if ((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e)  {
                return@(true, copy i)
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return (false, 0u64)
    }
    #[]public fun is_empty<Element#524>(v: &vector<Element#524>): bool {
        locals:
            v: &vector<Element#524>

        return (std=0x1)::vector::length<Element#524>(copy v) == 0u64
    }
    #[bytecode_instruction]public native fun length<Element#525>(v: &vector<Element#525>): u64;

    #[bytecode_instruction]public native fun pop_back<Element#528>(v: &mut vector<Element#528>): Element#528;

    #[bytecode_instruction]public native fun push_back<Element#529>(v: &mut vector<Element#529>, e: Element#529): ();

    #[]public fun remove<Element#530>(v: &mut vector<Element#530>, i: u64): Element#530 {
        locals:
            %#1: u64,
            %#2: &mut vector<Element#530>,
            i: u64,
            len: u64,
            v: &mut vector<Element#530>

        (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
        if (copy i >= copy len)  {
            abort EINDEX_OUT_OF_BOUNDS
        } else  {
            pop  = ()
        };
        (len: u64) = copy len - 1u64;
        pop  = /*()*/;
        while (copy i < copy len) {
            (%#2: &mut vector<Element#530>) = copy v;
            (%#1: u64) = copy i;
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i))
        };
        return (std=0x1)::vector::pop_back<Element#530>(copy v)
    }
    #[]public fun reverse<Element#531>(v: &mut vector<Element#531>): () {
        locals:
            back_index: u64,
            front_index: u64,
            len: u64,
            v: &mut vector<Element#531>

        (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
        if (copy len == 0u64)  {
            return@()
        } else  {
            pop  = ()
        };
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        while (copy front_index < copy back_index) {
            pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
            (front_index: u64) = copy front_index + 1u64;
            pop  = /*()*/;
            (back_index: u64) = copy back_index - 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return /*()*/
    }
    #[]public fun singleton<Element#532>(e: Element#532): vector<Element#532> {
        locals:
            e: Element#532,
            v: vector<Element#532>

        (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
        return move#no-copy v
    }
    #[bytecode_instruction]public native fun swap<Element#533>(v: &mut vector<Element#533>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#534>(v: &mut vector<Element#534>, i: u64): Element#534 {
        locals:
            i: u64,
            last_idx: u64,
            v: &mut vector<Element#534>

        if (! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v)))  {
            pop  = ()
        } else  {
            abort EINDEX_OUT_OF_BOUNDS
        };
        pop  = /*()*/;
        (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#534>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#534>(copy v)
    }

}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(copy byte)) 3 else 4

    
    label 3:
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(copy byte)) 3 else 4

    
    label 3:
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 4

    
    label 3:
        pop _ = move#last string;
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 5

    
    label 3:
        pop _ = move#last string;
        return@false

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy string.bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy string.bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last string.bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last string.bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = move#last char;
        return move#last byte
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = move#last char;
        return move#last byte
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: copy byte}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: copy byte}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: move#last byte}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 3 else 2

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: move#last byte}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = move#last string;
        return move#last bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = move#last string;
        return move#last bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = copy byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = copy byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = move#last byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = move#last byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy b <= 127u8
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy b <= 127u8
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last b <= 127u8
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last b <= 127u8
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 3 else 2

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(copy possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(copy possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 5

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 9]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [4, 6]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 2

loop heads:
    loop head: 4. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 9

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 9]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [4, 6]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 2

loop heads:
    loop head: 4. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index

    
    label 13:
        jump 9
After recompute, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 7
    7 => 8
    8 => 13
    13 => 2

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index

    
    label 13:
        jump 9
dead_blocks is 
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 7
    7 => 8
    8 => 13
    13 => 2

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        pop _ = move#last bitvector;
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = move#last index + 1u64;
        jump 4

    
    label 9:
        return move#last index - move#last start_index

    
    label 13:
        pop _ = move#last bitvector;
        jump 9
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 8]
    6 => [9]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    8 <= [5]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 8
    8 => 13

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 8

    
    label 6:
        pop _ = move#last bitvector;
        jump@9

    
    label 8:
        (index: u64) = move#last index + 1u64;
        jump 4

    
    label 9:
        return move#last index - move#last start_index

    
    label 13:
        pop _ = move#last bitvector;
        jump 9
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = copy counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = copy counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = move#last counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: move#last length, bit_field: move#last bit_field}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [5, 6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    5 <= [3]
    6 <= [3]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 2
    2 => 3
    3 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 3 else 2

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 6 else 5

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = move#last counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: move#last length, bit_field: move#last bit_field}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = true;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = true;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *copy elem = false;
        (i: u64) = copy i + 1u64;
        jump 2

    
    label 4:
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = copy i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - copy amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = copy i#1 + 1u64;
        jump 12

    
    label 14:
        jump 15

    
    label 15:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *copy elem = false;
        (i: u64) = copy i + 1u64;
        jump 2

    
    label 4:
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = copy i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - copy amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = copy i#1 + 1u64;
        jump 12

    
    label 14:
        jump 15

    
    label 15:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *move#last elem = false;
        (i: u64) = move#last i + 1u64;
        jump 2

    
    label 4:
        pop _ = move#last bitvector;
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = move#last i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - move#last amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = move#last i#1 + 1u64;
        jump 12

    
    label 14:
        pop _ = move#last bitvector;
        jump 15

    
    label 15:
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *move#last elem = false;
        (i: u64) = move#last i + 1u64;
        jump 2

    
    label 4:
        pop _ = move#last bitvector;
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = move#last i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - move#last amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = move#last i#1 + 1u64;
        jump 12

    
    label 14:
        pop _ = move#last bitvector;
        jump 15

    
    label 15:
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = false;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = false;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy category << 16u8 + copy reason
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy category << 16u8 + copy reason
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last category << 16u8 + move#last reason
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last category << 16u8 + move#last reason
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@copy floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@copy floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@move#last floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (move#last floored_num as u128) + 1u128 << 32u8;
        return (move#last val >> 32u8 as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]

traversal:
    0 => 1
    1 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 3

    
    label 1:
        return@move#last floored_num >> 32u8

    
    label 3:
        (val: u128) = (move#last floored_num as u128) + 4294967296u128;
        return (move#last val >> 32u8 as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = copy numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (copy quotient as u64)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = copy numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (copy quotient as u64)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = move#last numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (move#last quotient as u64)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [8, 9]
    8 => []
    9 => [11, 12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    8 <= [6]
    9 <= [6]
    11 <= [9]
    12 <= [9]

traversal:
    0 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 8
    8 => 9
    9 => 11
    11 => 12

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 3 else 2

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = move#last numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 9 else 8

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 12 else 11

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (move#last quotient as u64)}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: copy value}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: copy value}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: move#last value}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: move#last value}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (copy val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (copy value as u64)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (copy val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (copy value as u64)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (move#last val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (move#last value as u64)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (move#last val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 3 else 2

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (move#last value as u64)}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (copy quotient as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (copy quotient as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (move#last val as u128) << 32u8;
        (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (move#last quotient as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [5, 6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    5 <= [3]
    6 <= [3]

traversal:
    0 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 3 else 2

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (move#last val as u128) << 32u8;
        (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 6 else 5

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (move#last quotient as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (copy product as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (copy product as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
        (product: u128) = move#last unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (move#last product as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
        (product: u128) = move#last unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 3 else 2

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (move#last product as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < copy boundary) 1 else 2

    
    label 1:
        (%#1: u64) = copy floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num);
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < copy boundary) 1 else 2

    
    label 1:
        (%#1: u64) = copy floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num);
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < move#last boundary) 1 else 2

    
    label 1:
        (%#1: u64) = move#last floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 2147483648u64;
        jump_if(*&&num.value < move#last boundary) 1 else 2

    
    label 1:
        (%#1: u64) = move#last floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#485>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#485>((&copy t.vec, 0u64))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#485>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#485>((&copy t.vec, 0u64))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#485>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#485>((&move#last t.vec, 0u64))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#485>(copy t)) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#485>((&move#last t.vec, 0u64))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#486>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#486>((&mut copy t.vec, 0u64))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#486>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#486>((&mut copy t.vec, 0u64))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#486>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#486>((&mut move#last t.vec, 0u64))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#486>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#486>((&mut move#last t.vec, 0u64))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#487>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#487>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: &Element#487) = copy default_ref;
        jump 3

    
    label 2:
        (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#487>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#487>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: &Element#487) = copy default_ref;
        jump 3

    
    label 2:
        (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#487>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#487>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: &Element#487) = move#last default_ref;
        jump 3

    
    label 2:
        pop _ = move#last default_ref;
        (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#487>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#487>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: &Element#487) = move#last default_ref;
        jump 3

    
    label 2:
        pop _ = move#last default_ref;
        (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#488>((&copy t.vec, copy e_ref))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#488>((&copy t.vec, copy e_ref))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#488>((&move#last t.vec, move#last e_ref))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#488>((&move#last t.vec, move#last e_ref))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#489>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#489>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#489>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#489>(&t)) 3 else 2

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#490>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
        (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
        return move#no-copy elem
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#490>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
        (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
        return move#no-copy elem
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#490>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
        (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
        return move#no-copy elem
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#490>(&t)) 3 else 2

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
        (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
        return move#no-copy elem
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#491: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#491: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#491: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#491: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#492>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#492>(&mut copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#492>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#492>(&mut copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#492>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#492>(&mut move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#492>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#492>(&mut move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#493>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#493>((copy vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#493>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#493>((copy vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#493>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#493>((move#last vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        pop _ = move#last vec_ref;
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#493>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref))) 3 else 2

    
    label 2:
        pop _ = move#last vec_ref;
        abort EOPTION_IS_SET

    
    label 3:
        pop  = (std=0x1)::vector::push_back<Element#493>((move#last vec_ref, move#no-copy e));
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#500: copy+drop>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: Element#500: copy+drop) = copy default;
        jump 3

    
    label 2:
        (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#500: copy+drop>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: Element#500: copy+drop) = copy default;
        jump 3

    
    label 2:
        (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#500: copy+drop>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: Element#500: copy+drop) = move#last default;
        jump 3

    
    label 2:
        (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#500: copy+drop>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: Element#500: copy+drop) = move#last default;
        jump 3

    
    label 2:
        (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#501>(&copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#501>(&copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#501>(&move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#501>(&move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#502>(&copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#502>(&copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#502>(&move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#502>(&move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#507>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#507>) = &mut copy t.vec;
        (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#507>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#507>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#507>) = &mut copy t.vec;
        (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#507>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#507>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#507>) = &mut move#last t.vec;
        (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#507>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#507>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#507>) = &mut move#last t.vec;
        (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#507>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#508>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#508>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#508>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#508>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#508>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#508>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#508>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#508>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
        return move#no-copy vec
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
        return move#no-copy vec
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
        return move#no-copy vec
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
        return move#no-copy vec
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(copy s)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(copy s)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(move#last s)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(move#last s)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy s.bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy s.bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last s.bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last s.bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at));
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at));
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
        jump 3

    
    label 2:
        pop _ = move#last bytes;
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        pop _ = move#last s;
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, move#last o));
        pop  = (std=0x1)::string::append<>((&mut front, move#last end));
        *move#last s = move#last front;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [5, 6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    5 <= [3]
    6 <= [3]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
        jump 3

    
    label 2:
        pop _ = move#last bytes;
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 6 else 5

    
    label 5:
        pop _ = move#last s;
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#4: u64)) = (copy s, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), 0u64, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, move#last o));
        pop  = (std=0x1)::string::append<>((&mut front, move#last end));
        *move#last s = move#last front;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&copy s.bytes)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&copy s.bytes)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&move#last s.bytes)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&move#last s.bytes)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= copy l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= copy l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &move#last s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= move#last l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        pop _ = move#last bytes;
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [11, 12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    11 <= [9]
    12 <= [9]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 11
    11 => 12

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &move#last s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= move#last l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 12 else 11

    
    label 11:
        pop _ = move#last bytes;
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: copy bytes}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: copy bytes}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: move#last bytes}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 3 else 2

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: move#last bytes}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy self.name
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy self.name
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last self.name
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last self.name
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#511>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)));
        jump 1

    
    label 3:
        pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#511>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)));
        jump 1

    
    label 3:
        pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#511>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)));
        jump 1

    
    label 3:
        pop _ = move#last lhs;
        pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#511>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)));
        jump 1

    
    label 3:
        pop _ = move#last lhs;
        pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return false
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return false
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return false
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e) 3 else 5

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@true

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return false
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@(true, copy i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return (false, 0u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@(true, copy i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return (false, 0u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@(true, move#last i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return (false, 0u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e) 3 else 5

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@(true, move#last i)

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return (false, 0u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#524>(copy v) == 0u64
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#524>(copy v) == 0u64
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#524>(move#last v) == 0u64
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#524>(move#last v) == 0u64
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#530>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = copy i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#530>(copy v)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#530>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = copy i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#530>(copy v)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#530>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = move#last i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#530>(move#last v)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 3

    
    label 1:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (len: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#530>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = move#last i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#530>(move#last v)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
        (front_index: u64) = copy front_index + 1u64;
        (back_index: u64) = copy back_index - 1u64;
        jump 4

    
    label 6:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
        (front_index: u64) = copy front_index + 1u64;
        (back_index: u64) = copy back_index - 1u64;
        jump 4

    
    label 6:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        pop _ = move#last v;
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
        (front_index: u64) = move#last front_index + 1u64;
        (back_index: u64) = move#last back_index - 1u64;
        jump 4

    
    label 6:
        pop _ = move#last v;
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 3

    
    label 1:
        pop _ = move#last v;
        return@()

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
        (front_index: u64) = move#last front_index + 1u64;
        (back_index: u64) = move#last back_index - 1u64;
        jump 4

    
    label 6:
        pop _ = move#last v;
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
        return move#no-copy v
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
        return move#no-copy v
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
        return move#no-copy v
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
        return move#no-copy v
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#534>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#534>(copy v)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#534>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#534>(copy v)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#534>((copy v, move#last i, move#last last_idx));
        return (std=0x1)::vector::pop_back<Element#534>(move#last v)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v))) 3 else 2

    
    label 2:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#534>((copy v, move#last i, move#last last_idx));
        return (std=0x1)::vector::pop_back<Element#534>(move#last v)
After cfgir: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        byte: u8
    }
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        locals:
            byte: u8,
            i: u64,
            len: u64,
            string: &(std=0x1)::ascii::String

        loop heads:

            1

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
            (i: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
            jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 5

        
        label 3:
            pop _ = move#last string;
            return@false

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
            return true


    }
    #[]public as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        locals:
            string: &(std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return &move#last string.bytes


    }
    #[]public byte(char: (std=0x1)::ascii::Char): u8 {
        locals:
            byte: u8,
            char: (std=0x1)::ascii::Char

        loop heads:


        start=0

        label 0:
            Char<>{byte: (byte: u8)} = move#last char;
            return move#last byte


    }
    #[]public char(byte: u8): (std=0x1)::ascii::Char {
        locals:
            byte: u8

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 3 else 2

        
        label 2:
            abort EINVALID_ASCII_CHARACTER

        
        label 3:
            return Char<>{byte: move#last byte}


    }
    #[]public into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        locals:
            bytes: vector<u8>,
            string: (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            String<>{bytes: (bytes: vector<u8>)} = move#last string;
            return move#last bytes


    }
    #[]public is_printable_char(byte: u8): bool {
        locals:
            %#1: bool,
            byte: u8

        loop heads:


        start=0

        label 0:
            jump_if(copy byte >= 32u8) 1 else 2

        
        label 1:
            (%#1: bool) = move#last byte <= 126u8;
            jump 3

        
        label 2:
            (%#1: bool) = false;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public is_valid_char(b: u8): bool {
        locals:
            b: u8

        loop heads:


        start=0

        label 0:
            return move#last b <= 127u8


    }
    #[]public length(string: &(std=0x1)::ascii::String): u64 {
        locals:
            string: &(std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))


    }
    #[]public pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        locals:
            string: &mut (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}


    }
    #[]public push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        locals:
            char: (std=0x1)::ascii::Char,
            string: &mut (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
            return /*;()*/


    }
    #[]public string(bytes: vector<u8>): (std=0x1)::ascii::String {
        locals:
            bytes: vector<u8>,
            x: (std=0x1)::option::Option<(std=0x1)::ascii::String>

        loop heads:


        start=0

        label 0:
            (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
            jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 3 else 2

        
        label 2:
            abort EINVALID_ASCII_CHARACTER

        
        label 3:
            return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)


    }
    #[]public try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        locals:
            bytes: vector<u8>,
            i: u64,
            len: u64,
            possible_byte: u8

        loop heads:

            1

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
            (i: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
            jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 5

        
        label 3:
            return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
            return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})


    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native to_bytes<MoveValue#483>(v: &MoveValue#483): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        length: u64;
        bit_field: vector<bool>
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        locals:
            bit_index: u64,
            bitvector: &(std=0x1)::bit_vector::BitVector

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))


    }
    #[]public length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)


    }
    #[]public longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector,
            index: u64,
            start_index: u64

        loop heads:

            4

        start=0

        label 0:
            jump_if(copy start_index < *&copy bitvector.length) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (index: u64) = copy start_index;
            jump 4

        
        label 4:
            jump_if(copy index < *&copy bitvector.length) 5 else 13

        
        label 5:
            jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 8

        
        label 6:
            pop _ = move#last bitvector;
            jump@9

        
        label 8:
            (index: u64) = move#last index + 1u64;
            jump 4

        
        label 9:
            return move#last index - move#last start_index

        
        label 13:
            pop _ = move#last bitvector;
            jump 9


    }
    #[]public new(length: u64): (std=0x1)::bit_vector::BitVector {
        locals:
            bit_field: vector<bool>,
            counter: u64,
            length: u64

        loop heads:

            7

        start=0

        label 0:
            jump_if(copy length > 0u64) 3 else 2

        
        label 2:
            abort ELENGTH

        
        label 3:
            jump_if(copy length < MAX_SIZE) 6 else 5

        
        label 5:
            abort ELENGTH

        
        label 6:
            (counter: u64) = 0u64;
            (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
            jump 7

        
        label 7:
            pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            jump_if(copy counter < copy length) 8 else 9

        
        label 8:
            pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
            (counter: u64) = move#last counter + 1u64;
            jump 7

        
        label 9:
            pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
            return BitVector<>{length: move#last length, bit_field: move#last bit_field}


    }
    #[]public set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
            *move#last x = true;
            return /*;()*/


    }
    #[]public shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        locals:
            %#2: &mut (std=0x1)::bit_vector::BitVector,
            %#3: u64,
            amount: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            elem: &mut bool,
            i: u64,
            i#1: u64,
            len: u64

        loop heads:

            2
            6
            12

        start=0

        label 0:
            jump_if(copy amount >= *&copy bitvector.length) 1 else 5

        
        label 1:
            (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
            (i: u64) = 0u64;
            jump 2

        
        label 2:
            jump_if(copy i < copy len) 3 else 4

        
        label 3:
            (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
            *move#last elem = false;
            (i: u64) = move#last i + 1u64;
            jump 2

        
        label 4:
            pop _ = move#last bitvector;
            jump 15

        
        label 5:
            (i#1: u64) = copy amount;
            jump 6

        
        label 6:
            jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

        
        label 7:
            ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
            jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

        
        label 8:
            pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
            jump 10

        
        label 9:
            pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
            jump 10

        
        label 10:
            (i#1: u64) = move#last i#1 + 1u64;
            jump 6

        
        label 11:
            (i#1: u64) = *&copy bitvector.length - move#last amount;
            jump 12

        
        label 12:
            jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

        
        label 13:
            pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
            (i#1: u64) = move#last i#1 + 1u64;
            jump 12

        
        label 14:
            pop _ = move#last bitvector;
            jump 15

        
        label 15:
            return /*()*/


    }
    #[]public unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
            *move#last x = false;
            return /*;()*/


    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public aborted(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((ABORTED, move#last r))


    }
    #[]public already_exists(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))


    }
    #[]public canonical(category: u64, reason: u64): u64 {
        locals:
            category: u64,
            reason: u64

        loop heads:


        start=0

        label 0:
            return move#last category << 16u8 + move#last reason


    }
    #[]public internal(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INTERNAL, move#last r))


    }
    #[]public invalid_argument(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))


    }
    #[]public invalid_state(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))


    }
    #[]public not_found(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))


    }
    #[]public not_implemented(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))


    }
    #[]public out_of_range(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))


    }
    #[]public permission_denied(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))


    }
    #[]public resource_exhausted(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))


    }
    #[]public unauthenticated(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))


    }
    #[]public unavailable(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))


    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32,
            val: u128

        loop heads:


        start=0

        label 0:
            (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
            jump_if(*&&num.value == copy floored_num) 1 else 3

        
        label 1:
            return@move#last floored_num >> 32u8

        
        label 3:
            (val: u128) = (move#last floored_num as u128) + 4294967296u128;
            return (move#last val >> 32u8 as u64)


    }
    #[]public create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: bool,
            denominator: u64,
            numerator: u64,
            quotient: u128,
            scaled_denominator: u128,
            scaled_numerator: u128

        loop heads:


        start=0

        label 0:
            (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
            (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
            jump_if(copy scaled_denominator != 0u128) 3 else 2

        
        label 2:
            abort EDENOMINATOR

        
        label 3:
            (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
            jump_if(copy quotient != 0u128) 4 else 5

        
        label 4:
            (%#1: bool) = true;
            jump 6

        
        label 5:
            (%#1: bool) = move#last numerator == 0u64;
            jump 6

        
        label 6:
            jump_if(move#last %#1) 9 else 8

        
        label 8:
            abort ERATIO_OUT_OF_RANGE

        
        label 9:
            jump_if(copy quotient <= MAX_U64) 12 else 11

        
        label 11:
            abort ERATIO_OUT_OF_RANGE

        
        label 12:
            return FixedPoint32<>{value: (move#last quotient as u64)}


    }
    #[]public create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            value: u64

        loop heads:


        start=0

        label 0:
            return FixedPoint32<>{value: move#last value}


    }
    #[]public create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            val: u64,
            value: u128

        loop heads:


        start=0

        label 0:
            (value: u128) = (move#last val as u128) << 32u8;
            jump_if(copy value <= MAX_U64) 3 else 2

        
        label 2:
            abort ERATIO_OUT_OF_RANGE

        
        label 3:
            return FixedPoint32<>{value: (move#last value as u64)}


    }
    #[]public divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            divisor: (std=0x1)::fixed_point32::FixedPoint32,
            quotient: u128,
            scaled_value: u128,
            val: u64

        loop heads:


        start=0

        label 0:
            jump_if(*&&divisor.value != 0u64) 3 else 2

        
        label 2:
            abort EDIVISION_BY_ZERO

        
        label 3:
            (scaled_value: u128) = (move#last val as u128) << 32u8;
            (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
            jump_if(copy quotient <= MAX_U64) 6 else 5

        
        label 5:
            abort EDIVISION

        
        label 6:
            return (move#last quotient as u64)


    }
    #[]public floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value >> 32u8


    }
    #[]public get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value


    }
    #[]public is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value == 0u64


    }
    #[]public max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            jump_if(*&&num1.value > *&&num2.value) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
            jump 3

        
        label 2:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            jump_if(*&&num1.value < *&&num2.value) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
            jump 3

        
        label 2:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            multiplier: (std=0x1)::fixed_point32::FixedPoint32,
            product: u128,
            unscaled_product: u128,
            val: u64

        loop heads:


        start=0

        label 0:
            (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
            (product: u128) = move#last unscaled_product >> 32u8;
            jump_if(copy product <= MAX_U64) 3 else 2

        
        label 2:
            abort EMULTIPLICATION

        
        label 3:
            return (move#last product as u64)


    }
    #[]public round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            %#1: u64,
            boundary: u64,
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
            (boundary: u64) = copy floored_num + 2147483648u64;
            jump_if(*&&num.value < move#last boundary) 1 else 2

        
        label 1:
            (%#1: u64) = move#last floored_num >> 32u8;
            jump 3

        
        label 2:
            (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
            jump 3

        
        label 3:
            return move#last %#1


    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native sha2_256(data: vector<u8>): vector<u8>;

    #[]public native sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#484> has copy drop store {
        vec: vector<Element#484>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public borrow<Element#485>(t: &(std=0x1)::option::Option<Element#485>): &Element#485 {
        locals:
            t: &(std=0x1)::option::Option<Element#485>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#485>(copy t)) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::borrow<Element#485>((&move#last t.vec, 0u64))


    }
    #[]public borrow_mut<Element#486>(t: &mut (std=0x1)::option::Option<Element#486>): &mut Element#486 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#486>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#486>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::borrow_mut<Element#486>((&mut move#last t.vec, 0u64))


    }
    #[]public borrow_with_default<Element#487>(t: &(std=0x1)::option::Option<Element#487>, default_ref: &Element#487): &Element#487 {
        locals:
            %#1: &Element#487,
            default_ref: &Element#487,
            t: &(std=0x1)::option::Option<Element#487>,
            vec_ref: &vector<Element#487>

        loop heads:


        start=0

        label 0:
            (vec_ref: &vector<Element#487>) = &move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#487>(copy vec_ref)) 1 else 2

        
        label 1:
            pop _ = move#last vec_ref;
            (%#1: &Element#487) = move#last default_ref;
            jump 3

        
        label 2:
            pop _ = move#last default_ref;
            (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((move#last vec_ref, 0u64));
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public contains<Element#488>(t: &(std=0x1)::option::Option<Element#488>, e_ref: &Element#488): bool {
        locals:
            e_ref: &Element#488,
            t: &(std=0x1)::option::Option<Element#488>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::contains<Element#488>((&move#last t.vec, move#last e_ref))


    }
    #[]public destroy_none<Element#489>(t: (std=0x1)::option::Option<Element#489>): () {
        locals:
            t: (std=0x1)::option::Option<Element#489>,
            vec: vector<Element#489>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_none<Element#489>(&t)) 3 else 2

        
        label 2:
            abort EOPTION_IS_SET

        
        label 3:
            Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
            return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)


    }
    #[]public destroy_some<Element#490>(t: (std=0x1)::option::Option<Element#490>): Element#490 {
        locals:
            elem: Element#490,
            t: (std=0x1)::option::Option<Element#490>,
            vec: vector<Element#490>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#490>(&t)) 3 else 2

        
        label 2:
            abort EOPTION_NOT_SET

        
        label 3:
            Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
            (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
            pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
            return move#no-copy elem


    }
    #[]public destroy_with_default<Element#491: drop>(t: (std=0x1)::option::Option<Element#491: drop>, default: Element#491: drop): Element#491: drop {
        locals:
            %#1: Element#491: drop,
            default: Element#491: drop,
            t: (std=0x1)::option::Option<Element#491: drop>,
            vec: vector<Element#491: drop>

        loop heads:


        start=0

        label 0:
            Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
            jump_if((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec))) 1 else 2

        
        label 1:
            (%#1: Element#491: drop) = move#no-copy default;
            jump 3

        
        label 2:
            (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec);
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public extract<Element#492>(t: &mut (std=0x1)::option::Option<Element#492>): Element#492 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#492>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#492>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::pop_back<Element#492>(&mut move#last t.vec)


    }
    #[]public fill<Element#493>(t: &mut (std=0x1)::option::Option<Element#493>, e: Element#493): () {
        locals:
            e: Element#493,
            t: &mut (std=0x1)::option::Option<Element#493>,
            vec_ref: &mut vector<Element#493>

        loop heads:


        start=0

        label 0:
            (vec_ref: &mut vector<Element#493>) = &mut move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref))) 3 else 2

        
        label 2:
            pop _ = move#last vec_ref;
            abort EOPTION_IS_SET

        
        label 3:
            pop  = (std=0x1)::vector::push_back<Element#493>((move#last vec_ref, move#no-copy e));
            return /*()*/


    }
    #[]public get_with_default<Element#500: copy+drop>(t: &(std=0x1)::option::Option<Element#500: copy+drop>, default: Element#500: copy+drop): Element#500: copy+drop {
        locals:
            %#1: Element#500: copy+drop,
            default: Element#500: copy+drop,
            t: &(std=0x1)::option::Option<Element#500: copy+drop>,
            vec_ref: &vector<Element#500: copy+drop>

        loop heads:


        start=0

        label 0:
            (vec_ref: &vector<Element#500: copy+drop>) = &move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref)) 1 else 2

        
        label 1:
            pop _ = move#last vec_ref;
            (%#1: Element#500: copy+drop) = move#last default;
            jump 3

        
        label 2:
            (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((move#last vec_ref, 0u64));
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public is_none<Element#501>(t: &(std=0x1)::option::Option<Element#501>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#501>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::is_empty<Element#501>(&move#last t.vec)


    }
    #[]public is_some<Element#502>(t: &(std=0x1)::option::Option<Element#502>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#502>

        loop heads:


        start=0

        label 0:
            return ! (std=0x1)::vector::is_empty<Element#502>(&move#last t.vec)


    }
    #[]public none<Element#505>(): (std=0x1)::option::Option<Element#505> {
        locals:


        loop heads:


        start=0

        label 0:
            return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}


    }
    #[]public some<Element#506>(e: Element#506): (std=0x1)::option::Option<Element#506> {
        locals:
            e: Element#506

        loop heads:


        start=0

        label 0:
            return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}


    }
    #[]public swap<Element#507>(t: &mut (std=0x1)::option::Option<Element#507>, e: Element#507): Element#507 {
        locals:
            e: Element#507,
            old_value: Element#507,
            t: &mut (std=0x1)::option::Option<Element#507>,
            vec_ref: &mut vector<Element#507>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#507>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            (vec_ref: &mut vector<Element#507>) = &mut move#last t.vec;
            (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
            pop  = (std=0x1)::vector::push_back<Element#507>((move#last vec_ref, move#no-copy e));
            return move#no-copy old_value


    }
    #[]public swap_or_fill<Element#508>(t: &mut (std=0x1)::option::Option<Element#508>, e: Element#508): (std=0x1)::option::Option<Element#508> {
        locals:
            %#1: (std=0x1)::option::Option<Element#508>,
            e: Element#508,
            old_value: (std=0x1)::option::Option<Element#508>,
            t: &mut (std=0x1)::option::Option<Element#508>,
            vec_ref: &mut vector<Element#508>

        loop heads:


        start=0

        label 0:
            (vec_ref: &mut vector<Element#508>) = &mut move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref))) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(());
            jump 3

        
        label 2:
            (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref));
            jump 3

        
        label 3:
            (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
            pop  = (std=0x1)::vector::push_back<Element#508>((move#last vec_ref, move#no-copy e));
            return move#no-copy old_value


    }
    #[]public to_vec<Element#509>(t: (std=0x1)::option::Option<Element#509>): vector<Element#509> {
        locals:
            t: (std=0x1)::option::Option<Element#509>,
            vec: vector<Element#509>

        loop heads:


        start=0

        label 0:
            Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
            return move#no-copy vec


    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public address_of(s: &signer): address {
        locals:
            s: &signer

        loop heads:


        start=0

        label 0:
            return *(std=0x1)::signer::borrow_address<>(move#last s)


    }
    #[]public native borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        locals:
            r: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))


    }
    #[]public append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        locals:
            bytes: vector<u8>,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))


    }
    #[]public bytes(s: &(std=0x1)::string::String): &vector<u8> {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return &move#last s.bytes


    }
    #[]public index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        locals:
            r: &(std=0x1)::string::String,
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))


    }
    #[]public insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        locals:
            %#1: bool,
            %#2: &mut (std=0x1)::string::String,
            %#3: u64,
            %#4: u64,
            %#5: &mut (std=0x1)::string::String,
            %#6: u64,
            %#7: u64,
            at: u64,
            bytes: &vector<u8>,
            end: (std=0x1)::string::String,
            front: (std=0x1)::string::String,
            l: u64,
            o: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            (bytes: &vector<u8>) = &copy s.bytes;
            jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

        
        label 1:
            (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
            jump 3

        
        label 2:
            pop _ = move#last bytes;
            (%#1: bool) = false;
            jump 3

        
        label 3:
            jump_if(move#last %#1) 6 else 5

        
        label 5:
            pop _ = move#last s;
            abort EINVALID_INDEX

        
        label 6:
            (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
            ((%#2: &mut (std=0x1)::string::String), (%#4: u64)) = (copy s, copy at);
            (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), 0u64, move#last %#4));
            ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
            (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
            pop  = (std=0x1)::string::append<>((&mut front, move#last o));
            pop  = (std=0x1)::string::append<>((&mut front, move#last end));
            *move#last s = move#last front;
            return /*;()*/


    }
    #[] native internal_check_utf8(v: &vector<u8>): bool;

    #[] native internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public is_empty(s: &(std=0x1)::string::String): bool {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)


    }
    #[]public length(s: &(std=0x1)::string::String): u64 {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<u8>(&move#last s.bytes)


    }
    #[]public sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        locals:
            %#1: bool,
            %#2: bool,
            %#3: bool,
            bytes: &vector<u8>,
            i: u64,
            j: u64,
            l: u64,
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            (bytes: &vector<u8>) = &move#last s.bytes;
            (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
            jump_if(copy j <= move#last l) 1 else 2

        
        label 1:
            (%#1: bool) = copy i <= copy j;
            jump 3

        
        label 2:
            (%#1: bool) = false;
            jump 3

        
        label 3:
            jump_if(move#last %#1) 4 else 5

        
        label 4:
            (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
            jump 6

        
        label 5:
            (%#2: bool) = false;
            jump 6

        
        label 6:
            jump_if(move#last %#2) 7 else 8

        
        label 7:
            (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
            jump 9

        
        label 8:
            (%#3: bool) = false;
            jump 9

        
        label 9:
            jump_if(move#last %#3) 12 else 11

        
        label 11:
            pop _ = move#last bytes;
            abort EINVALID_INDEX

        
        label 12:
            return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}


    }
    #[]public try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        locals:
            %#1: (std=0x1)::option::Option<(std=0x1)::string::String>,
            bytes: vector<u8>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
            jump 3

        
        label 2:
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public utf8(bytes: vector<u8>): (std=0x1)::string::String {
        locals:
            bytes: vector<u8>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 3 else 2

        
        label 2:
            abort EINVALID_UTF8

        
        label 3:
            return String<>{bytes: move#last bytes}


    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        name: (std=0x1)::ascii::String
    }
    #[]public borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        locals:
            self: &(std=0x1)::type_name::TypeName

        loop heads:


        start=0

        label 0:
            return &move#last self.name


    }
    #[]public native get<T#510>(): (std=0x1)::type_name::TypeName;

    #[]public into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        locals:
            self: (std=0x1)::type_name::TypeName

        loop heads:


        start=0

        label 0:
            return *&&self.name


    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public append<Element#511>(lhs: &mut vector<Element#511>, other: vector<Element#511>): () {
        locals:
            lhs: &mut vector<Element#511>,
            other: vector<Element#511>

        loop heads:

            1

        start=0

        label 0:
            pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
            jump 1

        
        label 1:
            jump_if(! (std=0x1)::vector::is_empty<Element#511>(&other)) 2 else 3

        
        label 2:
            pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)));
            jump 1

        
        label 3:
            pop _ = move#last lhs;
            pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
            return /*;()*/


    }
    #[bytecode_instruction]public native borrow<Element#512>(v: &vector<Element#512>, i: u64): &Element#512;

    #[bytecode_instruction]public native borrow_mut<Element#513>(v: &mut vector<Element#513>, i: u64): &mut Element#513;

    #[]public contains<Element#514>(v: &vector<Element#514>, e: &Element#514): bool {
        locals:
            e: &Element#514,
            i: u64,
            len: u64,
            v: &vector<Element#514>

        loop heads:

            1

        start=0

        label 0:
            (i: u64) = 0u64;
            (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
            jump 1

        
        label 1:
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            jump_if((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e) 3 else 5

        
        label 3:
            pop _ = move#last v;
            pop _ = move#last e;
            return@true

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop _ = move#last v;
            pop _ = move#last e;
            return false


    }
    #[bytecode_instruction]public native destroy_empty<Element#515>(v: vector<Element#515>): ();

    #[bytecode_instruction]public native empty<Element#516>(): vector<Element#516>;

    #[]public index_of<Element#523>(v: &vector<Element#523>, e: &Element#523): (bool, u64) {
        locals:
            e: &Element#523,
            i: u64,
            len: u64,
            v: &vector<Element#523>

        loop heads:

            1

        start=0

        label 0:
            (i: u64) = 0u64;
            (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
            jump 1

        
        label 1:
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            jump_if((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e) 3 else 5

        
        label 3:
            pop _ = move#last v;
            pop _ = move#last e;
            return@(true, move#last i)

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop _ = move#last v;
            pop _ = move#last e;
            return (false, 0u64)


    }
    #[]public is_empty<Element#524>(v: &vector<Element#524>): bool {
        locals:
            v: &vector<Element#524>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<Element#524>(move#last v) == 0u64


    }
    #[bytecode_instruction]public native length<Element#525>(v: &vector<Element#525>): u64;

    #[bytecode_instruction]public native pop_back<Element#528>(v: &mut vector<Element#528>): Element#528;

    #[bytecode_instruction]public native push_back<Element#529>(v: &mut vector<Element#529>, e: Element#529): ();

    #[]public remove<Element#530>(v: &mut vector<Element#530>, i: u64): Element#530 {
        locals:
            %#1: u64,
            %#2: &mut vector<Element#530>,
            i: u64,
            len: u64,
            v: &mut vector<Element#530>

        loop heads:

            4

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
            jump_if(copy i >= copy len) 1 else 3

        
        label 1:
            pop _ = move#last v;
            abort EINDEX_OUT_OF_BOUNDS

        
        label 3:
            (len: u64) = move#last len - 1u64;
            jump 4

        
        label 4:
            jump_if(copy i < copy len) 5 else 6

        
        label 5:
            (%#2: &mut vector<Element#530>) = copy v;
            (%#1: u64) = copy i;
            (i: u64) = move#last i + 1u64;
            pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i));
            jump 4

        
        label 6:
            return (std=0x1)::vector::pop_back<Element#530>(move#last v)


    }
    #[]public reverse<Element#531>(v: &mut vector<Element#531>): () {
        locals:
            back_index: u64,
            front_index: u64,
            len: u64,
            v: &mut vector<Element#531>

        loop heads:

            4

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
            jump_if(copy len == 0u64) 1 else 3

        
        label 1:
            pop _ = move#last v;
            return@()

        
        label 3:
            (front_index: u64) = 0u64;
            (back_index: u64) = move#last len - 1u64;
            jump 4

        
        label 4:
            jump_if(copy front_index < copy back_index) 5 else 6

        
        label 5:
            pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
            (front_index: u64) = move#last front_index + 1u64;
            (back_index: u64) = move#last back_index - 1u64;
            jump 4

        
        label 6:
            pop _ = move#last v;
            return /*()*/


    }
    #[]public singleton<Element#532>(e: Element#532): vector<Element#532> {
        locals:
            e: Element#532,
            v: vector<Element#532>

        loop heads:


        start=0

        label 0:
            (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
            pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
            return move#no-copy v


    }
    #[bytecode_instruction]public native swap<Element#533>(v: &mut vector<Element#533>, i: u64, j: u64): ();

    #[]public swap_remove<Element#534>(v: &mut vector<Element#534>, i: u64): Element#534 {
        locals:
            i: u64,
            last_idx: u64,
            v: &mut vector<Element#534>

        loop heads:


        start=0

        label 0:
            jump_if(! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v))) 3 else 2

        
        label 2:
            pop _ = move#last v;
            abort EINDEX_OUT_OF_BOUNDS

        
        label 3:
            (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
            pop  = (std=0x1)::vector::swap<Element#534>((copy v, move#last i, move#last last_idx));
            return (std=0x1)::vector::pop_back<Element#534>(move#last v)


    }

}
Before expansion: program = ------ Lib Defs: ------

------ Source Defs: ------
no package
std => 0x1
module 0x42::Test {
    use std::vector;public inline fun filter<X: drop>(v: &mut vector<X>, predicate: (&X):bool): () {
        let i = 0;
        while ( {
            spec {spec {invariant forall k in 0 .. i : ! predicate(v[k])}};
            i < vector::length(v)
        }) {
            if (predicate(vector::borrow(v, i)))  {
                vector::swap_remove(v, i);

            } else  {
                i = i + 1;

            };

        }
    }public fun test_filter(): vector<u64> {
        let v = vector[1u64, 2, 3];
        filter(&mut v, |e|*e > 1);
        v
    }spec test_filter{pragma verify = false}
}
After expansion: program = module 0x42::Test {
    #[]source module
    dependency order #0
    #[]public inline fun filter<X: drop>(v: &mut vector<X>, predicate: |&X|bool): () {
        let i = 0;
        while ( {
            spec #0 uses [i, v] applies [predicate];
            i < (std=0x1)::vector::length(v)
        }) {
            if (predicate((std=0x1)::vector::borrow(v, i)))  {
                (std=0x1)::vector::swap_remove(v, i);
                /*()*/
            } else  {
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun test_filter(): vector<u64> {
        let v = vector[1u64, 2, 3];
        0x42::Test::filter(&mut v, |e|*e > 1);
        v
    }
     spec test_filter{pragma verify = false}

}
After naming: program = module 0x42::Test {
    #[]library module
    dependency order #0
    #[]public inline fun filter<X#966: drop>(v: &mut vector<X#966: drop>, predicate: |..|..<&X#966: drop, bool>): () {
        let i = 0;
        while ( {
            spec #0 uses [i, v] applies [predicate];
            i < (std=0x1)::vector::length(v)
        }) {
            if (predicate((std=0x1)::vector::borrow(v, i)))  {
                (std=0x1)::vector::swap_remove(v, i);
                /*()*/
            } else  {
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun test_filter(): vector<u64> {
        let v = vector[1u64, 2, 3];
        0x42::Test::filter(&mut v, |e|*e > 1);
        v
    }

}
After typing: program = module 0x42::Test {
    #[]library module
    dependency order #0
    #[]public fun filter!<X#966: drop>(v: &mut vector<X#966: drop>, predicate: |..|..<&X#966: drop, bool>): () {
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [i (i), predicate (predicate), v (v)];
            copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<X#966: drop>]<X#966: drop>(copy v)
        }) {
            if (predicate((std=0x1)::vector::borrow[parameter_types: [&vector<X#966: drop>, u64]<X#966: drop>((copy v, copy i))))  {
                (std=0x1)::vector::swap_remove[parameter_types: [&mut vector<X#966: drop>, u64]<X#966: drop>((copy v, copy i));
                /*()*/
            } else  {
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun test_filter(): vector<u64> {
        let v: (vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        0x42::Test::filter[parameter_types: [&mut vector<u64>, |..|..<&u64, bool>]<u64>((&mut v, |e|*copy e >@u64 1u64));
        copy v
    }

}
After inlining: program = module 0x42::Test {
    #[]library module
    dependency order #0
    #[]public fun test_filter(): vector<u64> {
        let v: (vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
         {
            let v#0: (&mut vector<u64>) = annot(&mut v: &mut vector<u64>);
            let i#2: (u64) = 0u64;
            while ( {
                spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate]
                lambda predicate -> test_filter_predicate_0: (e: &u64): bool {
                    *copy e >@u64 1u64
                }
                ;
                copy i#2 <@u64 (std=0x1)::vector::length[parameter_types: [&vector<u64>]<u64>(copy v#0)
            }) {
                if ( {
                    let e#3: (&u64) = (std=0x1)::vector::borrow[parameter_types: [&vector<u64>, u64]<u64>((copy v#0, copy i#2));
                    *copy e#3 >@u64 1u64
                })  {
                    (std=0x1)::vector::swap_remove[parameter_types: [&mut vector<u64>, u64]<u64>((copy v#0, copy i#2));
                    /*()*/
                } else  {
                    i#2: (u64) = copy i#2 +@u64 1u64;
                    /*()*/
                };
                /*()*/
            }
        };
        copy v
    }

}
After hlir: program = module 0x42::Test {
    #[]library module
    dependency order #0
    #[]public fun test_filter(): vector<u64> {
        locals:
            %#1: &mut vector<u64>,
            %#2: u64,
            e#3: &u64,
            i#2: u64,
            v: vector<u64>,
            v#0: &mut vector<u64>

        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        while ( {
            pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
            ;
            copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))
        }) {
            ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
            (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
            if (*copy e#3 > 1u64)  {
                pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
                pop  = /*;()*/
            } else  {
                (i#2: u64) = copy i#2 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        };
        pop  = /*()*/;
        return copy v
    }

}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*copy e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = copy i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        return copy v
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*copy e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = copy i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        return copy v
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*move#last e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = move#last i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        pop _ = move#last v#0;
        return move#last v
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#value<u64>[1u64, 2u64, 3u64];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*move#last e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = move#last i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        pop _ = move#last v#0;
        return move#last v
After cfgir: program = module 0x42::Test {
    #[]library module
    dependency order #0
    #[]public test_filter(): vector<u64> {
        locals:
            %#1: &mut vector<u64>,
            %#2: u64,
            e#3: &u64,
            i#2: u64,
            v: vector<u64>,
            v#0: &mut vector<u64>

        loop heads:

            1

        start=0

        label 0:
            (v: vector<u64>) = vector#value<u64>[1u64, 2u64, 3u64];
            (v#0: &mut vector<u64>) = &mut v;
            (i#2: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
            ;
            jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

        
        label 2:
            ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
            (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
            jump_if(*move#last e#3 > 1u64) 3 else 4

        
        label 3:
            pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
            jump 5

        
        label 4:
            (i#2: u64) = move#last i#2 + 1u64;
            jump 5

        
        label 5:
            jump 1

        
        label 6:
            pop _ = move#last v#0;
            return move#last v


    }

}
test run_test::inlining/inline_fun.move ... [0m[32mok[0m

test result: [0m[32mok[0m. 1 passed; 0 failed; 0 ignored; 0 measured; 117 filtered out; finished in 0.29s

     Running unittests src/lib.rs (target/debug/deps/move_compiler_v2-6b9e0c749bc6ef22)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 3 filtered out; finished in 0.00s

     Running tests/testsuite.rs (target/debug/deps/testsuite-666d3b9248c29615)

running 3 tests
After error check, GlobalEnv=module 0x42::M {
    public inline fun f(): u64 {
        spec {
          assert Eq<u256>(1, 1);
        }
        ;
        42
    }
    spec fun $f(): u64 {
        42
    }
} // end 0x42::M
After inlining, GlobalEnv=module 0x42::M {
    spec fun $f(): u64 {
        42
    }
} // end 0x42::M
test test_runner::checking/specs/inline_fun_spec_ok.move  ... [0m[32mok[0m
test test_runner::checking/specs/inline_fun_spec_err.move ... [0m[32mok[0m
After error check, GlobalEnv=module 0x42::Test {
    use std::vector;
    public inline fun filter<X>(v: &mut vector<#0>,predicate: |&#0|bool) {
        {
          let i: u64 = 0;
          loop {
            if spec {
              invariant forall k: num: Range(0, i): Not((predicate)(Index($t0, k)));
            }
            ;
            Lt<u64>(i, vector::length<X>(v)) {
              if (predicate)(vector::borrow<X>(v, i)) {
                vector::swap_remove<X>(v, i);
                Tuple()
              } else {
                i: u64 = Add<u64>(i, 1);
                Tuple()
              };
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public fun test_filter(): vector<u64> {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          Test::filter<u64>(Borrow(Mutable)(v), |e: &u64| Gt<u64>(Deref(e), 1));
          v
        }
    }
    spec fun $filter<X>(v: &mut vector<#0>,predicate: |&#0|bool);
    spec fun $test_filter(): vector<u64>;
} // end 0x42::Test
inlining function `public inline fun filter<X>(v: &mut vector<#0>,predicate: |&#0|bool) {
    {
      let i: u64 = 0;
      loop {
        if spec {
          invariant forall k: num: Range(0, i): Not((predicate)(Index($t0, k)));
        }
        ;
        Lt<u64>(i, vector::length<X>(v)) {
          if (predicate)(vector::borrow<X>(v, i)) {
            vector::swap_remove<X>(v, i);
            Tuple()
          } else {
            i: u64 = Add<u64>(i, 1);
            Tuple()
          };
          Tuple()
        } else {
          break
        }
      }
    }
}
` with args `Borrow(Mutable)(v),|e: &u64| Gt<u64>(Deref(e), 1)`
After inlining, expr is `{
  let (v: &mut vector<u64>) = Tuple(Borrow(Mutable)(v));
  {
    let i: u64 = 0;
    loop {
      if spec {
        invariant forall k: num: Range(0, i): Not((predicate)(Index($t0, k)));
      }
      ;
      Lt<u64>(i, vector::length<u64>(v)) {
        if {
          let (e: &u64) = Tuple(vector::borrow<u64>(v, i));
          Gt<u64>(Deref(e), 1)
        } {
          vector::swap_remove<u64>(v, i);
          Tuple()
        } else {
          i: u64 = Add<u64>(i, 1);
          Tuple()
        };
        Tuple()
      } else {
        break
      }
    }
  }
}`
After inlining, GlobalEnv=module 0x42::Test {
    use std::vector;
    public fun test_filter(): vector<u64> {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let (v: &mut vector<u64>) = Tuple(Borrow(Mutable)(v));
            {
              let i: u64 = 0;
              loop {
                if spec {
                  invariant forall k: num: Range(0, i): Not((predicate)(Index($t0, k)));
                }
                ;
                Lt<u64>(i, vector::length<u64>(v)) {
                  if {
                    let (e: &u64) = Tuple(vector::borrow<u64>(v, i));
                    Gt<u64>(Deref(e), 1)
                  } {
                    vector::swap_remove<u64>(v, i);
                    Tuple()
                  } else {
                    i: u64 = Add<u64>(i, 1);
                    Tuple()
                  };
                  Tuple()
                } else {
                  break
                }
              }
            }
          };
          v
        }
    }
    spec fun $filter<X>(v: &mut vector<#0>,predicate: |&#0|bool);
    spec fun $test_filter(): vector<u64>;
} // end 0x42::Test
test test_runner::checking/inlining/inline_fun.move       ... [0m[32mok[0m

test result: [0m[32mok[0m. 3 passed; 0 failed; 0 ignored; 0 measured; 444 filtered out; finished in 0.04s

     Running unittests src/lib.rs (target/debug/deps/move_compiler_v2_transactional_tests-fc6f4b6371e9fc51)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/tests.rs (target/debug/deps/tests-cd3b38bd3ce07def)

running 1 test
Before expansion: program = ------ Lib Defs: ------

------ Source Defs: ------
no package
std => 0x1
module std::ascii {
    use std::vector;use std::option:: {
        Self, Option
    };const EINVALID_ASCII_CHARACTER:u64 = 0x10000;copy drop storestruct String {
        bytes: vector<u8>
    }spec String{invariant forall i in 0 .. len(bytes) : is_valid_char(bytes[i])}copy drop storestruct Char {
        byte: u8
    }spec Char{invariant is_valid_char(byte)}public fun char(byte: u8): Char {
        assert!(is_valid_char(byte), EINVALID_ASCII_CHARACTER);
        Char{byte: byte}
    }spec char{aborts_if ! is_valid_char(byte)EINVALID_ASCII_CHARACTER}public fun string(bytes: vector<u8>): String {
        let x = try_string(bytes);
        assert!(option::is_some(&x), EINVALID_ASCII_CHARACTER);
        option::destroy_some(x)
    }spec string{aborts_if exists i in 0 .. len(bytes) : ! is_valid_char(bytes[i])EINVALID_ASCII_CHARACTER}public fun try_string(bytes: vector<u8>): Option<String> {
        let len = vector::length(&bytes);
        let i = 0;
        while ( {
            spec {spec {invariant i <= len;
            invariant forall j in 0 .. i : is_valid_char(bytes[j])}};
            i < len
        }) {
            let possible_byte = *vector::borrow(&bytes, i);
            if (! is_valid_char(possible_byte)) return option::none();
            i = i + 1;

        };
        spec {spec {assert i == len;
        assert forall j in 0 .. len : is_valid_char(bytes[j])}};
        option::some(String{bytes: bytes})
    }public fun all_characters_printable(string: &String): bool {
        let len = vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec {spec {invariant i <= len;
            invariant forall j in 0 .. i : is_printable_char(string.bytes[j])}};
            i < len
        }) {
            let byte = *vector::borrow(&string.bytes, i);
            if (! is_printable_char(byte)) return false;
            i = i + 1;

        };
        spec {spec {assert i == len;
        assert forall j in 0 .. len : is_printable_char(string.bytes[j])}};
        true
    }spec all_characters_printable{ensures result ==> forall j in 0 .. len(string.bytes) : is_printable_char(string.bytes[j])}public fun push_char(string: &mut String, char: Char): () {
        vector::push_back(&mut string.bytes, char.byte);

    }spec push_char{ensures len(string.bytes) == len(old(string.bytes)) + 1}public fun pop_char(string: &mut String): Char {
        Char{byte: vector::pop_back(&mut string.bytes)}
    }spec pop_char{ensures len(string.bytes) == len(old(string.bytes)) - 1}public fun length(string: &String): u64 {
        vector::length(as_bytes(string))
    }public fun as_bytes(string: &String): &vector<u8> {
        &string.bytes
    }public fun into_bytes(string: String): vector<u8> {
        let String{bytes: bytes} = string;
        bytes
    }public fun byte(char: Char): u8 {
        let Char{byte: byte} = char;
        byte
    }public fun is_valid_char(b: u8): bool {
        b <= 0x7F
    }public fun is_printable_char(byte: u8): bool {
        byte >= 0x20 && byte <= 0x7E
    }
}no package
std => 0x1
module std::bcs {
    public native fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;
    spec module {}spec module {native fun serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }
}no package
std => 0x1
module std::bit_vector {
    use std::vector;const EINDEX:u64 = 0x20000;const ELENGTH:u64 = 0x20001;const WORD_SIZE:u64 = 1;const MAX_SIZE:u64 = 1024;copy drop storestruct BitVector {
        length: u64;
        bit_field: vector<bool>
    }public fun new(length: u64): BitVector {
        assert!(length > 0, ELENGTH);
        assert!(length < MAX_SIZE, ELENGTH);
        let counter = 0;
        let bit_field = vector::empty();
        while ( {
            spec {spec {invariant counter <= length;
            invariant len(bit_field) == counter}};
            counter < length
        }) {
            vector::push_back(&mut bit_field, false);
            counter = counter + 1;

        };
        spec {spec {assert counter == length;
        assert len(bit_field) == length}};
        BitVector{length: length, bit_field: bit_field}
    }spec new{include NewAbortsIf;
    ensures result.length == length;
    ensures len(result.bit_field) == length}spec schema NewAbortsIf{locallength: u64;
    aborts_if length <= 0ELENGTH;
    aborts_if length >= MAX_SIZEELENGTH}public fun set(bitvector: &mut BitVector, bit_index: u64): () {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;

    }spec set{include SetAbortsIf;
    ensures bitvector.bit_field[bit_index]}spec schema SetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}public fun unset(bitvector: &mut BitVector, bit_index: u64): () {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;

    }spec unset{include UnsetAbortsIf;
    ensures ! bitvector.bit_field[bit_index]}spec schema UnsetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}public fun shift_left(bitvector: &mut BitVector, amount: u64): () {
        if (amount >= bitvector.length)  {
            let len = vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;

            };

        } else  {
            let i = amount;
            while (i < bitvector.length) {
                if (is_index_set(bitvector, i)) set(bitvector, i - amount) else unset(bitvector, i - amount);
                i = i + 1;

            };
            i = bitvector.length - amount;
            while (i < bitvector.length) {
                unset(bitvector, i);
                i = i + 1;

            };

        }
    }public fun is_index_set(bitvector: &BitVector, bit_index: u64): bool {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        *vector::borrow(&bitvector.bit_field, bit_index)
    }spec is_index_set{include IsIndexSetAbortsIf;
    ensures result == bitvector.bit_field[bit_index]}spec schema IsIndexSetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}spec module {fun spec_is_index_set(bitvector: BitVector, bit_index: u64): bool {
        if (bit_index >= length(bitvector))  {
            false
        } else  {
            bitvector.bit_field[bit_index]
        }
    }}public fun length(bitvector: &BitVector): u64 {
        vector::length(&bitvector.bit_field)
    }public fun longest_set_sequence_starting_at(bitvector: &BitVector, start_index: u64): u64 {
        assert!(start_index < bitvector.length, EINDEX);
        let index = start_index;
        while (index < bitvector.length) {
            if (! is_index_set(bitvector, index)) break;
            index = index + 1;

        };
        index - start_index
    }
}no package
std => 0x1
module std::error {
    const INVALID_ARGUMENT:u64 = 0x1;const OUT_OF_RANGE:u64 = 0x2;const INVALID_STATE:u64 = 0x3;const UNAUTHENTICATED:u64 = 0x4;const PERMISSION_DENIED:u64 = 0x5;const NOT_FOUND:u64 = 0x6;const ABORTED:u64 = 0x7;const ALREADY_EXISTS:u64 = 0x8;const RESOURCE_EXHAUSTED:u64 = 0x9;const CANCELLED:u64 = 0xA;const INTERNAL:u64 = 0xB;const NOT_IMPLEMENTED:u64 = 0xC;const UNAVAILABLE:u64 = 0xD;public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }public fun invalid_argument(r: u64): u64 {
        canonical(INVALID_ARGUMENT, r)
    }public fun out_of_range(r: u64): u64 {
        canonical(OUT_OF_RANGE, r)
    }public fun invalid_state(r: u64): u64 {
        canonical(INVALID_STATE, r)
    }public fun unauthenticated(r: u64): u64 {
        canonical(UNAUTHENTICATED, r)
    }public fun permission_denied(r: u64): u64 {
        canonical(PERMISSION_DENIED, r)
    }public fun not_found(r: u64): u64 {
        canonical(NOT_FOUND, r)
    }public fun aborted(r: u64): u64 {
        canonical(ABORTED, r)
    }public fun already_exists(r: u64): u64 {
        canonical(ALREADY_EXISTS, r)
    }public fun resource_exhausted(r: u64): u64 {
        canonical(RESOURCE_EXHAUSTED, r)
    }public fun internal(r: u64): u64 {
        canonical(INTERNAL, r)
    }public fun not_implemented(r: u64): u64 {
        canonical(NOT_IMPLEMENTED, r)
    }public fun unavailable(r: u64): u64 {
        canonical(UNAVAILABLE, r)
    }
}no package
std => 0x1
module std::fixed_point32 {
    copy drop storestruct FixedPoint32 {
        value: u64
    }const MAX_U64:u128 = 18446744073709551615;const EDENOMINATOR:u64 = 0x10001;const EDIVISION:u64 = 0x20002;const EMULTIPLICATION:u64 = 0x20003;const EDIVISION_BY_ZERO:u64 = 0x10004;const ERATIO_OUT_OF_RANGE:u64 = 0x20005;public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64 {
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert!(product <= MAX_U64, EMULTIPLICATION);
        (product as u64)
    }spec multiply_u64{pragma opaque;
    include MultiplyAbortsIf;
    ensures result == spec_multiply_u64(val, multiplier)}spec schema MultiplyAbortsIf{localval: num;
    localmultiplier: FixedPoint32;
    aborts_if spec_multiply_u64(val, multiplier) > MAX_U64EMULTIPLICATION}spec module {fun spec_multiply_u64(val: num, multiplier: FixedPoint32): num {
        val * multiplier.value >> 32
    }}public fun divide_u64(val: u64, divisor: FixedPoint32): u64 {
        assert!(divisor.value != 0, EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / (divisor.value as u128);
        assert!(quotient <= MAX_U64, EDIVISION);
        (quotient as u64)
    }spec divide_u64{pragma opaque;
    include DivideAbortsIf;
    ensures result == spec_divide_u64(val, divisor)}spec schema DivideAbortsIf{localval: num;
    localdivisor: FixedPoint32;
    aborts_if divisor.value == 0EDIVISION_BY_ZERO;
    aborts_if spec_divide_u64(val, divisor) > MAX_U64EDIVISION}spec module {fun spec_divide_u64(val: num, divisor: FixedPoint32): num {
        val << 32 / divisor.value
    }}public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert!(scaled_denominator != 0, EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);
        assert!(quotient <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32{value: (quotient as u64)}
    }spec create_from_rational{pragma verify = false;
    pragma opaque;
    include CreateFromRationalAbortsIf;
    ensures result == spec_create_from_rational(numerator, denominator)}spec schema CreateFromRationalAbortsIf{localnumerator: u64;
    localdenominator: u64;
    let scaled_numerator = (numerator as u128) << 64;
    let scaled_denominator = (denominator as u128) << 32;
    let quotient = scaled_numerator / scaled_denominator;
    aborts_if scaled_denominator == 0EDENOMINATOR;
    aborts_if quotient == 0 && scaled_numerator != 0ERATIO_OUT_OF_RANGE;
    aborts_if quotient > MAX_U64ERATIO_OUT_OF_RANGE}spec module {fun spec_create_from_rational(numerator: num, denominator: num): FixedPoint32 {
        FixedPoint32{value: numerator << 64 / denominator << 32}
    }}public fun create_from_raw_value(value: u64): FixedPoint32 {
        FixedPoint32{value: value}
    }spec create_from_raw_value{pragma opaque;
    aborts_if false;
    ensures result.value == value}public fun get_raw_value(num: FixedPoint32): u64 {
        num.value
    }public fun is_zero(num: FixedPoint32): bool {
        num.value == 0
    }public fun min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }spec min{pragma opaque;
    aborts_if false;
    ensures result == spec_min(num1, num2)}spec module {fun spec_min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }}public fun max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }spec max{pragma opaque;
    aborts_if false;
    ensures result == spec_max(num1, num2)}spec module {fun spec_max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }}public fun create_from_u64(val: u64): FixedPoint32 {
        let value = (val as u128) << 32;
        assert!(value <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32{value: (value as u64)}
    }spec create_from_u64{pragma opaque;
    include CreateFromU64AbortsIf;
    ensures result == spec_create_from_u64(val)}spec schema CreateFromU64AbortsIf{localval: num;
    let scaled_value = (val as u128) << 32;
    aborts_if scaled_value > MAX_U64}spec module {fun spec_create_from_u64(val: num): FixedPoint32 {
        FixedPoint32{value: val << 32}
    }}public fun floor(num: FixedPoint32): u64 {
        num.value >> 32
    }spec floor{pragma opaque;
    aborts_if false;
    ensures result == spec_floor(num)}spec module {fun spec_floor(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional >> 32
        }
    }}public fun ceil(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        if (num.value == floored_num)  {
            return floored_num >> 32
        };
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }spec ceil{pragma verify = false;
    pragma opaque;
    aborts_if false;
    ensures result == spec_ceil(num)}spec module {fun spec_ceil(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let one = 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}public fun round(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if (num.value < boundary)  {
            floored_num >> 32
        } else  {
            ceil(num)
        }
    }spec round{pragma opaque;
    pragma timeout = 120;
    aborts_if false;
    ensures result == spec_round(num)}spec module {fun spec_round(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let boundary = 1 << 32 / 2;
        let one = 1 << 32;
        if (fractional < boundary)  {
            val.value - fractional >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}spec module {}spec module {pragma aborts_if_is_strict}
}no package
std => 0x1
module std::hash {
    public native fun sha2_256(data: vector<u8>): vector<u8>;
    public native fun sha3_256(data: vector<u8>): vector<u8>;

}no package
std => 0x1
module std::option {
    use std::vector;copy drop storestruct Option<Element> {
        vec: vector<Element>
    }spec Option{invariant len(vec) <= 1}const EOPTION_IS_SET:u64 = 0x40000;const EOPTION_NOT_SET:u64 = 0x40001;public fun none<Element>(): Option<Element> {
        Option{vec: vector::empty()}
    }spec none{pragma opaque;
    aborts_if false;
    ensures result == spec_none<Element>()}spec module {fun spec_none<Element>(): Option<Element> {
        Option{vec: vec()}
    }}public fun some<Element>(e: Element): Option<Element> {
        Option{vec: vector::singleton(e)}
    }spec some{pragma opaque;
    aborts_if false;
    ensures result == spec_some(e)}spec module {fun spec_some<Element>(e: Element): Option<Element> {
        Option{vec: vec(e)}
    }}public fun is_none<Element>(t: &Option<Element>): bool {
        vector::is_empty(&t.vec)
    }spec is_none{pragma opaque;
    aborts_if false;
    ensures result == is_none(t)}public fun is_some<Element>(t: &Option<Element>): bool {
        ! vector::is_empty(&t.vec)
    }spec is_some{pragma opaque;
    aborts_if false;
    ensures result == is_some(t)}public fun contains<Element>(t: &Option<Element>, e_ref: &Element): bool {
        vector::contains(&t.vec, e_ref)
    }spec contains{pragma opaque;
    aborts_if false;
    ensures result == spec_contains(t, e_ref)}spec module {fun spec_contains<Element>(t: Option<Element>, e: Element): bool {
        is_some(t) && borrow(t) == e
    }}public fun borrow<Element>(t: &Option<Element>): &Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow(&t.vec, 0)
    }spec borrow{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t)}public fun borrow_with_default<Element>(t: &Option<Element>, default_ref: &Element): &Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default_ref else vector::borrow(vec_ref, 0)
    }spec borrow_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default_ref}public fun get_with_default<Element: copy+drop>(t: &Option<Element>, default: Element): Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default else *vector::borrow(vec_ref, 0)
    }spec get_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default}public fun fill<Element>(t: &mut Option<Element>, e: Element): () {
        let vec_ref = &mut t.vec;
        if (vector::is_empty(vec_ref)) vector::push_back(vec_ref, e) else abort EOPTION_IS_SET
    }spec fill{pragma opaque;
    aborts_if is_some(t)EOPTION_IS_SET;
    ensures is_some(t);
    ensures borrow(t) == e}public fun extract<Element>(t: &mut Option<Element>): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::pop_back(&mut t.vec)
    }spec extract{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(old(t));
    ensures is_none(t)}public fun borrow_mut<Element>(t: &mut Option<Element>): &mut Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow_mut(&mut t.vec, 0)
    }spec borrow_mut{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t);
    ensures t == old(t)}public fun swap<Element>(t: &mut Option<Element>, e: Element): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = vector::pop_back(vec_ref);
        vector::push_back(vec_ref, e);
        old_value
    }spec swap{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(old(t));
    ensures is_some(t);
    ensures borrow(t) == e}public fun swap_or_fill<Element>(t: &mut Option<Element>, e: Element): Option<Element> {
        let vec_ref = &mut t.vec;
        let old_value = if (vector::is_empty(vec_ref)) none() else some(vector::pop_back(vec_ref));
        vector::push_back(vec_ref, e);
        old_value
    }spec swap_or_fill{pragma opaque;
    ensures result == old(t);
    ensures borrow(t) == e}public fun destroy_with_default<Element: drop>(t: Option<Element>, default: Element): Element {
        let Option{vec: vec} = t;
        if (vector::is_empty(&mut vec)) default else vector::pop_back(&mut vec)
    }spec destroy_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default}public fun destroy_some<Element>(t: Option<Element>): Element {
        assert!(is_some(&t), EOPTION_NOT_SET);
        let Option{vec: vec} = t;
        let elem = vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
        elem
    }spec destroy_some{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t)}public fun destroy_none<Element>(t: Option<Element>): () {
        assert!(is_none(&t), EOPTION_IS_SET);
        let Option{vec: vec} = t;
        vector::destroy_empty(vec)
    }spec destroy_none{pragma opaque;
    aborts_if is_some(t)EOPTION_IS_SET}public fun to_vec<Element>(t: Option<Element>): vector<Element> {
        let Option{vec: vec} = t;
        vec
    }spec to_vec{pragma opaque;
    aborts_if false;
    ensures result == t.vec}public inline fun for_each<Element>(o: Option<Element>, f: (Element):()): () {
        if (is_some(&o))  {
            f(destroy_some(o))
        } else  {
            destroy_none(o)
        }
    }public inline fun for_each_ref<Element>(o: &Option<Element>, f: (&Element):()): () {
        if (is_some(o))  {
            f(borrow(o))
        }
    }public inline fun for_each_mut<Element>(o: &mut Option<Element>, f: (&mut Element):()): () {
        if (is_some(o))  {
            f(borrow_mut(o))
        }
    }public inline fun fold<Accumulator, Element>(o: Option<Element>, init: Accumulator, f: (Accumulator, Element):Accumulator): Accumulator {
        if (is_some(&o))  {
            f(init, destroy_some(o))
        } else  {
            destroy_none(o);
            init
        }
    }public inline fun map<Element, OtherElement>(o: Option<Element>, f: (Element):OtherElement): Option<OtherElement> {
        if (is_some(&o))  {
            some(f(destroy_some(o)))
        } else  {
            destroy_none(o);
            none()
        }
    }public inline fun filter<Element: drop>(o: Option<Element>, f: (&Element):bool): Option<Element> {
        if (is_some(&o) && f(borrow(&o)))  {
            o
        } else  {
            none()
        }
    }spec module {}spec module {pragma aborts_if_is_strict}spec schema AbortsIfNone<Element>{localt: Option<Element>;
    aborts_if is_none(t)EOPTION_NOT_SET}
}no package
std => 0x1
module std::signer {
    public native fun borrow_address(s: &signer): &address;
    public fun address_of(s: &signer): address {
        *borrow_address(s)
    }spec module {native fun is_txn_signer(s: signer): bool;
    }spec module {native fun is_txn_signer_addr(a: address): bool;
    }
}no package
std => 0x1
module std::string {
    use std::vector;use std::option:: {
        Self, Option
    };const EINVALID_UTF8:u64 = 1;const EINVALID_INDEX:u64 = 2;copy drop storestruct String {
        bytes: vector<u8>
    }public fun utf8(bytes: vector<u8>): String {
        assert!(internal_check_utf8(&bytes), EINVALID_UTF8);
        String{bytes: bytes}
    }public fun try_utf8(bytes: vector<u8>): Option<String> {
        if (internal_check_utf8(&bytes))  {
            option::some(String{bytes: bytes})
        } else  {
            option::none()
        }
    }public fun bytes(s: &String): &vector<u8> {
        &s.bytes
    }public fun is_empty(s: &String): bool {
        vector::is_empty(&s.bytes)
    }public fun length(s: &String): u64 {
        vector::length(&s.bytes)
    }public fun append(s: &mut String, r: String): () {
        vector::append(&mut s.bytes, r.bytes)
    }public fun append_utf8(s: &mut String, bytes: vector<u8>): () {
        append(s, utf8(bytes))
    }public fun insert(s: &mut String, at: u64, o: String): () {
        let bytes = &s.bytes;
        assert!(at <= vector::length(bytes) && internal_is_char_boundary(bytes, at), EINVALID_INDEX);
        let l = length(s);
        let front = sub_string(s, 0, at);
        let end = sub_string(s, at, l);
        append(&mut front, o);
        append(&mut front, end);
        *s = front;

    }public fun sub_string(s: &String, i: u64, j: u64): String {
        let bytes = &s.bytes;
        let l = vector::length(bytes);
        assert!(j <= l && i <= j && internal_is_char_boundary(bytes, i) && internal_is_char_boundary(bytes, j), EINVALID_INDEX);
        String{bytes: internal_sub_string(bytes, i, j)}
    }public fun index_of(s: &String, r: &String): u64 {
        internal_index_of(&s.bytes, &r.bytes)
    } native fun internal_check_utf8(v: &vector<u8>): bool;
     native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;
     native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;
     native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

}no package
std => 0x1
module std::type_name {
    use std::ascii:: {
        String
    };copy drop storestruct TypeName {
        name: String
    }public native fun get<T>(): TypeName;
    public fun borrow_string(self: &TypeName): &String {
        &self.name
    }public fun into_string(self: TypeName): String {
        self.name
    }
}no package
std => 0x1
module std::vector {
    const EINDEX_OUT_OF_BOUNDS:u64 = 0x20000;#[bytecode_instruction]public native fun empty<Element>(): vector<Element>;
    #[bytecode_instruction]public native fun length<Element>(v: &vector<Element>): u64;
    #[bytecode_instruction]public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;
    #[bytecode_instruction]public native fun push_back<Element>(v: &mut vector<Element>, e: Element): ();
    #[bytecode_instruction]public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;
    #[bytecode_instruction]public native fun pop_back<Element>(v: &mut vector<Element>): Element;
    #[bytecode_instruction]public native fun destroy_empty<Element>(v: vector<Element>): ();
    #[bytecode_instruction]public native fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64): ();
    public fun singleton<Element>(e: Element): vector<Element> {
        let v = empty();
        push_back(&mut v, e);
        v
    }spec singleton{aborts_if false;
    ensures result == vec(e)}public fun reverse<Element>(v: &mut vector<Element>): () {
        let len = length(v);
        if (len == 0) return ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;

        }
    }spec reverse{pragma intrinsic = true}public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>): () {
        reverse(&mut other);
        while (! is_empty(&other))push_back(lhs, pop_back(&mut other));
        destroy_empty(other);

    }spec append{pragma intrinsic = true}spec is_empty{pragma intrinsic = true}public fun is_empty<Element>(v: &vector<Element>): bool {
        length(v) == 0
    }public fun contains<Element>(v: &vector<Element>, e: &Element): bool {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return true;
            i = i + 1;

        };
        false
    }spec contains{pragma intrinsic = true}public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return (true, i);
            i = i + 1;

        };
        (false, 0)
    }spec index_of{pragma intrinsic = true}public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {
        let len = length(v);
        if (i >= len) abort EINDEX_OUT_OF_BOUNDS;
        len = len - 1;
        while (i < len)swap(v, i,  {
            i = i + 1;
            i
        });
        pop_back(v)
    }spec remove{pragma intrinsic = true}public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {
        assert!(! is_empty(v), EINDEX_OUT_OF_BOUNDS);
        let last_idx = length(v) - 1;
        swap(v, i, last_idx);
        pop_back(v)
    }spec swap_remove{pragma intrinsic = true}public inline fun for_each<Element>(v: vector<Element>, f: (Element):()): () {
        reverse(&mut v);
        while (! is_empty(&v)) {
            let e = pop_back(&mut v);
            f(e);

        };

    }public inline fun for_each_ref<Element>(v: &vector<Element>, f: (&Element):()): () {
        let i = 0;
        while (i < length(v)) {
            f(borrow(v, i));
            i = i + 1
        }
    }public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: (&mut Element):()): () {
        let i = 0;
        while (i < length(v)) {
            f(borrow_mut(v, i));
            i = i + 1
        }
    }public inline fun fold<Accumulator, Element>(v: vector<Element>, init: Accumulator, f: (Accumulator, Element):Accumulator): Accumulator {
        let accu = init;
        for_each(v, |elem|accu = f(accu, elem));
        accu
    }public inline fun map<Element, NewElement>(v: vector<Element>, f: (Element):NewElement): vector<NewElement> {
        let result = vector<NewElement>[];
        for_each(v, |elem|push_back(&mut result, f(elem)));
        result
    }public inline fun filter<Element: drop>(v: vector<Element>, p: (&Element):bool): vector<Element> {
        let result = vector<Element>[];
        for_each(v, |elem| {
            if (p(&elem)) push_back(&mut result, elem);

        });
        result
    }spec module {}spec module {fun eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
        len(v1) == len(v2) + 1 && v1[len(v1) - 1] == e && v1[0 .. len(v1) - 1] == v2[0 .. len(v2)]
    };
    fun eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
        len(v) == len(v1) + len(v2) && v[0 .. len(v1)] == v1 && v[len(v1) .. len(v)] == v2
    };
    fun eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1 == v2[1 .. len(v2)]
    };
    fun eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1[0 .. i] == v2[0 .. i] && v1[i .. len(v1)] == v2[i + 1 .. len(v2)]
    }}
}
After expansion: program = module (std=0x1)::ascii {
    #[]source module
    dependency order #2
    neighbor#dependency (std=0x1)::option;
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len = (std=0x1)::vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec #0 uses [i, len, string];
            i < len
        }) {
            let byte = *(std=0x1)::vector::borrow(&string.bytes, i);
            if (! (std=0x1)::ascii::is_printable_char(byte)) return false else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [i, len, string];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char{0#byte: byte} = char;
        byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert!((std=0x1)::ascii::is_valid_char(byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::ascii::Char{0#byte: byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String{0#bytes: bytes} = string;
        bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        byte >= 32 && byte <= 126
    }
    #[]public fun is_valid_char(b: u8): bool {
        b <= 127
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length((std=0x1)::ascii::as_bytes(string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char{0#byte: (std=0x1)::vector::pop_back(&mut string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back(&mut string.bytes, char.byte);
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x = (std=0x1)::ascii::try_string(bytes);
        assert!((std=0x1)::option::is_some(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::option::destroy_some(x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len = (std=0x1)::vector::length(&bytes);
        let i = 0;
        while ( {
            spec #0 uses [bytes, i, len];
            i < len
        }) {
            let possible_byte = *(std=0x1)::vector::borrow(&bytes, i);
            if (! (std=0x1)::ascii::is_valid_char(possible_byte)) return (std=0x1)::option::none() else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [bytes, i, len];
        (std=0x1)::option::some((std=0x1)::ascii::String{0#bytes: bytes})
    }
     spec String{invariant forall i in 0 .. len(bytes) : (std=0x1)::ascii::is_valid_char(bytes[i])}
     spec Char{invariant (std=0x1)::ascii::is_valid_char(byte)}
     spec char{aborts_if ! (std=0x1)::ascii::is_valid_char(byte)(std=0x1)::ascii::EINVALID_ASCII_CHARACTER}
     spec string{aborts_if exists i in 0 .. len(bytes) : ! (std=0x1)::ascii::is_valid_char(bytes[i])(std=0x1)::ascii::EINVALID_ASCII_CHARACTER}
     spec all_characters_printable{ensures result ==> forall j in 0 .. len(string.bytes) : (std=0x1)::ascii::is_printable_char(string.bytes[j])}
     spec push_char{ensures len(string.bytes) == len(old(string.bytes)) + 1}
     spec pop_char{ensures len(string.bytes) == len(old(string.bytes)) - 1}

}
module (std=0x1)::bcs {
    #[]source module
    dependency order #0
    #[]public native fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;

     spec module {}
     spec module {native define serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }

}
module (std=0x1)::bit_vector {
    #[]source module
    dependency order #3
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        *(std=0x1)::vector::borrow(&bitvector.bit_field, bit_index)
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length(&bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert!(start_index < bitvector.length, (std=0x1)::bit_vector::EINDEX);
        let index = start_index;
        while (index < bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set(bitvector, index)) break else ();
            index = index + 1;
            /*()*/
        };
        index - start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert!(length > 0, (std=0x1)::bit_vector::ELENGTH);
        assert!(length < (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH);
        let counter = 0;
        let bit_field = (std=0x1)::vector::empty();
        while ( {
            spec #0 uses [bit_field, counter, length] applies [len];
            counter < length
        }) {
            (std=0x1)::vector::push_back(&mut bit_field, false);
            counter = counter + 1;
            /*()*/
        };
        spec #1 uses [bit_field, counter, length] applies [len];
        (std=0x1)::bit_vector::BitVector{1#bit_field: bit_field, 0#length: length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (amount >= bitvector.length)  {
            let len = (std=0x1)::vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;
                /*()*/
            };
            /*()*/
        } else  {
            let i = amount;
            while (i < bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set(bitvector, i)) (std=0x1)::bit_vector::set(bitvector, i - amount) else (std=0x1)::bit_vector::unset(bitvector, i - amount);
                i = i + 1;
                /*()*/
            };
            i = bitvector.length - amount;
            while (i < bitvector.length) {
                (std=0x1)::bit_vector::unset(bitvector, i);
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;
        /*()*/
    }
     spec new{include (std=0x1)::bit_vector::NewAbortsIf;
    ensures result.length == length;
    ensures len(result.bit_field) == length}
     spec schema NewAbortsIf{locallength: u64;
    aborts_if length <= 0(std=0x1)::bit_vector::ELENGTH;
    aborts_if length >= (std=0x1)::bit_vector::MAX_SIZE(std=0x1)::bit_vector::ELENGTH}
     spec set{include (std=0x1)::bit_vector::SetAbortsIf;
    ensures bitvector.bit_field[bit_index]}
     spec schema SetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec unset{include (std=0x1)::bit_vector::UnsetAbortsIf;
    ensures ! bitvector.bit_field[bit_index]}
     spec schema UnsetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec is_index_set{include (std=0x1)::bit_vector::IsIndexSetAbortsIf;
    ensures result == bitvector.bit_field[bit_index]}
     spec schema IsIndexSetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec module {define spec_is_index_set(bitvector: (std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        if (bit_index >= (std=0x1)::bit_vector::length(bitvector))  {
            false
        } else  {
            bitvector.bit_field[bit_index]
        }
    }}

}
module (std=0x1)::error {
    #[]source module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ABORTED, r)
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ALREADY_EXISTS, r)
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INTERNAL, r)
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_ARGUMENT, r)
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_STATE, r)
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_FOUND, r)
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_IMPLEMENTED, r)
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::OUT_OF_RANGE, r)
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::PERMISSION_DENIED, r)
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::RESOURCE_EXHAUSTED, r)
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAUTHENTICATED, r)
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAVAILABLE, r)
    }

}
module (std=0x1)::fixed_point32 {
    #[]source module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        if (num.value == floored_num)  {
            return floored_num >> 32
        } else ();
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert!(scaled_denominator != 0, (std=0x1)::fixed_point32::EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert!(quotient != 0 || numerator == 0, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        assert!(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value = (val as u128) << 32;
        assert!(value <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert!(divisor.value != 0, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / (divisor.value as u128);
        assert!(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION);
        (quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        num.value >> 32
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        num.value == 0
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert!(product <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION);
        (product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if (num.value < boundary)  {
            floored_num >> 32
        } else  {
            (std=0x1)::fixed_point32::ceil(num)
        }
    }
     spec multiply_u64{pragma opaque;
    include (std=0x1)::fixed_point32::MultiplyAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_multiply_u64(val, multiplier)}
     spec schema MultiplyAbortsIf{localval: num;
    localmultiplier: (std=0x1)::fixed_point32::FixedPoint32;
    aborts_if (std=0x1)::fixed_point32::spec_multiply_u64(val, multiplier) > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::EMULTIPLICATION}
     spec module {define spec_multiply_u64(val: num, multiplier: (std=0x1)::fixed_point32::FixedPoint32): num {
        val * multiplier.value >> 32
    }}
     spec divide_u64{pragma opaque;
    include (std=0x1)::fixed_point32::DivideAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_divide_u64(val, divisor)}
     spec schema DivideAbortsIf{localval: num;
    localdivisor: (std=0x1)::fixed_point32::FixedPoint32;
    aborts_if divisor.value == 0(std=0x1)::fixed_point32::EDIVISION_BY_ZERO;
    aborts_if (std=0x1)::fixed_point32::spec_divide_u64(val, divisor) > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::EDIVISION}
     spec module {define spec_divide_u64(val: num, divisor: (std=0x1)::fixed_point32::FixedPoint32): num {
        val << 32 / divisor.value
    }}
     spec create_from_rational{pragma verify = false;
    pragma opaque;
    include (std=0x1)::fixed_point32::CreateFromRationalAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_create_from_rational(numerator, denominator)}
     spec schema CreateFromRationalAbortsIf{localnumerator: u64;
    localdenominator: u64;
    let scaled_numerator = (numerator as u128) << 64;
    let scaled_denominator = (denominator as u128) << 32;
    let quotient = scaled_numerator / scaled_denominator;
    aborts_if scaled_denominator == 0(std=0x1)::fixed_point32::EDENOMINATOR;
    aborts_if quotient == 0 && scaled_numerator != 0(std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE;
    aborts_if quotient > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE}
     spec module {define spec_create_from_rational(numerator: num, denominator: num): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: numerator << 64 / denominator << 32}
    }}
     spec create_from_raw_value{pragma opaque;
    aborts_if false;
    ensures result.value == value}
     spec min{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_min(num1, num2)}
     spec module {define spec_min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }}
     spec max{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_max(num1, num2)}
     spec module {define spec_max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }}
     spec create_from_u64{pragma opaque;
    include (std=0x1)::fixed_point32::CreateFromU64AbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_create_from_u64(val)}
     spec schema CreateFromU64AbortsIf{localval: num;
    let scaled_value = (val as u128) << 32;
    aborts_if scaled_value > (std=0x1)::fixed_point32::MAX_U64}
     spec module {define spec_create_from_u64(val: num): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: val << 32}
    }}
     spec floor{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_floor(num)}
     spec module {define spec_floor(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional >> 32
        }
    }}
     spec ceil{pragma verify = false;
    pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_ceil(num)}
     spec module {define spec_ceil(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let one = 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}
     spec round{pragma opaque;
    pragma timeout = 120;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_round(num)}
     spec module {define spec_round(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let boundary = 1 << 32 / 2;
        let one = 1 << 32;
        if (fractional < boundary)  {
            val.value - fractional >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}
     spec module {}
     spec module {pragma aborts_if_is_strict}

}
module (std=0x1)::hash {
    #[]source module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]source module
    dependency order #1
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct Option<Element> has copy drop store {
        0#vec: vector<Element>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public fun borrow<Element>(t: &(std=0x1)::option::Option<Element>): &Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow(&t.vec, 0)
    }
    #[]public fun borrow_mut<Element>(t: &mut (std=0x1)::option::Option<Element>): &mut Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow_mut(&mut t.vec, 0)
    }
    #[]public fun borrow_with_default<Element>(t: &(std=0x1)::option::Option<Element>, default_ref: &Element): &Element {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default_ref else (std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun contains<Element>(t: &(std=0x1)::option::Option<Element>, e_ref: &Element): bool {
        (std=0x1)::vector::contains(&t.vec, e_ref)
    }
    #[]public fun destroy_none<Element>(t: (std=0x1)::option::Option<Element>): () {
        assert!((std=0x1)::option::is_none(&t), (std=0x1)::option::EOPTION_IS_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        (std=0x1)::vector::destroy_empty(vec)
    }
    #[]public fun destroy_some<Element>(t: (std=0x1)::option::Option<Element>): Element {
        assert!((std=0x1)::option::is_some(&t), (std=0x1)::option::EOPTION_NOT_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        let elem = (std=0x1)::vector::pop_back(&mut vec);
        (std=0x1)::vector::destroy_empty(vec);
        elem
    }
    #[]public fun destroy_with_default<Element: drop>(t: (std=0x1)::option::Option<Element>, default: Element): Element {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        if ((std=0x1)::vector::is_empty(&mut vec)) default else (std=0x1)::vector::pop_back(&mut vec)
    }
    #[]public fun extract<Element>(t: &mut (std=0x1)::option::Option<Element>): Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::pop_back(&mut t.vec)
    }
    #[]public fun fill<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): () {
        let vec_ref = &mut t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::vector::push_back(vec_ref, e) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public inline fun filter<Element: drop>(o: (std=0x1)::option::Option<Element>, f: |&Element|bool): (std=0x1)::option::Option<Element> {
        if ((std=0x1)::option::is_some(&o) && f((std=0x1)::option::borrow(&o)))  {
            o
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public inline fun fold<Accumulator, Element>(o: (std=0x1)::option::Option<Element>, init: Accumulator, f: |Accumulator, Element|Accumulator): Accumulator {
        if ((std=0x1)::option::is_some(&o))  {
            f(init, (std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o);
            init
        }
    }
    #[]public inline fun for_each<Element>(o: (std=0x1)::option::Option<Element>, f: |Element|()): () {
        if ((std=0x1)::option::is_some(&o))  {
            f((std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o)
        }
    }
    #[]public inline fun for_each_mut<Element>(o: &mut (std=0x1)::option::Option<Element>, f: |&mut Element|()): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow_mut(o))
        } else ()
    }
    #[]public inline fun for_each_ref<Element>(o: &(std=0x1)::option::Option<Element>, f: |&Element|()): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow(o))
        } else ()
    }
    #[]public fun get_with_default<Element: copy+drop>(t: &(std=0x1)::option::Option<Element>, default: Element): Element {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default else *(std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun is_none<Element>(t: &(std=0x1)::option::Option<Element>): bool {
        (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public fun is_some<Element>(t: &(std=0x1)::option::Option<Element>): bool {
        ! (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public inline fun map<Element, OtherElement>(o: (std=0x1)::option::Option<Element>, f: |Element|OtherElement): (std=0x1)::option::Option<OtherElement> {
        if ((std=0x1)::option::is_some(&o))  {
            (std=0x1)::option::some(f((std=0x1)::option::destroy_some(o)))
        } else  {
            (std=0x1)::option::destroy_none(o);
            (std=0x1)::option::none()
        }
    }
    #[]public fun none<Element>(): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::empty()}
    }
    #[]public fun some<Element>(e: Element): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::singleton(e)}
    }
    #[]public fun swap<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = (std=0x1)::vector::pop_back(vec_ref);
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun swap_or_fill<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): (std=0x1)::option::Option<Element> {
        let vec_ref = &mut t.vec;
        let old_value = if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::option::none() else (std=0x1)::option::some((std=0x1)::vector::pop_back(vec_ref));
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun to_vec<Element>(t: (std=0x1)::option::Option<Element>): vector<Element> {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        vec
    }
     spec Option{invariant len(vec) <= 1}
     spec none{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_none<Element>()}
     spec module {define spec_none<Element>(): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: vec()}
    }}
     spec some{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_some(e)}
     spec module {define spec_some<Element>(e: Element): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: vec(e)}
    }}
     spec is_none{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::is_none(t)}
     spec is_some{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::is_some(t)}
     spec contains{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_contains(t, e_ref)}
     spec module {define spec_contains<Element>(t: (std=0x1)::option::Option<Element>, e: Element): bool {
        (std=0x1)::option::is_some(t) && (std=0x1)::option::borrow(t) == e
    }}
     spec borrow{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t)}
     spec borrow_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default_ref}
     spec get_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default}
     spec fill{pragma opaque;
    aborts_if (std=0x1)::option::is_some(t)(std=0x1)::option::EOPTION_IS_SET;
    ensures (std=0x1)::option::is_some(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec extract{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(old(t));
    ensures (std=0x1)::option::is_none(t)}
     spec borrow_mut{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t);
    ensures t == old(t)}
     spec swap{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(old(t));
    ensures (std=0x1)::option::is_some(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec swap_or_fill{pragma opaque;
    ensures result == old(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec destroy_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default}
     spec destroy_some{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t)}
     spec destroy_none{pragma opaque;
    aborts_if (std=0x1)::option::is_some(t)(std=0x1)::option::EOPTION_IS_SET}
     spec to_vec{pragma opaque;
    aborts_if false;
    ensures result == t.vec}
     spec module {}
     spec module {pragma aborts_if_is_strict}
     spec schema AbortsIfNone<Element>{localt: (std=0x1)::option::Option<Element>;
    aborts_if (std=0x1)::option::is_none(t)(std=0x1)::option::EOPTION_NOT_SET}

}
module (std=0x1)::signer {
    #[]source module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address(s)
    }
    #[]public native fun borrow_address(s: &signer): &address;

     spec module {native define is_txn_signer(s: signer): bool;
    }
     spec module {native define is_txn_signer_addr(a: address): bool;
    }

}
module (std=0x1)::string {
    #[]source module
    dependency order #4
    neighbor#dependency (std=0x1)::option;
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append(&mut s.bytes, r.bytes)
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append(s, (std=0x1)::string::utf8(bytes))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of(&s.bytes, &r.bytes)
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes = &s.bytes;
        assert!(at <= (std=0x1)::vector::length(bytes) && (std=0x1)::string::internal_is_char_boundary(bytes, at), (std=0x1)::string::EINVALID_INDEX);
        let l = (std=0x1)::string::length(s);
        let front = (std=0x1)::string::sub_string(s, 0, at);
        let end = (std=0x1)::string::sub_string(s, at, l);
        (std=0x1)::string::append(&mut front, o);
        (std=0x1)::string::append(&mut front, end);
        *s = front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty(&s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length(&s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes = &s.bytes;
        let l = (std=0x1)::vector::length(bytes);
        assert!(j <= l && i <= j && (std=0x1)::string::internal_is_char_boundary(bytes, i) && (std=0x1)::string::internal_is_char_boundary(bytes, j), (std=0x1)::string::EINVALID_INDEX);
        (std=0x1)::string::String{0#bytes: (std=0x1)::string::internal_sub_string(bytes, i, j)}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8(&bytes))  {
            (std=0x1)::option::some((std=0x1)::string::String{0#bytes: bytes})
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert!((std=0x1)::string::internal_check_utf8(&bytes), (std=0x1)::string::EINVALID_UTF8);
        (std=0x1)::string::String{0#bytes: bytes}
    }

}
module (std=0x1)::type_name {
    #[]source module
    dependency order #5
    neighbor#dependency (std=0x1)::ascii;
    uses address (std=0x1);
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &self.name
    }
    #[]public native fun get<T>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        self.name
    }

}
module (std=0x1)::vector {
    #[]source module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>): () {
        (std=0x1)::vector::reverse(&mut other);
        while (! (std=0x1)::vector::is_empty(&other))(std=0x1)::vector::push_back(lhs, (std=0x1)::vector::pop_back(&mut other));
        (std=0x1)::vector::destroy_empty(other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;

    #[bytecode_instruction]public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;

    #[]public fun contains<Element>(v: &vector<Element>, e: &Element): bool {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return true else ();
            i = i + 1;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element>(v: vector<Element>): ();

    #[bytecode_instruction]public native fun empty<Element>(): vector<Element>;

    #[]public inline fun filter<Element: drop>(v: vector<Element>, p: |&Element|bool): vector<Element> {
        let result = vector<Element>[];
        (std=0x1)::vector::for_each(v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back(&mut result, elem) else ();
            /*()*/
        });
        result
    }
    #[]public inline fun fold<Accumulator, Element>(v: vector<Element>, init: Accumulator, f: |Accumulator, Element|Accumulator): Accumulator {
        let accu = init;
        (std=0x1)::vector::for_each(v, |elem|accu = f(accu, elem));
        accu
    }
    #[]public inline fun for_each<Element>(v: vector<Element>, f: |Element|()): () {
        (std=0x1)::vector::reverse(&mut v);
        while (! (std=0x1)::vector::is_empty(&v)) {
            let e = (std=0x1)::vector::pop_back(&mut v);
            f(e);
            /*()*/
        };
        /*()*/
    }
    #[]public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: |&mut Element|()): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow_mut(v, i));
            i = i + 1
        }
    }
    #[]public inline fun for_each_ref<Element>(v: &vector<Element>, f: |&Element|()): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow(v, i));
            i = i + 1
        }
    }
    #[]public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return (true, i) else ();
            i = i + 1;
            /*()*/
        };
        (false, 0)
    }
    #[]public fun is_empty<Element>(v: &vector<Element>): bool {
        (std=0x1)::vector::length(v) == 0
    }
    #[bytecode_instruction]public native fun length<Element>(v: &vector<Element>): u64;

    #[]public inline fun map<Element, NewElement>(v: vector<Element>, f: |Element|NewElement): vector<NewElement> {
        let result = vector<NewElement>[];
        (std=0x1)::vector::for_each(v, |elem|(std=0x1)::vector::push_back(&mut result, f(elem)));
        result
    }
    #[bytecode_instruction]public native fun pop_back<Element>(v: &mut vector<Element>): Element;

    #[bytecode_instruction]public native fun push_back<Element>(v: &mut vector<Element>, e: Element): ();

    #[]public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {
        let len = (std=0x1)::vector::length(v);
        if (i >= len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len = len - 1;
        while (i < len)(std=0x1)::vector::swap(v, i,  {
            i = i + 1;
            i
        });
        (std=0x1)::vector::pop_back(v)
    }
    #[]public fun reverse<Element>(v: &mut vector<Element>): () {
        let len = (std=0x1)::vector::length(v);
        if (len == 0) return () else ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            (std=0x1)::vector::swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;
            /*()*/
        }
    }
    #[]public fun singleton<Element>(e: Element): vector<Element> {
        let v = (std=0x1)::vector::empty();
        (std=0x1)::vector::push_back(&mut v, e);
        v
    }
    #[bytecode_instruction]public native fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {
        assert!(! (std=0x1)::vector::is_empty(v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS);
        let last_idx = (std=0x1)::vector::length(v) - 1;
        (std=0x1)::vector::swap(v, i, last_idx);
        (std=0x1)::vector::pop_back(v)
    }
     spec singleton{aborts_if false;
    ensures result == vec(e)}
     spec reverse{pragma intrinsic = true}
     spec append{pragma intrinsic = true}
     spec is_empty{pragma intrinsic = true}
     spec contains{pragma intrinsic = true}
     spec index_of{pragma intrinsic = true}
     spec remove{pragma intrinsic = true}
     spec swap_remove{pragma intrinsic = true}
     spec module {}
     spec module {define eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
        len(v1) == len(v2) + 1 && v1[len(v1) - 1] == e && v1[0 .. len(v1) - 1] == v2[0 .. len(v2)]
    };
    define eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
        len(v) == len(v1) + len(v2) && v[0 .. len(v1)] == v1 && v[len(v1) .. len(v)] == v2
    };
    define eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1 == v2[1 .. len(v2)]
    };
    define eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1[0 .. i] == v2[0 .. i] && v1[i .. len(v1)] == v2[i + 1 .. len(v2)]
    }}

}
After naming: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len = (std=0x1)::vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec #0 uses [i, len, string];
            i < len
        }) {
            let byte = *(std=0x1)::vector::borrow(&string.bytes, i);
            if (! (std=0x1)::ascii::is_printable_char(byte)) return false else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [i, len, string];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char{0#byte: byte} = char;
        byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert((std=0x1)::ascii::is_valid_char(byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::ascii::Char{0#byte: byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String{0#bytes: bytes} = string;
        bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        byte >= 32 && byte <= 126
    }
    #[]public fun is_valid_char(b: u8): bool {
        b <= 127
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length((std=0x1)::ascii::as_bytes(string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char{0#byte: (std=0x1)::vector::pop_back(&mut string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back(&mut string.bytes, (&*)char.byte);
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x = (std=0x1)::ascii::try_string(bytes);
        assert((std=0x1)::option::is_some(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::option::destroy_some(x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len = (std=0x1)::vector::length(&bytes);
        let i = 0;
        while ( {
            spec #0 uses [bytes, i, len];
            i < len
        }) {
            let possible_byte = *(std=0x1)::vector::borrow(&bytes, i);
            if (! (std=0x1)::ascii::is_valid_char(possible_byte)) return (std=0x1)::option::none() else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [bytes, i, len];
        (std=0x1)::option::some((std=0x1)::ascii::String{0#bytes: bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        *(std=0x1)::vector::borrow(&bitvector.bit_field, bit_index)
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length(&bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert(start_index < (&*)bitvector.length, (std=0x1)::bit_vector::EINDEX);
        let index = start_index;
        while (index < (&*)bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set(bitvector, index)) break else ();
            index = index + 1;
            /*()*/
        };
        index - start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert(length > 0, (std=0x1)::bit_vector::ELENGTH);
        assert(length < (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH);
        let counter = 0;
        let bit_field = (std=0x1)::vector::empty();
        while ( {
            spec #0 uses [bit_field, counter, length] applies [len];
            counter < length
        }) {
            (std=0x1)::vector::push_back(&mut bit_field, false);
            counter = counter + 1;
            /*()*/
        };
        spec #1 uses [bit_field, counter, length] applies [len];
        (std=0x1)::bit_vector::BitVector{1#bit_field: bit_field, 0#length: length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (amount >= (&*)bitvector.length)  {
            let len = (std=0x1)::vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;
                /*()*/
            };
            /*()*/
        } else  {
            let i = amount;
            while (i < (&*)bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set(bitvector, i)) (std=0x1)::bit_vector::set(bitvector, i - amount) else (std=0x1)::bit_vector::unset(bitvector, i - amount);
                i = i + 1;
                /*()*/
            };
            i = (&*)bitvector.length - amount;
            while (i < (&*)bitvector.length) {
                (std=0x1)::bit_vector::unset(bitvector, i);
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ABORTED, r)
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ALREADY_EXISTS, r)
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INTERNAL, r)
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_ARGUMENT, r)
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_STATE, r)
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_FOUND, r)
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_IMPLEMENTED, r)
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::OUT_OF_RANGE, r)
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::PERMISSION_DENIED, r)
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::RESOURCE_EXHAUSTED, r)
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAUTHENTICATED, r)
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAVAILABLE, r)
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        if ((&*)num.value == floored_num)  {
            return floored_num >> 32
        } else ();
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert(scaled_denominator != 0, (std=0x1)::fixed_point32::EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert(quotient != 0 || numerator == 0, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        assert(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value = (val as u128) << 32;
        assert(value <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((&*)divisor.value != 0, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / ((&*)divisor.value as u128);
        assert(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION);
        (quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        (&*)num.value >> 32
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        (&*)num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        (&*)num.value == 0
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if ((&*)num1.value > (&*)num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if ((&*)num1.value < (&*)num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product = (val as u128) * ((&*)multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert(product <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION);
        (product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if ((&*)num.value < boundary)  {
            floored_num >> 32
        } else  {
            (std=0x1)::fixed_point32::ceil(num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#1> has copy drop store {
        0#vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow(&t.vec, 0)
    }
    #[]public fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow_mut(&mut t.vec, 0)
    }
    #[]public fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4 {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default_ref else (std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool {
        (std=0x1)::vector::contains(&t.vec, e_ref)
    }
    #[]public fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): () {
        assert((std=0x1)::option::is_none(&t), (std=0x1)::option::EOPTION_IS_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        (std=0x1)::vector::destroy_empty(vec)
    }
    #[]public fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7 {
        assert((std=0x1)::option::is_some(&t), (std=0x1)::option::EOPTION_NOT_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        let elem = (std=0x1)::vector::pop_back(&mut vec);
        (std=0x1)::vector::destroy_empty(vec);
        elem
    }
    #[]public fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        if ((std=0x1)::vector::is_empty(&mut vec)) default else (std=0x1)::vector::pop_back(&mut vec)
    }
    #[]public fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::pop_back(&mut t.vec)
    }
    #[]public fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): () {
        let vec_ref = &mut t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::vector::push_back(vec_ref, e) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public inline fun filter<Element#11: drop>(o: (std=0x1)::option::Option<Element#11: drop>, f: |..|..<&Element#11: drop, bool>): (std=0x1)::option::Option<Element#11: drop> {
        if ((std=0x1)::option::is_some(&o) && f((std=0x1)::option::borrow(&o)))  {
            o
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public inline fun fold<Accumulator#12, Element#13>(o: (std=0x1)::option::Option<Element#13>, init: Accumulator#12, f: |..|..<Accumulator#12, Element#13, Accumulator#12>): Accumulator#12 {
        if ((std=0x1)::option::is_some(&o))  {
            f(init, (std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o);
            init
        }
    }
    #[]public inline fun for_each<Element#14>(o: (std=0x1)::option::Option<Element#14>, f: |..|..<Element#14, ()>): () {
        if ((std=0x1)::option::is_some(&o))  {
            f((std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o)
        }
    }
    #[]public inline fun for_each_mut<Element#15>(o: &mut (std=0x1)::option::Option<Element#15>, f: |..|..<&mut Element#15, ()>): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow_mut(o))
        } else ()
    }
    #[]public inline fun for_each_ref<Element#16>(o: &(std=0x1)::option::Option<Element#16>, f: |..|..<&Element#16, ()>): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow(o))
        } else ()
    }
    #[]public fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default else *(std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool {
        (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool {
        ! (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public inline fun map<Element#20, OtherElement#21>(o: (std=0x1)::option::Option<Element#20>, f: |..|..<Element#20, OtherElement#21>): (std=0x1)::option::Option<OtherElement#21> {
        if ((std=0x1)::option::is_some(&o))  {
            (std=0x1)::option::some(f((std=0x1)::option::destroy_some(o)))
        } else  {
            (std=0x1)::option::destroy_none(o);
            (std=0x1)::option::none()
        }
    }
    #[]public fun none<Element#22>(): (std=0x1)::option::Option<Element#22> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::empty()}
    }
    #[]public fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::singleton(e)}
    }
    #[]public fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = (std=0x1)::vector::pop_back(vec_ref);
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25> {
        let vec_ref = &mut t.vec;
        let old_value = if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::option::none() else (std=0x1)::option::some((std=0x1)::vector::pop_back(vec_ref));
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26> {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address(s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append(&mut s.bytes, (&*)r.bytes)
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append(s, (std=0x1)::string::utf8(bytes))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of(&s.bytes, &r.bytes)
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes = &s.bytes;
        assert(at <= (std=0x1)::vector::length(bytes) && (std=0x1)::string::internal_is_char_boundary(bytes, at), (std=0x1)::string::EINVALID_INDEX);
        let l = (std=0x1)::string::length(s);
        let front = (std=0x1)::string::sub_string(s, 0, at);
        let end = (std=0x1)::string::sub_string(s, at, l);
        (std=0x1)::string::append(&mut front, o);
        (std=0x1)::string::append(&mut front, end);
        *s = front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty(&s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length(&s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes = &s.bytes;
        let l = (std=0x1)::vector::length(bytes);
        assert(j <= l && i <= j && (std=0x1)::string::internal_is_char_boundary(bytes, i) && (std=0x1)::string::internal_is_char_boundary(bytes, j), (std=0x1)::string::EINVALID_INDEX);
        (std=0x1)::string::String{0#bytes: (std=0x1)::string::internal_sub_string(bytes, i, j)}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8(&bytes))  {
            (std=0x1)::option::some((std=0x1)::string::String{0#bytes: bytes})
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert((std=0x1)::string::internal_check_utf8(&bytes), (std=0x1)::string::EINVALID_UTF8);
        (std=0x1)::string::String{0#bytes: bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &self.name
    }
    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        (&*)self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): () {
        (std=0x1)::vector::reverse(&mut other);
        while (! (std=0x1)::vector::is_empty(&other))(std=0x1)::vector::push_back(lhs, (std=0x1)::vector::pop_back(&mut other));
        (std=0x1)::vector::destroy_empty(other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return true else ();
            i = i + 1;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public inline fun filter<Element#34: drop>(v: vector<Element#34: drop>, p: |..|..<&Element#34: drop, bool>): vector<Element#34: drop> {
        let result = vector<Element#34: drop>[];
        (std=0x1)::vector::for_each(v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back(&mut result, elem) else ();
            /*()*/
        });
        result
    }
    #[]public inline fun fold<Accumulator#35, Element#36>(v: vector<Element#36>, init: Accumulator#35, f: |..|..<Accumulator#35, Element#36, Accumulator#35>): Accumulator#35 {
        let accu = init;
        (std=0x1)::vector::for_each(v, |elem|accu = f(accu, elem));
        accu
    }
    #[]public inline fun for_each<Element#37>(v: vector<Element#37>, f: |..|..<Element#37, ()>): () {
        (std=0x1)::vector::reverse(&mut v);
        while (! (std=0x1)::vector::is_empty(&v)) {
            let e = (std=0x1)::vector::pop_back(&mut v);
            f(e);
            /*()*/
        };
        /*()*/
    }
    #[]public inline fun for_each_mut<Element#38>(v: &mut vector<Element#38>, f: |..|..<&mut Element#38, ()>): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow_mut(v, i));
            i = i + 1
        }
    }
    #[]public inline fun for_each_ref<Element#39>(v: &vector<Element#39>, f: |..|..<&Element#39, ()>): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow(v, i));
            i = i + 1
        }
    }
    #[]public fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64) {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return (true, i) else ();
            i = i + 1;
            /*()*/
        };
        (false, 0)
    }
    #[]public fun is_empty<Element#41>(v: &vector<Element#41>): bool {
        (std=0x1)::vector::length(v) == 0
    }
    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[]public inline fun map<Element#43, NewElement#44>(v: vector<Element#43>, f: |..|..<Element#43, NewElement#44>): vector<NewElement#44> {
        let result = vector<NewElement#44>[];
        (std=0x1)::vector::for_each(v, |elem|(std=0x1)::vector::push_back(&mut result, f(elem)));
        result
    }
    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47 {
        let len = (std=0x1)::vector::length(v);
        if (i >= len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len = len - 1;
        while (i < len)(std=0x1)::vector::swap(v, i,  {
            i = i + 1;
            i
        });
        (std=0x1)::vector::pop_back(v)
    }
    #[]public fun reverse<Element#48>(v: &mut vector<Element#48>): () {
        let len = (std=0x1)::vector::length(v);
        if (len == 0) return () else ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            (std=0x1)::vector::swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;
            /*()*/
        }
    }
    #[]public fun singleton<Element#49>(e: Element#49): vector<Element#49> {
        let v = (std=0x1)::vector::empty();
        (std=0x1)::vector::push_back(&mut v, e);
        v
    }
    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51 {
        assert(! (std=0x1)::vector::is_empty(v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS);
        let last_idx = (std=0x1)::vector::length(v) - 1;
        (std=0x1)::vector::swap(v, i, last_idx);
        (std=0x1)::vector::pop_back(v)
    }

}
After typing: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536u64;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy string.bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [i (i), len (len), string (string)];
            copy i <@u64 copy len
        }) {
            let byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char[parameter_types: [u8]<>(copy byte)) return false else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 uses [i (i), len (len), string (string)];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char<>{0#byte: byte}: ((std=0x1)::ascii::Char) = copy char;
        copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert(((std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::ascii::Char<>{(0#byte:u8): copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String<>{0#bytes: bytes}: ((std=0x1)::ascii::String) = copy string;
        copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        copy byte >=@u8 32u8 &&@bool copy byte <=@u8 126u8
    }
    #[]public fun is_valid_char(b: u8): bool {
        copy b <=@u8 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>((std=0x1)::ascii::as_bytes[parameter_types: [&(std=0x1)::ascii::String]<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char<>{(0#byte:u8): (std=0x1)::vector::pop_back[parameter_types: [&mut vector<u8>]<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<u8>, u8]<u8>((&mut copy string.bytes, *&&char.byte));
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x: ((std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string[parameter_types: [vector<u8>]<>(copy bytes);
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [bytes (bytes), i (i), len (len)];
            copy i <@u64 copy len
        }) {
            let possible_byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy possible_byte)) return (std=0x1)::option::none<(std=0x1)::ascii::String>(()) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 uses [bytes (bytes), i (i), len (len)];
        (std=0x1)::option::some[parameter_types: [(std=0x1)::ascii::String]<(std=0x1)::ascii::String>((std=0x1)::ascii::String<>{(0#bytes:vector<u8>): copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072u64;
    #[]const ELENGTH:u64 = 131073u64;
    #[]const MAX_SIZE:u64 = 1024u64;
    #[]const WORD_SIZE:u64 = 1u64;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        *(std=0x1)::vector::borrow[parameter_types: [&vector<bool>, u64]<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert((copy start_index <@u64 *&copy bitvector.length, (std=0x1)::bit_vector::EINDEX));
        let index: (u64) = copy start_index;
        while (copy index <@u64 *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy index))) break else ();
            index: (u64) = copy index +@u64 1u64;
            /*()*/
        };
        copy index -@u64 copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert((copy length >@u64 0u64, (std=0x1)::bit_vector::ELENGTH));
        assert((copy length <@u64 (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH));
        let counter: (u64) = 0u64;
        let bit_field: (vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            spec #0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter <@u64 copy length
        }) {
            (std=0x1)::vector::push_back[parameter_types: [&mut vector<bool>, bool]<bool>((&mut bit_field, false));
            counter: (u64) = copy counter +@u64 1u64;
            /*()*/
        };
        spec #1 uses [bit_field (bit_field), counter (counter), length (length)];
        (std=0x1)::bit_vector::BitVector<>{(1#bit_field:vector<bool>): copy bit_field, (0#length:u64): copy length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (copy amount >=@u64 *&copy bitvector.length)  {
            let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field);
            let i: (u64) = 0u64;
            while (copy i <@u64 copy len) {
                let elem: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        } else  {
            let i: (u64) = copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i))) (std=0x1)::bit_vector::set[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount)) else (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            i: (u64) = *&copy bitvector.length -@u64 copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7u64;
    #[]const ALREADY_EXISTS:u64 = 8u64;
    #[]const CANCELLED:u64 = 10u64;
    #[]const INTERNAL:u64 = 11u64;
    #[]const INVALID_ARGUMENT:u64 = 1u64;
    #[]const INVALID_STATE:u64 = 3u64;
    #[]const NOT_FOUND:u64 = 6u64;
    #[]const NOT_IMPLEMENTED:u64 = 12u64;
    #[]const OUT_OF_RANGE:u64 = 2u64;
    #[]const PERMISSION_DENIED:u64 = 5u64;
    #[]const RESOURCE_EXHAUSTED:u64 = 9u64;
    #[]const UNAUTHENTICATED:u64 = 4u64;
    #[]const UNAVAILABLE:u64 = 13u64;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        copy category <<@u64 16u8 +@u64 copy reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537u64;
    #[]const EDIVISION:u64 = 131074u64;
    #[]const EDIVISION_BY_ZERO:u64 = 65540u64;
    #[]const EMULTIPLICATION:u64 = 131075u64;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077u64;
    #[]const MAX_U64:u128 = 18446744073709551615u128;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        if (*&&num.value ==@u64 copy floored_num)  {
            return copy floored_num >>@u64 32u8
        } else ();
        let val: (u128) = (copy floored_num as u128) +@u128 1u128 <<@u128 32u8;
        (copy val >>@u128 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator: (u128) = (copy numerator as u128) <<@u128 64u8;
        let scaled_denominator: (u128) = (copy denominator as u128) <<@u128 32u8;
        assert((copy scaled_denominator !=@u128 0u128, (std=0x1)::fixed_point32::EDENOMINATOR));
        let quotient: (u128) = copy scaled_numerator /@u128 copy scaled_denominator;
        assert((copy quotient !=@u128 0u128 ||@bool copy numerator ==@u64 0u64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value: (u128) = (copy val as u128) <<@u128 32u8;
        assert((copy value <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((*&&divisor.value !=@u64 0u64, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO));
        let scaled_value: (u128) = (copy val as u128) <<@u128 32u8;
        let quotient: (u128) = copy scaled_value /@u128 (*&&divisor.value as u128);
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION));
        (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value >>@u64 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        *&&num.value ==@u64 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value >@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value <@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product: (u128) = (copy val as u128) *@u128 (*&&multiplier.value as u128);
        let product: (u128) = copy unscaled_product >>@u128 32u8;
        assert((copy product <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION));
        (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        let boundary: (u64) = copy floored_num +@u64 1u64 <<@u64 32u8 /@u64 2u64;
        if (*&&num.value <@u64 copy boundary)  {
            copy floored_num >>@u64 32u8
        } else  {
            (std=0x1)::fixed_point32::ceil[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#1> has copy drop store {
        0#vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144u64;
    #[]const EOPTION_NOT_SET:u64 = 262145u64;
    #[]public fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#2>]<Element#2>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow[parameter_types: [&vector<Element#2>, u64]<Element#2>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#3>]<Element#3>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#3>, u64]<Element#3>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4 {
        let vec_ref: (&vector<Element#4>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#4>]<Element#4>(copy vec_ref)) copy default_ref else (std=0x1)::vector::borrow[parameter_types: [&vector<Element#4>, u64]<Element#4>((copy vec_ref, 0u64))
    }
    #[]public fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool {
        (std=0x1)::vector::contains[parameter_types: [&vector<Element#5>, &Element#5]<Element#5>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): () {
        assert(((std=0x1)::option::is_none[parameter_types: [&(std=0x1)::option::Option<Element#6>]<Element#6>(&t), (std=0x1)::option::EOPTION_IS_SET));
        let (std=0x1)::option::Option<Element#6>{0#vec: vec}: ((std=0x1)::option::Option<Element#6>) = move t;
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#6>]<Element#6>(move vec)
    }
    #[]public fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#7>]<Element#7>(&t), (std=0x1)::option::EOPTION_NOT_SET));
        let (std=0x1)::option::Option<Element#7>{0#vec: vec}: ((std=0x1)::option::Option<Element#7>) = move t;
        let elem: (Element#7) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#7>]<Element#7>(&mut vec);
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#7>]<Element#7>(move vec);
        move elem
    }
    #[]public fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop {
        let (std=0x1)::option::Option<Element#8: drop>{0#vec: vec}: ((std=0x1)::option::Option<Element#8: drop>) = move t;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#8: drop>]<Element#8: drop>(&mut vec)) move default else (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#8: drop>]<Element#8: drop>(&mut vec)
    }
    #[]public fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#9>]<Element#9>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#9>]<Element#9>(&mut copy t.vec)
    }
    #[]public fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): () {
        let vec_ref: (&mut vector<Element#10>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#10>]<Element#10>(copy vec_ref)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#10>, Element#10]<Element#10>((copy vec_ref, move e)) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public fun filter!<Element#11: drop>(o: (std=0x1)::option::Option<Element#11: drop>, f: |..|..<&Element#11: drop, bool>): (std=0x1)::option::Option<Element#11: drop> {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#11: drop>]<Element#11: drop>(&o) &&@bool f((std=0x1)::option::borrow[parameter_types: [&(std=0x1)::option::Option<Element#11: drop>]<Element#11: drop>(&o)))  {
            move o
        } else  {
            (std=0x1)::option::none<Element#11: drop>(())
        }
    }
    #[]public fun fold!<Accumulator#12, Element#13>(o: (std=0x1)::option::Option<Element#13>, init: Accumulator#12, f: |..|..<Accumulator#12, Element#13, Accumulator#12>): Accumulator#12 {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#13>]<Element#13>(&o))  {
            f((move init, (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#13>]<Element#13>(move o)))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#13>]<Element#13>(move o);
            move init
        }
    }
    #[]public fun for_each!<Element#14>(o: (std=0x1)::option::Option<Element#14>, f: |..|..<Element#14, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#14>]<Element#14>(&o))  {
            f((std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#14>]<Element#14>(move o))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#14>]<Element#14>(move o)
        }
    }
    #[]public fun for_each_mut!<Element#15>(o: &mut (std=0x1)::option::Option<Element#15>, f: |..|..<&mut Element#15, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#15>]<Element#15>(copy o))  {
            f((std=0x1)::option::borrow_mut[parameter_types: [&mut (std=0x1)::option::Option<Element#15>]<Element#15>(copy o))
        } else ()
    }
    #[]public fun for_each_ref!<Element#16>(o: &(std=0x1)::option::Option<Element#16>, f: |..|..<&Element#16, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#16>]<Element#16>(copy o))  {
            f((std=0x1)::option::borrow[parameter_types: [&(std=0x1)::option::Option<Element#16>]<Element#16>(copy o))
        } else ()
    }
    #[]public fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop {
        let vec_ref: (&vector<Element#17: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#17: copy+drop>]<Element#17: copy+drop>(copy vec_ref)) copy default else *(std=0x1)::vector::borrow[parameter_types: [&vector<Element#17: copy+drop>, u64]<Element#17: copy+drop>((copy vec_ref, 0u64))
    }
    #[]public fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#18>]<Element#18>(&copy t.vec)
    }
    #[]public fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool {
        ! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#19>]<Element#19>(&copy t.vec)
    }
    #[]public fun map!<Element#20, OtherElement#21>(o: (std=0x1)::option::Option<Element#20>, f: |..|..<Element#20, OtherElement#21>): (std=0x1)::option::Option<OtherElement#21> {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#20>]<Element#20>(&o))  {
            (std=0x1)::option::some[parameter_types: [OtherElement#21]<OtherElement#21>(f((std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#20>]<Element#20>(move o)))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#20>]<Element#20>(move o);
            (std=0x1)::option::none<OtherElement#21>(())
        }
    }
    #[]public fun none<Element#22>(): (std=0x1)::option::Option<Element#22> {
        (std=0x1)::option::Option<Element#22>{(0#vec:vector<Element#22>): (std=0x1)::vector::empty<Element#22>(())}
    }
    #[]public fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23> {
        (std=0x1)::option::Option<Element#23>{(0#vec:vector<Element#23>): (std=0x1)::vector::singleton[parameter_types: [Element#23]<Element#23>(move e)}
    }
    #[]public fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#24>]<Element#24>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        let vec_ref: (&mut vector<Element#24>) = &mut copy t.vec;
        let old_value: (Element#24) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#24>]<Element#24>(copy vec_ref);
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#24>, Element#24]<Element#24>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25> {
        let vec_ref: (&mut vector<Element#25>) = &mut copy t.vec;
        let old_value: ((std=0x1)::option::Option<Element#25>) = if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#25>]<Element#25>(copy vec_ref)) (std=0x1)::option::none<Element#25>(()) else (std=0x1)::option::some[parameter_types: [Element#25]<Element#25>((std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#25>]<Element#25>(copy vec_ref));
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#25>, Element#25]<Element#25>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26> {
        let (std=0x1)::option::Option<Element#26>{0#vec: vec}: ((std=0x1)::option::Option<Element#26>) = move t;
        move vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address[parameter_types: [&signer]<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2u64;
    #[]const EINVALID_UTF8:u64 = 1u64;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append[parameter_types: [&mut vector<u8>, vector<u8>]<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((copy s, (std=0x1)::string::utf8[parameter_types: [vector<u8>]<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of[parameter_types: [&vector<u8>, &vector<u8>]<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes: (&vector<u8>) = &copy s.bytes;
        assert((copy at <=@u64 (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy at)), (std=0x1)::string::EINVALID_INDEX));
        let l: (u64) = (std=0x1)::string::length[parameter_types: [&(std=0x1)::string::String]<>(copy s);
        let front: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, 0u64, copy at));
        let end: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, copy at, copy l));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy o));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy end));
        *copy s = copy front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes: (&vector<u8>) = &copy s.bytes;
        let l: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes);
        assert((copy j <=@u64 copy l &&@bool copy i <=@u64 copy j &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy i)) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy j)), (std=0x1)::string::EINVALID_INDEX));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): (std=0x1)::string::internal_sub_string[parameter_types: [&vector<u8>, u64, u64]<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes))  {
            (std=0x1)::option::some[parameter_types: [(std=0x1)::string::String]<(std=0x1)::string::String>((std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes})
        } else  {
            (std=0x1)::option::none<(std=0x1)::string::String>(())
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert(((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes), (std=0x1)::string::EINVALID_UTF8));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &copy self.name
    }
    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072u64;
    #[]public fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#28>]<Element#28>(&mut other);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#28>]<Element#28>(&other))(std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#28>, Element#28]<Element#28>((copy lhs, (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#28>]<Element#28>(&mut other)));
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#28>]<Element#28>(move other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#31>]<Element#31>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#31>, u64]<Element#31>((copy v, copy i)) ==@&Element#31 copy e) return true else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public fun filter!<Element#34: drop>(v: vector<Element#34: drop>, p: |..|..<&Element#34: drop, bool>): vector<Element#34: drop> {
        let result: (vector<Element#34: drop>) = vector#0<Element#34: drop>[()];
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#34: drop>, |..|..<Element#34: drop, ()>]<Element#34: drop>((move v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#34: drop>, Element#34: drop]<Element#34: drop>((&mut result, move elem)) else ();
            /*()*/
        }));
        move result
    }
    #[]public fun fold!<Accumulator#35, Element#36>(v: vector<Element#36>, init: Accumulator#35, f: |..|..<Accumulator#35, Element#36, Accumulator#35>): Accumulator#35 {
        let accu: (Accumulator#35) = move init;
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#36>, |..|..<Element#36, ()>]<Element#36>((move v, |elem|accu: (Accumulator#35) = f((move accu, move elem))));
        move accu
    }
    #[]public fun for_each!<Element#37>(v: vector<Element#37>, f: |..|..<Element#37, ()>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#37>]<Element#37>(&mut v);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#37>]<Element#37>(&v)) {
            let e: (Element#37) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#37>]<Element#37>(&mut v);
            f(move e);
            /*()*/
        };
        /*()*/
    }
    #[]public fun for_each_mut!<Element#38>(v: &mut vector<Element#38>, f: |..|..<&mut Element#38, ()>): () {
        let i: (u64) = 0u64;
        while (copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<Element#38>]<Element#38>(copy v)) {
            f((std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#38>, u64]<Element#38>((copy v, copy i)));
            i: (u64) = copy i +@u64 1u64
        }
    }
    #[]public fun for_each_ref!<Element#39>(v: &vector<Element#39>, f: |..|..<&Element#39, ()>): () {
        let i: (u64) = 0u64;
        while (copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<Element#39>]<Element#39>(copy v)) {
            f((std=0x1)::vector::borrow[parameter_types: [&vector<Element#39>, u64]<Element#39>((copy v, copy i)));
            i: (u64) = copy i +@u64 1u64
        }
    }
    #[]public fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64) {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#40>]<Element#40>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#40>, u64]<Element#40>((copy v, copy i)) ==@&Element#40 copy e) return (true, copy i) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        (false, 0u64)
    }
    #[]public fun is_empty<Element#41>(v: &vector<Element#41>): bool {
        (std=0x1)::vector::length[parameter_types: [&vector<Element#41>]<Element#41>(copy v) ==@u64 0u64
    }
    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[]public fun map!<Element#43, NewElement#44>(v: vector<Element#43>, f: |..|..<Element#43, NewElement#44>): vector<NewElement#44> {
        let result: (vector<NewElement#44>) = vector#0<NewElement#44>[()];
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#43>, |..|..<Element#43, ()>]<Element#43>((move v, |elem|(std=0x1)::vector::push_back[parameter_types: [&mut vector<NewElement#44>, NewElement#44]<NewElement#44>((&mut result, f(move elem)))));
        move result
    }
    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47 {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#47>]<Element#47>(copy v);
        if (copy i >=@u64 copy len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len: (u64) = copy len -@u64 1u64;
        while (copy i <@u64 copy len)(std=0x1)::vector::swap[parameter_types: [&mut vector<Element#47>, u64, u64]<Element#47>((copy v, copy i,  {
            i: (u64) = copy i +@u64 1u64;
            copy i
        }));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#47>]<Element#47>(copy v)
    }
    #[]public fun reverse<Element#48>(v: &mut vector<Element#48>): () {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#48>]<Element#48>(copy v);
        if (copy len ==@u64 0u64) return () else ();
        let front_index: (u64) = 0u64;
        let back_index: (u64) = copy len -@u64 1u64;
        while (copy front_index <@u64 copy back_index) {
            (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#48>, u64, u64]<Element#48>((copy v, copy front_index, copy back_index));
            front_index: (u64) = copy front_index +@u64 1u64;
            back_index: (u64) = copy back_index -@u64 1u64;
            /*()*/
        }
    }
    #[]public fun singleton<Element#49>(e: Element#49): vector<Element#49> {
        let v: (vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#49>, Element#49]<Element#49>((&mut v, move e));
        move v
    }
    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51 {
        assert((! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#51>]<Element#51>(copy v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS));
        let last_idx: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#51>]<Element#51>(copy v) -@u64 1u64;
        (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#51>, u64, u64]<Element#51>((copy v, copy i, copy last_idx));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#51>]<Element#51>(copy v)
    }

}
After inlining: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536u64;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy string.bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            copy i <@u64 copy len
        }) {
            let byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char[parameter_types: [u8]<>(copy byte)) return false else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char<>{0#byte: byte}: ((std=0x1)::ascii::Char) = copy char;
        copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert(((std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::ascii::Char<>{(0#byte:u8): copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String<>{0#bytes: bytes}: ((std=0x1)::ascii::String) = copy string;
        copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        copy byte >=@u8 32u8 &&@bool copy byte <=@u8 126u8
    }
    #[]public fun is_valid_char(b: u8): bool {
        copy b <=@u8 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>((std=0x1)::ascii::as_bytes[parameter_types: [&(std=0x1)::ascii::String]<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char<>{(0#byte:u8): (std=0x1)::vector::pop_back[parameter_types: [&mut vector<u8>]<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<u8>, u8]<u8>((&mut copy string.bytes, *&&char.byte));
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x: ((std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string[parameter_types: [vector<u8>]<>(copy bytes);
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            copy i <@u64 copy len
        }) {
            let possible_byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy possible_byte)) return (std=0x1)::option::none<(std=0x1)::ascii::String>(()) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        (std=0x1)::option::some[parameter_types: [(std=0x1)::ascii::String]<(std=0x1)::ascii::String>((std=0x1)::ascii::String<>{(0#bytes:vector<u8>): copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072u64;
    #[]const ELENGTH:u64 = 131073u64;
    #[]const MAX_SIZE:u64 = 1024u64;
    #[]const WORD_SIZE:u64 = 1u64;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        *(std=0x1)::vector::borrow[parameter_types: [&vector<bool>, u64]<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert((copy start_index <@u64 *&copy bitvector.length, (std=0x1)::bit_vector::EINDEX));
        let index: (u64) = copy start_index;
        while (copy index <@u64 *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy index))) break else ();
            index: (u64) = copy index +@u64 1u64;
            /*()*/
        };
        copy index -@u64 copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert((copy length >@u64 0u64, (std=0x1)::bit_vector::ELENGTH));
        assert((copy length <@u64 (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH));
        let counter: (u64) = 0u64;
        let bit_field: (vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter <@u64 copy length
        }) {
            (std=0x1)::vector::push_back[parameter_types: [&mut vector<bool>, bool]<bool>((&mut bit_field, false));
            counter: (u64) = copy counter +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        (std=0x1)::bit_vector::BitVector<>{(1#bit_field:vector<bool>): copy bit_field, (0#length:u64): copy length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (copy amount >=@u64 *&copy bitvector.length)  {
            let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field);
            let i: (u64) = 0u64;
            while (copy i <@u64 copy len) {
                let elem: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        } else  {
            let i: (u64) = copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i))) (std=0x1)::bit_vector::set[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount)) else (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            i: (u64) = *&copy bitvector.length -@u64 copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7u64;
    #[]const ALREADY_EXISTS:u64 = 8u64;
    #[]const CANCELLED:u64 = 10u64;
    #[]const INTERNAL:u64 = 11u64;
    #[]const INVALID_ARGUMENT:u64 = 1u64;
    #[]const INVALID_STATE:u64 = 3u64;
    #[]const NOT_FOUND:u64 = 6u64;
    #[]const NOT_IMPLEMENTED:u64 = 12u64;
    #[]const OUT_OF_RANGE:u64 = 2u64;
    #[]const PERMISSION_DENIED:u64 = 5u64;
    #[]const RESOURCE_EXHAUSTED:u64 = 9u64;
    #[]const UNAUTHENTICATED:u64 = 4u64;
    #[]const UNAVAILABLE:u64 = 13u64;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        copy category <<@u64 16u8 +@u64 copy reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537u64;
    #[]const EDIVISION:u64 = 131074u64;
    #[]const EDIVISION_BY_ZERO:u64 = 65540u64;
    #[]const EMULTIPLICATION:u64 = 131075u64;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077u64;
    #[]const MAX_U64:u128 = 18446744073709551615u128;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        if (*&&num.value ==@u64 copy floored_num)  {
            return copy floored_num >>@u64 32u8
        } else ();
        let val: (u128) = (copy floored_num as u128) +@u128 1u128 <<@u128 32u8;
        (copy val >>@u128 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator: (u128) = (copy numerator as u128) <<@u128 64u8;
        let scaled_denominator: (u128) = (copy denominator as u128) <<@u128 32u8;
        assert((copy scaled_denominator !=@u128 0u128, (std=0x1)::fixed_point32::EDENOMINATOR));
        let quotient: (u128) = copy scaled_numerator /@u128 copy scaled_denominator;
        assert((copy quotient !=@u128 0u128 ||@bool copy numerator ==@u64 0u64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value: (u128) = (copy val as u128) <<@u128 32u8;
        assert((copy value <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((*&&divisor.value !=@u64 0u64, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO));
        let scaled_value: (u128) = (copy val as u128) <<@u128 32u8;
        let quotient: (u128) = copy scaled_value /@u128 (*&&divisor.value as u128);
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION));
        (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value >>@u64 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        *&&num.value ==@u64 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value >@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value <@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product: (u128) = (copy val as u128) *@u128 (*&&multiplier.value as u128);
        let product: (u128) = copy unscaled_product >>@u128 32u8;
        assert((copy product <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION));
        (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        let boundary: (u64) = copy floored_num +@u64 1u64 <<@u64 32u8 /@u64 2u64;
        if (*&&num.value <@u64 copy boundary)  {
            copy floored_num >>@u64 32u8
        } else  {
            (std=0x1)::fixed_point32::ceil[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#1> has copy drop store {
        0#vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144u64;
    #[]const EOPTION_NOT_SET:u64 = 262145u64;
    #[]public fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#2>]<Element#2>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow[parameter_types: [&vector<Element#2>, u64]<Element#2>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#3>]<Element#3>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#3>, u64]<Element#3>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4 {
        let vec_ref: (&vector<Element#4>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#4>]<Element#4>(copy vec_ref)) copy default_ref else (std=0x1)::vector::borrow[parameter_types: [&vector<Element#4>, u64]<Element#4>((copy vec_ref, 0u64))
    }
    #[]public fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool {
        (std=0x1)::vector::contains[parameter_types: [&vector<Element#5>, &Element#5]<Element#5>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): () {
        assert(((std=0x1)::option::is_none[parameter_types: [&(std=0x1)::option::Option<Element#6>]<Element#6>(&t), (std=0x1)::option::EOPTION_IS_SET));
        let (std=0x1)::option::Option<Element#6>{0#vec: vec}: ((std=0x1)::option::Option<Element#6>) = move t;
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#6>]<Element#6>(move vec)
    }
    #[]public fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#7>]<Element#7>(&t), (std=0x1)::option::EOPTION_NOT_SET));
        let (std=0x1)::option::Option<Element#7>{0#vec: vec}: ((std=0x1)::option::Option<Element#7>) = move t;
        let elem: (Element#7) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#7>]<Element#7>(&mut vec);
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#7>]<Element#7>(move vec);
        move elem
    }
    #[]public fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop {
        let (std=0x1)::option::Option<Element#8: drop>{0#vec: vec}: ((std=0x1)::option::Option<Element#8: drop>) = move t;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#8: drop>]<Element#8: drop>(&mut vec)) move default else (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#8: drop>]<Element#8: drop>(&mut vec)
    }
    #[]public fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#9>]<Element#9>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#9>]<Element#9>(&mut copy t.vec)
    }
    #[]public fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): () {
        let vec_ref: (&mut vector<Element#10>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#10>]<Element#10>(copy vec_ref)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#10>, Element#10]<Element#10>((copy vec_ref, move e)) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop {
        let vec_ref: (&vector<Element#17: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#17: copy+drop>]<Element#17: copy+drop>(copy vec_ref)) copy default else *(std=0x1)::vector::borrow[parameter_types: [&vector<Element#17: copy+drop>, u64]<Element#17: copy+drop>((copy vec_ref, 0u64))
    }
    #[]public fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#18>]<Element#18>(&copy t.vec)
    }
    #[]public fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool {
        ! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#19>]<Element#19>(&copy t.vec)
    }
    #[]public fun none<Element#22>(): (std=0x1)::option::Option<Element#22> {
        (std=0x1)::option::Option<Element#22>{(0#vec:vector<Element#22>): (std=0x1)::vector::empty<Element#22>(())}
    }
    #[]public fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23> {
        (std=0x1)::option::Option<Element#23>{(0#vec:vector<Element#23>): (std=0x1)::vector::singleton[parameter_types: [Element#23]<Element#23>(move e)}
    }
    #[]public fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#24>]<Element#24>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        let vec_ref: (&mut vector<Element#24>) = &mut copy t.vec;
        let old_value: (Element#24) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#24>]<Element#24>(copy vec_ref);
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#24>, Element#24]<Element#24>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25> {
        let vec_ref: (&mut vector<Element#25>) = &mut copy t.vec;
        let old_value: ((std=0x1)::option::Option<Element#25>) = if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#25>]<Element#25>(copy vec_ref)) (std=0x1)::option::none<Element#25>(()) else (std=0x1)::option::some[parameter_types: [Element#25]<Element#25>((std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#25>]<Element#25>(copy vec_ref));
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#25>, Element#25]<Element#25>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26> {
        let (std=0x1)::option::Option<Element#26>{0#vec: vec}: ((std=0x1)::option::Option<Element#26>) = move t;
        move vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address[parameter_types: [&signer]<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2u64;
    #[]const EINVALID_UTF8:u64 = 1u64;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append[parameter_types: [&mut vector<u8>, vector<u8>]<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((copy s, (std=0x1)::string::utf8[parameter_types: [vector<u8>]<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of[parameter_types: [&vector<u8>, &vector<u8>]<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes: (&vector<u8>) = &copy s.bytes;
        assert((copy at <=@u64 (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy at)), (std=0x1)::string::EINVALID_INDEX));
        let l: (u64) = (std=0x1)::string::length[parameter_types: [&(std=0x1)::string::String]<>(copy s);
        let front: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, 0u64, copy at));
        let end: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, copy at, copy l));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy o));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy end));
        *copy s = copy front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes: (&vector<u8>) = &copy s.bytes;
        let l: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes);
        assert((copy j <=@u64 copy l &&@bool copy i <=@u64 copy j &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy i)) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy j)), (std=0x1)::string::EINVALID_INDEX));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): (std=0x1)::string::internal_sub_string[parameter_types: [&vector<u8>, u64, u64]<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes))  {
            (std=0x1)::option::some[parameter_types: [(std=0x1)::string::String]<(std=0x1)::string::String>((std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes})
        } else  {
            (std=0x1)::option::none<(std=0x1)::string::String>(())
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert(((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes), (std=0x1)::string::EINVALID_UTF8));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &copy self.name
    }
    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072u64;
    #[]public fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#28>]<Element#28>(&mut other);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#28>]<Element#28>(&other))(std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#28>, Element#28]<Element#28>((copy lhs, (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#28>]<Element#28>(&mut other)));
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#28>]<Element#28>(move other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#31>]<Element#31>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#31>, u64]<Element#31>((copy v, copy i)) ==@&Element#31 copy e) return true else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64) {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#40>]<Element#40>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#40>, u64]<Element#40>((copy v, copy i)) ==@&Element#40 copy e) return (true, copy i) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        (false, 0u64)
    }
    #[]public fun is_empty<Element#41>(v: &vector<Element#41>): bool {
        (std=0x1)::vector::length[parameter_types: [&vector<Element#41>]<Element#41>(copy v) ==@u64 0u64
    }
    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47 {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#47>]<Element#47>(copy v);
        if (copy i >=@u64 copy len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len: (u64) = copy len -@u64 1u64;
        while (copy i <@u64 copy len)(std=0x1)::vector::swap[parameter_types: [&mut vector<Element#47>, u64, u64]<Element#47>((copy v, copy i,  {
            i: (u64) = copy i +@u64 1u64;
            copy i
        }));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#47>]<Element#47>(copy v)
    }
    #[]public fun reverse<Element#48>(v: &mut vector<Element#48>): () {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#48>]<Element#48>(copy v);
        if (copy len ==@u64 0u64) return () else ();
        let front_index: (u64) = 0u64;
        let back_index: (u64) = copy len -@u64 1u64;
        while (copy front_index <@u64 copy back_index) {
            (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#48>, u64, u64]<Element#48>((copy v, copy front_index, copy back_index));
            front_index: (u64) = copy front_index +@u64 1u64;
            back_index: (u64) = copy back_index -@u64 1u64;
            /*()*/
        }
    }
    #[]public fun singleton<Element#49>(e: Element#49): vector<Element#49> {
        let v: (vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#49>, Element#49]<Element#49>((&mut v, move e));
        move v
    }
    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51 {
        assert((! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#51>]<Element#51>(copy v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS));
        let last_idx: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#51>]<Element#51>(copy v) -@u64 1u64;
        (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#51>, u64, u64]<Element#51>((copy v, copy i, copy last_idx));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#51>]<Element#51>(copy v)
    }

}
After hlir: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        byte: u8
    }
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 =  {
        locals:


        return 65536u64
    };
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        locals:
            byte: u8,
            i: u64,
            len: u64,
            string: &(std=0x1)::ascii::String

        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        while ( {
            pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            copy i < copy len
        }) {
            (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char<>(copy byte))  {
                return@false
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        locals:
            string: &(std=0x1)::ascii::String

        return &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        locals:
            byte: u8,
            char: (std=0x1)::ascii::Char

        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        locals:
            byte: u8

        if ((std=0x1)::ascii::is_valid_char<>(copy byte))  {
            pop  = ()
        } else  {
            abort EINVALID_ASCII_CHARACTER
        };
        pop  = /*()*/;
        return Char<>{byte: copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        locals:
            bytes: vector<u8>,
            string: (std=0x1)::ascii::String

        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        locals:
            %#1: bool,
            byte: u8

        if (copy byte >= 32u8)  {
            (%#1: bool) = copy byte <= 126u8
        } else  {
            (%#1: bool) = false
        };
        return move#last %#1
    }
    #[]public fun is_valid_char(b: u8): bool {
        locals:
            b: u8

        return copy b <= 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        locals:
            string: &(std=0x1)::ascii::String

        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        locals:
            string: &mut (std=0x1)::ascii::String

        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        locals:
            char: (std=0x1)::ascii::Char,
            string: &mut (std=0x1)::ascii::String

        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        locals:
            bytes: vector<u8>,
            x: (std=0x1)::option::Option<(std=0x1)::ascii::String>

        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        if ((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x))  {
            pop  = ()
        } else  {
            abort EINVALID_ASCII_CHARACTER
        };
        pop  = /*()*/;
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        locals:
            bytes: vector<u8>,
            i: u64,
            len: u64,
            possible_byte: u8

        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        while ( {
            pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            copy i < copy len
        }) {
            (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char<>(copy possible_byte))  {
                return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        length: u64;
        bit_field: vector<bool>
    }
    #[]const EINDEX:u64 =  {
        locals:


        return 131072u64
    };
    #[]const ELENGTH:u64 =  {
        locals:


        return 131073u64
    };
    #[]const MAX_SIZE:u64 =  {
        locals:


        return 1024u64
    };
    #[]const WORD_SIZE:u64 =  {
        locals:


        return 1u64
    };
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        locals:
            bit_index: u64,
            bitvector: &(std=0x1)::bit_vector::BitVector

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector

        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector,
            index: u64,
            start_index: u64

        if (copy start_index < *&copy bitvector.length)  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (index: u64) = copy start_index;
        while (copy index < *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index)))  {
                break
            } else  {
                pop  = ()
            };
            (index: u64) = copy index + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return copy index - copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        locals:
            bit_field: vector<bool>,
            counter: u64,
            length: u64

        if (copy length > 0u64)  {
            pop  = ()
        } else  {
            abort ELENGTH
        };
        pop  = /*()*/;
        if (copy length < MAX_SIZE)  {
            pop  = ()
        } else  {
            abort ELENGTH
        };
        pop  = /*()*/;
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter < copy length
        }) {
            pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
            (counter: u64) = copy counter + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        pop  = /*()*/;
        return /*;()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        locals:
            %#2: &mut (std=0x1)::bit_vector::BitVector,
            %#3: u64,
            amount: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            elem: &mut bool,
            i: u64,
            i#1: u64,
            len: u64

        if (copy amount >= *&copy bitvector.length)  {
            (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
            (i: u64) = 0u64;
            while (copy i < copy len) {
                (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                pop  = /*()*/;
                (i: u64) = copy i + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        } else  {
            (i#1: u64) = copy amount;
            while (copy i#1 < *&copy bitvector.length) {
                ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
                if ((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3)))  {
                    pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount))
                } else  {
                    pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount))
                };
                (i#1: u64) = copy i#1 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            (i#1: u64) = *&copy bitvector.length - copy amount;
            pop  = /*()*/;
            while (copy i#1 < *&copy bitvector.length) {
                pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
                (i#1: u64) = copy i#1 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        };
        return /*()*/
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        pop  = /*()*/;
        return /*;()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 =  {
        locals:


        return 7u64
    };
    #[]const ALREADY_EXISTS:u64 =  {
        locals:


        return 8u64
    };
    #[]const CANCELLED:u64 =  {
        locals:


        return 10u64
    };
    #[]const INTERNAL:u64 =  {
        locals:


        return 11u64
    };
    #[]const INVALID_ARGUMENT:u64 =  {
        locals:


        return 1u64
    };
    #[]const INVALID_STATE:u64 =  {
        locals:


        return 3u64
    };
    #[]const NOT_FOUND:u64 =  {
        locals:


        return 6u64
    };
    #[]const NOT_IMPLEMENTED:u64 =  {
        locals:


        return 12u64
    };
    #[]const OUT_OF_RANGE:u64 =  {
        locals:


        return 2u64
    };
    #[]const PERMISSION_DENIED:u64 =  {
        locals:


        return 5u64
    };
    #[]const RESOURCE_EXHAUSTED:u64 =  {
        locals:


        return 9u64
    };
    #[]const UNAUTHENTICATED:u64 =  {
        locals:


        return 4u64
    };
    #[]const UNAVAILABLE:u64 =  {
        locals:


        return 13u64
    };
    #[]public fun aborted(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        locals:
            category: u64,
            reason: u64

        return copy category << 16u8 + copy reason
    }
    #[]public fun internal(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        value: u64
    }
    #[]const EDENOMINATOR:u64 =  {
        locals:


        return 65537u64
    };
    #[]const EDIVISION:u64 =  {
        locals:


        return 131074u64
    };
    #[]const EDIVISION_BY_ZERO:u64 =  {
        locals:


        return 65540u64
    };
    #[]const EMULTIPLICATION:u64 =  {
        locals:


        return 131075u64
    };
    #[]const ERATIO_OUT_OF_RANGE:u64 =  {
        locals:


        return 131077u64
    };
    #[]const MAX_U64:u128 =  {
        locals:


        return 18446744073709551615u128
    };
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32,
            val: u128

        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        if (*&&num.value == copy floored_num)  {
            return@copy floored_num >> 32u8
        } else  {
            pop  = ()
        };
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: bool,
            denominator: u64,
            numerator: u64,
            quotient: u128,
            scaled_denominator: u128,
            scaled_numerator: u128

        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        if (copy scaled_denominator != 0u128)  {
            pop  = ()
        } else  {
            abort EDENOMINATOR
        };
        pop  = /*()*/;
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        if (copy quotient != 0u128)  {
            (%#1: bool) = true
        } else  {
            (%#1: bool) = copy numerator == 0u64
        };
        if (move#last %#1)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        if (copy quotient <= MAX_U64)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        return FixedPoint32<>{value: (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            value: u64

        return FixedPoint32<>{value: copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            val: u64,
            value: u128

        (value: u128) = (copy val as u128) << 32u8;
        if (copy value <= MAX_U64)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        return FixedPoint32<>{value: (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            divisor: (std=0x1)::fixed_point32::FixedPoint32,
            quotient: u128,
            scaled_value: u128,
            val: u64

        if (*&&divisor.value != 0u64)  {
            pop  = ()
        } else  {
            abort EDIVISION_BY_ZERO
        };
        pop  = /*()*/;
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        if (copy quotient <= MAX_U64)  {
            pop  = ()
        } else  {
            abort EDIVISION
        };
        pop  = /*()*/;
        return (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value >> 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value == 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        if (*&&num1.value > *&&num2.value)  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1
        } else  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2
        };
        return move#last %#1
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        if (*&&num1.value < *&&num2.value)  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1
        } else  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2
        };
        return move#last %#1
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            multiplier: (std=0x1)::fixed_point32::FixedPoint32,
            product: u128,
            unscaled_product: u128,
            val: u64

        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        if (copy product <= MAX_U64)  {
            pop  = ()
        } else  {
            abort EMULTIPLICATION
        };
        pop  = /*()*/;
        return (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            %#1: u64,
            boundary: u64,
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32

        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        if (*&&num.value < copy boundary)  {
            (%#1: u64) = copy floored_num >> 32u8
        } else  {
            (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num)
        };
        return move#last %#1
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#1> has copy drop store {
        vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 =  {
        locals:


        return 262144u64
    };
    #[]const EOPTION_NOT_SET:u64 =  {
        locals:


        return 262145u64
    };
    #[]public fun borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2 {
        locals:
            t: &(std=0x1)::option::Option<Element#2>

        if ((std=0x1)::option::is_some<Element#2>(copy t))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::borrow<Element#2>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#3>

        if ((std=0x1)::option::is_some<Element#3>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::borrow_mut<Element#3>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4 {
        locals:
            %#1: &Element#4,
            default_ref: &Element#4,
            t: &(std=0x1)::option::Option<Element#4>,
            vec_ref: &vector<Element#4>

        (vec_ref: &vector<Element#4>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#4>(copy vec_ref))  {
            (%#1: &Element#4) = copy default_ref
        } else  {
            (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((copy vec_ref, 0u64))
        };
        return move#last %#1
    }
    #[]public fun contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool {
        locals:
            e_ref: &Element#5,
            t: &(std=0x1)::option::Option<Element#5>

        return (std=0x1)::vector::contains<Element#5>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): () {
        locals:
            t: (std=0x1)::option::Option<Element#6>,
            vec: vector<Element#6>

        if ((std=0x1)::option::is_none<Element#6>(&t))  {
            pop  = ()
        } else  {
            abort EOPTION_IS_SET
        };
        pop  = /*()*/;
        Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)
    }
    #[]public fun destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7 {
        locals:
            elem: Element#7,
            t: (std=0x1)::option::Option<Element#7>,
            vec: vector<Element#7>

        if ((std=0x1)::option::is_some<Element#7>(&t))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
        (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
        return move#no-copy elem
    }
    #[]public fun destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop {
        locals:
            %#1: Element#8: drop,
            default: Element#8: drop,
            t: (std=0x1)::option::Option<Element#8: drop>,
            vec: vector<Element#8: drop>

        Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
        if ((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec)))  {
            (%#1: Element#8: drop) = move#no-copy default
        } else  {
            (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec)
        };
        return move#last %#1
    }
    #[]public fun extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#9>

        if ((std=0x1)::option::is_some<Element#9>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::pop_back<Element#9>(&mut copy t.vec)
    }
    #[]public fun fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): () {
        locals:
            e: Element#10,
            t: &mut (std=0x1)::option::Option<Element#10>,
            vec_ref: &mut vector<Element#10>

        (vec_ref: &mut vector<Element#10>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref)))  {
            pop  = (std=0x1)::vector::push_back<Element#10>((copy vec_ref, move#no-copy e))
        } else  {
            abort EOPTION_IS_SET
        };
        return /*()*/
    }
    #[]public fun get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop {
        locals:
            %#1: Element#17: copy+drop,
            default: Element#17: copy+drop,
            t: &(std=0x1)::option::Option<Element#17: copy+drop>,
            vec_ref: &vector<Element#17: copy+drop>

        (vec_ref: &vector<Element#17: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref))  {
            (%#1: Element#17: copy+drop) = copy default
        } else  {
            (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((copy vec_ref, 0u64))
        };
        return move#last %#1
    }
    #[]public fun is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#18>

        return (std=0x1)::vector::is_empty<Element#18>(&copy t.vec)
    }
    #[]public fun is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#19>

        return ! (std=0x1)::vector::is_empty<Element#19>(&copy t.vec)
    }
    #[]public fun none<Element#22>(): (std=0x1)::option::Option<Element#22> {
        locals:


        return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}
    }
    #[]public fun some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23> {
        locals:
            e: Element#23

        return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}
    }
    #[]public fun swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24 {
        locals:
            e: Element#24,
            old_value: Element#24,
            t: &mut (std=0x1)::option::Option<Element#24>,
            vec_ref: &mut vector<Element#24>

        if ((std=0x1)::option::is_some<Element#24>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        (vec_ref: &mut vector<Element#24>) = &mut copy t.vec;
        (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#24>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
    }
    #[]public fun swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25> {
        locals:
            %#1: (std=0x1)::option::Option<Element#25>,
            e: Element#25,
            old_value: (std=0x1)::option::Option<Element#25>,
            t: &mut (std=0x1)::option::Option<Element#25>,
            vec_ref: &mut vector<Element#25>

        (vec_ref: &mut vector<Element#25>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref)))  {
            (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(())
        } else  {
            (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref))
        };
        (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#25>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
    }
    #[]public fun to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26> {
        locals:
            t: (std=0x1)::option::Option<Element#26>,
            vec: vector<Element#26>

        Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
        return move#no-copy vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        locals:
            s: &signer

        return *(std=0x1)::signer::borrow_address<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 =  {
        locals:


        return 2u64
    };
    #[]const EINVALID_UTF8:u64 =  {
        locals:


        return 1u64
    };
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        locals:
            r: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        locals:
            bytes: vector<u8>,
            s: &mut (std=0x1)::string::String

        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        locals:
            s: &(std=0x1)::string::String

        return &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        locals:
            r: &(std=0x1)::string::String,
            s: &(std=0x1)::string::String

        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        locals:
            %#1: bool,
            %#2: &mut (std=0x1)::string::String,
            %#3: u64,
            %#4: u64,
            %#5: &mut (std=0x1)::string::String,
            %#6: u64,
            %#7: u64,
            at: u64,
            bytes: &vector<u8>,
            end: (std=0x1)::string::String,
            front: (std=0x1)::string::String,
            l: u64,
            o: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        (bytes: &vector<u8>) = &copy s.bytes;
        if (copy at <= (std=0x1)::vector::length<u8>(copy bytes))  {
            (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at))
        } else  {
            (%#1: bool) = false
        };
        if (move#last %#1)  {
            pop  = ()
        } else  {
            abort EINVALID_INDEX
        };
        pop  = /*()*/;
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        pop  = /*()*/;
        return /*;()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        locals:
            s: &(std=0x1)::string::String

        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        locals:
            s: &(std=0x1)::string::String

        return (std=0x1)::vector::length<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        locals:
            %#1: bool,
            %#2: bool,
            %#3: bool,
            bytes: &vector<u8>,
            i: u64,
            j: u64,
            l: u64,
            s: &(std=0x1)::string::String

        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        if (copy j <= copy l)  {
            (%#1: bool) = copy i <= copy j
        } else  {
            (%#1: bool) = false
        };
        if (move#last %#1)  {
            (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i))
        } else  {
            (%#2: bool) = false
        };
        if (move#last %#2)  {
            (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j))
        } else  {
            (%#3: bool) = false
        };
        if (move#last %#3)  {
            pop  = ()
        } else  {
            abort EINVALID_INDEX
        };
        pop  = /*()*/;
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        locals:
            %#1: (std=0x1)::option::Option<(std=0x1)::string::String>,
            bytes: vector<u8>

        if ((std=0x1)::string::internal_check_utf8<>(&bytes))  {
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes})
        } else  {
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(())
        };
        return move#last %#1
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        locals:
            bytes: vector<u8>

        if ((std=0x1)::string::internal_check_utf8<>(&bytes))  {
            pop  = ()
        } else  {
            abort EINVALID_UTF8
        };
        pop  = /*()*/;
        return String<>{bytes: copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        locals:
            self: &(std=0x1)::type_name::TypeName

        return &copy self.name
    }
    #[]public native fun get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        locals:
            self: (std=0x1)::type_name::TypeName

        return *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 =  {
        locals:


        return 131072u64
    };
    #[]public fun append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): () {
        locals:
            lhs: &mut vector<Element#28>,
            other: vector<Element#28>

        pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
        while (! (std=0x1)::vector::is_empty<Element#28>(&other)) {
            pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)))
        };
        pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
        return /*;()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native fun borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public fun contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool {
        locals:
            e: &Element#31,
            i: u64,
            len: u64,
            v: &vector<Element#31>

        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
        while (copy i < copy len) {
            if ((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e)  {
                return@true
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native fun empty<Element#33>(): vector<Element#33>;

    #[]public fun index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64) {
        locals:
            e: &Element#40,
            i: u64,
            len: u64,
            v: &vector<Element#40>

        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
        while (copy i < copy len) {
            if ((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e)  {
                return@(true, copy i)
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return (false, 0u64)
    }
    #[]public fun is_empty<Element#41>(v: &vector<Element#41>): bool {
        locals:
            v: &vector<Element#41>

        return (std=0x1)::vector::length<Element#41>(copy v) == 0u64
    }
    #[bytecode_instruction]public native fun length<Element#42>(v: &vector<Element#42>): u64;

    #[bytecode_instruction]public native fun pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native fun push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public fun remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47 {
        locals:
            %#1: u64,
            %#2: &mut vector<Element#47>,
            i: u64,
            len: u64,
            v: &mut vector<Element#47>

        (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
        if (copy i >= copy len)  {
            abort EINDEX_OUT_OF_BOUNDS
        } else  {
            pop  = ()
        };
        (len: u64) = copy len - 1u64;
        pop  = /*()*/;
        while (copy i < copy len) {
            (%#2: &mut vector<Element#47>) = copy v;
            (%#1: u64) = copy i;
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i))
        };
        return (std=0x1)::vector::pop_back<Element#47>(copy v)
    }
    #[]public fun reverse<Element#48>(v: &mut vector<Element#48>): () {
        locals:
            back_index: u64,
            front_index: u64,
            len: u64,
            v: &mut vector<Element#48>

        (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
        if (copy len == 0u64)  {
            return@()
        } else  {
            pop  = ()
        };
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        while (copy front_index < copy back_index) {
            pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
            (front_index: u64) = copy front_index + 1u64;
            pop  = /*()*/;
            (back_index: u64) = copy back_index - 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return /*()*/
    }
    #[]public fun singleton<Element#49>(e: Element#49): vector<Element#49> {
        locals:
            e: Element#49,
            v: vector<Element#49>

        (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
        return move#no-copy v
    }
    #[bytecode_instruction]public native fun swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51 {
        locals:
            i: u64,
            last_idx: u64,
            v: &mut vector<Element#51>

        if (! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v)))  {
            pop  = ()
        } else  {
            abort EINDEX_OUT_OF_BOUNDS
        };
        pop  = /*()*/;
        (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#51>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#51>(copy v)
    }

}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(copy byte)) 3 else 4

    
    label 3:
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(copy byte)) 3 else 4

    
    label 3:
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 4

    
    label 3:
        pop _ = move#last string;
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 5

    
    label 3:
        pop _ = move#last string;
        return@false

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy string.bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy string.bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last string.bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last string.bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = move#last char;
        return move#last byte
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = move#last char;
        return move#last byte
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: copy byte}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: copy byte}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: move#last byte}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 3 else 2

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: move#last byte}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = move#last string;
        return move#last bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = move#last string;
        return move#last bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = copy byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = copy byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = move#last byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = move#last byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy b <= 127u8
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy b <= 127u8
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last b <= 127u8
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last b <= 127u8
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 3 else 2

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(copy possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(copy possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 5

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 9]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [4, 6]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 2

loop heads:
    loop head: 4. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 9

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 9]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [4, 6]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 2

loop heads:
    loop head: 4. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index

    
    label 13:
        jump 9
After recompute, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 7
    7 => 8
    8 => 13
    13 => 2

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index

    
    label 13:
        jump 9
dead_blocks is 
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 7
    7 => 8
    8 => 13
    13 => 2

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        pop _ = move#last bitvector;
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = move#last index + 1u64;
        jump 4

    
    label 9:
        return move#last index - move#last start_index

    
    label 13:
        pop _ = move#last bitvector;
        jump 9
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 8]
    6 => [9]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    8 <= [5]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 8
    8 => 13

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 8

    
    label 6:
        pop _ = move#last bitvector;
        jump@9

    
    label 8:
        (index: u64) = move#last index + 1u64;
        jump 4

    
    label 9:
        return move#last index - move#last start_index

    
    label 13:
        pop _ = move#last bitvector;
        jump 9
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = copy counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = copy counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = move#last counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: move#last length, bit_field: move#last bit_field}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [5, 6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    5 <= [3]
    6 <= [3]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 2
    2 => 3
    3 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 3 else 2

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 6 else 5

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = move#last counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: move#last length, bit_field: move#last bit_field}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = true;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = true;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *copy elem = false;
        (i: u64) = copy i + 1u64;
        jump 2

    
    label 4:
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = copy i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - copy amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = copy i#1 + 1u64;
        jump 12

    
    label 14:
        jump 15

    
    label 15:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *copy elem = false;
        (i: u64) = copy i + 1u64;
        jump 2

    
    label 4:
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = copy i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - copy amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = copy i#1 + 1u64;
        jump 12

    
    label 14:
        jump 15

    
    label 15:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *move#last elem = false;
        (i: u64) = move#last i + 1u64;
        jump 2

    
    label 4:
        pop _ = move#last bitvector;
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = move#last i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - move#last amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = move#last i#1 + 1u64;
        jump 12

    
    label 14:
        pop _ = move#last bitvector;
        jump 15

    
    label 15:
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *move#last elem = false;
        (i: u64) = move#last i + 1u64;
        jump 2

    
    label 4:
        pop _ = move#last bitvector;
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = move#last i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - move#last amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = move#last i#1 + 1u64;
        jump 12

    
    label 14:
        pop _ = move#last bitvector;
        jump 15

    
    label 15:
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = false;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = false;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy category << 16u8 + copy reason
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy category << 16u8 + copy reason
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last category << 16u8 + move#last reason
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last category << 16u8 + move#last reason
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@copy floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@copy floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@move#last floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (move#last floored_num as u128) + 1u128 << 32u8;
        return (move#last val >> 32u8 as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]

traversal:
    0 => 1
    1 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 3

    
    label 1:
        return@move#last floored_num >> 32u8

    
    label 3:
        (val: u128) = (move#last floored_num as u128) + 4294967296u128;
        return (move#last val >> 32u8 as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = copy numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (copy quotient as u64)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = copy numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (copy quotient as u64)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = move#last numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (move#last quotient as u64)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [8, 9]
    8 => []
    9 => [11, 12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    8 <= [6]
    9 <= [6]
    11 <= [9]
    12 <= [9]

traversal:
    0 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 8
    8 => 9
    9 => 11
    11 => 12

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 3 else 2

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = move#last numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 9 else 8

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 12 else 11

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (move#last quotient as u64)}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: copy value}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: copy value}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: move#last value}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: move#last value}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (copy val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (copy value as u64)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (copy val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (copy value as u64)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (move#last val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (move#last value as u64)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (move#last val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 3 else 2

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (move#last value as u64)}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (copy quotient as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (copy quotient as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (move#last val as u128) << 32u8;
        (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (move#last quotient as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [5, 6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    5 <= [3]
    6 <= [3]

traversal:
    0 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 3 else 2

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (move#last val as u128) << 32u8;
        (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 6 else 5

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (move#last quotient as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (copy product as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (copy product as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
        (product: u128) = move#last unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (move#last product as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
        (product: u128) = move#last unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 3 else 2

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (move#last product as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < copy boundary) 1 else 2

    
    label 1:
        (%#1: u64) = copy floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num);
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < copy boundary) 1 else 2

    
    label 1:
        (%#1: u64) = copy floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num);
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < move#last boundary) 1 else 2

    
    label 1:
        (%#1: u64) = move#last floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 2147483648u64;
        jump_if(*&&num.value < move#last boundary) 1 else 2

    
    label 1:
        (%#1: u64) = move#last floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#2>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#2>((&copy t.vec, 0u64))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#2>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#2>((&copy t.vec, 0u64))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#2>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#2>((&move#last t.vec, 0u64))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#2>(copy t)) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#2>((&move#last t.vec, 0u64))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#3>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#3>((&mut copy t.vec, 0u64))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#3>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#3>((&mut copy t.vec, 0u64))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#3>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#3>((&mut move#last t.vec, 0u64))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#3>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#3>((&mut move#last t.vec, 0u64))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#4>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#4>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: &Element#4) = copy default_ref;
        jump 3

    
    label 2:
        (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#4>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#4>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: &Element#4) = copy default_ref;
        jump 3

    
    label 2:
        (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#4>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#4>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: &Element#4) = move#last default_ref;
        jump 3

    
    label 2:
        pop _ = move#last default_ref;
        (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#4>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#4>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: &Element#4) = move#last default_ref;
        jump 3

    
    label 2:
        pop _ = move#last default_ref;
        (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#5>((&copy t.vec, copy e_ref))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#5>((&copy t.vec, copy e_ref))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#5>((&move#last t.vec, move#last e_ref))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#5>((&move#last t.vec, move#last e_ref))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#6>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#6>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#6>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#6>(&t)) 3 else 2

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#7>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
        (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
        return move#no-copy elem
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#7>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
        (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
        return move#no-copy elem
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#7>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
        (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
        return move#no-copy elem
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#7>(&t)) 3 else 2

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
        (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
        return move#no-copy elem
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#8: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#8: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#8: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#8: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#9>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#9>(&mut copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#9>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#9>(&mut copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#9>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#9>(&mut move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#9>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#9>(&mut move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#10>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#10>((copy vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#10>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#10>((copy vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#10>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#10>((move#last vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        pop _ = move#last vec_ref;
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#10>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref))) 3 else 2

    
    label 2:
        pop _ = move#last vec_ref;
        abort EOPTION_IS_SET

    
    label 3:
        pop  = (std=0x1)::vector::push_back<Element#10>((move#last vec_ref, move#no-copy e));
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#17: copy+drop>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: Element#17: copy+drop) = copy default;
        jump 3

    
    label 2:
        (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#17: copy+drop>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: Element#17: copy+drop) = copy default;
        jump 3

    
    label 2:
        (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#17: copy+drop>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: Element#17: copy+drop) = move#last default;
        jump 3

    
    label 2:
        (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#17: copy+drop>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: Element#17: copy+drop) = move#last default;
        jump 3

    
    label 2:
        (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#18>(&copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#18>(&copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#18>(&move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#18>(&move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#19>(&copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#19>(&copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#19>(&move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#19>(&move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#24>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#24>) = &mut copy t.vec;
        (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#24>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#24>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#24>) = &mut copy t.vec;
        (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#24>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#24>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#24>) = &mut move#last t.vec;
        (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#24>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#24>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#24>) = &mut move#last t.vec;
        (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#24>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#25>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#25>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#25>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#25>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#25>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#25>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#25>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#25>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
        return move#no-copy vec
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
        return move#no-copy vec
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
        return move#no-copy vec
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
        return move#no-copy vec
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(copy s)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(copy s)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(move#last s)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(move#last s)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy s.bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy s.bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last s.bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last s.bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at));
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at));
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
        jump 3

    
    label 2:
        pop _ = move#last bytes;
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        pop _ = move#last s;
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, move#last o));
        pop  = (std=0x1)::string::append<>((&mut front, move#last end));
        *move#last s = move#last front;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [5, 6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    5 <= [3]
    6 <= [3]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
        jump 3

    
    label 2:
        pop _ = move#last bytes;
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 6 else 5

    
    label 5:
        pop _ = move#last s;
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#4: u64)) = (copy s, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), 0u64, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, move#last o));
        pop  = (std=0x1)::string::append<>((&mut front, move#last end));
        *move#last s = move#last front;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&copy s.bytes)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&copy s.bytes)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&move#last s.bytes)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&move#last s.bytes)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= copy l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= copy l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &move#last s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= move#last l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        pop _ = move#last bytes;
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [11, 12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    11 <= [9]
    12 <= [9]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 11
    11 => 12

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &move#last s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= move#last l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 12 else 11

    
    label 11:
        pop _ = move#last bytes;
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: copy bytes}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: copy bytes}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: move#last bytes}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 3 else 2

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: move#last bytes}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy self.name
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy self.name
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last self.name
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last self.name
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#28>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)));
        jump 1

    
    label 3:
        pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#28>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)));
        jump 1

    
    label 3:
        pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#28>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)));
        jump 1

    
    label 3:
        pop _ = move#last lhs;
        pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#28>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)));
        jump 1

    
    label 3:
        pop _ = move#last lhs;
        pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return false
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return false
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return false
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e) 3 else 5

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@true

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return false
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@(true, copy i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return (false, 0u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@(true, copy i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return (false, 0u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@(true, move#last i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return (false, 0u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e) 3 else 5

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@(true, move#last i)

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return (false, 0u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#41>(copy v) == 0u64
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#41>(copy v) == 0u64
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#41>(move#last v) == 0u64
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#41>(move#last v) == 0u64
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#47>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = copy i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#47>(copy v)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#47>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = copy i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#47>(copy v)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#47>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = move#last i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#47>(move#last v)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 3

    
    label 1:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (len: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#47>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = move#last i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#47>(move#last v)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
        (front_index: u64) = copy front_index + 1u64;
        (back_index: u64) = copy back_index - 1u64;
        jump 4

    
    label 6:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
        (front_index: u64) = copy front_index + 1u64;
        (back_index: u64) = copy back_index - 1u64;
        jump 4

    
    label 6:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        pop _ = move#last v;
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
        (front_index: u64) = move#last front_index + 1u64;
        (back_index: u64) = move#last back_index - 1u64;
        jump 4

    
    label 6:
        pop _ = move#last v;
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 3

    
    label 1:
        pop _ = move#last v;
        return@()

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
        (front_index: u64) = move#last front_index + 1u64;
        (back_index: u64) = move#last back_index - 1u64;
        jump 4

    
    label 6:
        pop _ = move#last v;
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
        return move#no-copy v
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
        return move#no-copy v
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
        return move#no-copy v
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
        pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
        return move#no-copy v
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#51>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#51>(copy v)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#51>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#51>(copy v)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#51>((copy v, move#last i, move#last last_idx));
        return (std=0x1)::vector::pop_back<Element#51>(move#last v)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v))) 3 else 2

    
    label 2:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#51>((copy v, move#last i, move#last last_idx));
        return (std=0x1)::vector::pop_back<Element#51>(move#last v)
After cfgir: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        byte: u8
    }
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        locals:
            byte: u8,
            i: u64,
            len: u64,
            string: &(std=0x1)::ascii::String

        loop heads:

            1

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
            (i: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
            jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 5

        
        label 3:
            pop _ = move#last string;
            return@false

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
            return true


    }
    #[]public as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        locals:
            string: &(std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return &move#last string.bytes


    }
    #[]public byte(char: (std=0x1)::ascii::Char): u8 {
        locals:
            byte: u8,
            char: (std=0x1)::ascii::Char

        loop heads:


        start=0

        label 0:
            Char<>{byte: (byte: u8)} = move#last char;
            return move#last byte


    }
    #[]public char(byte: u8): (std=0x1)::ascii::Char {
        locals:
            byte: u8

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 3 else 2

        
        label 2:
            abort EINVALID_ASCII_CHARACTER

        
        label 3:
            return Char<>{byte: move#last byte}


    }
    #[]public into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        locals:
            bytes: vector<u8>,
            string: (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            String<>{bytes: (bytes: vector<u8>)} = move#last string;
            return move#last bytes


    }
    #[]public is_printable_char(byte: u8): bool {
        locals:
            %#1: bool,
            byte: u8

        loop heads:


        start=0

        label 0:
            jump_if(copy byte >= 32u8) 1 else 2

        
        label 1:
            (%#1: bool) = move#last byte <= 126u8;
            jump 3

        
        label 2:
            (%#1: bool) = false;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public is_valid_char(b: u8): bool {
        locals:
            b: u8

        loop heads:


        start=0

        label 0:
            return move#last b <= 127u8


    }
    #[]public length(string: &(std=0x1)::ascii::String): u64 {
        locals:
            string: &(std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))


    }
    #[]public pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        locals:
            string: &mut (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}


    }
    #[]public push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        locals:
            char: (std=0x1)::ascii::Char,
            string: &mut (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
            return /*;()*/


    }
    #[]public string(bytes: vector<u8>): (std=0x1)::ascii::String {
        locals:
            bytes: vector<u8>,
            x: (std=0x1)::option::Option<(std=0x1)::ascii::String>

        loop heads:


        start=0

        label 0:
            (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
            jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 3 else 2

        
        label 2:
            abort EINVALID_ASCII_CHARACTER

        
        label 3:
            return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)


    }
    #[]public try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        locals:
            bytes: vector<u8>,
            i: u64,
            len: u64,
            possible_byte: u8

        loop heads:

            1

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
            (i: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
            jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 5

        
        label 3:
            return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
            return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})


    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native to_bytes<MoveValue#0>(v: &MoveValue#0): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        length: u64;
        bit_field: vector<bool>
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        locals:
            bit_index: u64,
            bitvector: &(std=0x1)::bit_vector::BitVector

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))


    }
    #[]public length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)


    }
    #[]public longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector,
            index: u64,
            start_index: u64

        loop heads:

            4

        start=0

        label 0:
            jump_if(copy start_index < *&copy bitvector.length) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (index: u64) = copy start_index;
            jump 4

        
        label 4:
            jump_if(copy index < *&copy bitvector.length) 5 else 13

        
        label 5:
            jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 8

        
        label 6:
            pop _ = move#last bitvector;
            jump@9

        
        label 8:
            (index: u64) = move#last index + 1u64;
            jump 4

        
        label 9:
            return move#last index - move#last start_index

        
        label 13:
            pop _ = move#last bitvector;
            jump 9


    }
    #[]public new(length: u64): (std=0x1)::bit_vector::BitVector {
        locals:
            bit_field: vector<bool>,
            counter: u64,
            length: u64

        loop heads:

            7

        start=0

        label 0:
            jump_if(copy length > 0u64) 3 else 2

        
        label 2:
            abort ELENGTH

        
        label 3:
            jump_if(copy length < MAX_SIZE) 6 else 5

        
        label 5:
            abort ELENGTH

        
        label 6:
            (counter: u64) = 0u64;
            (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
            jump 7

        
        label 7:
            pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            jump_if(copy counter < copy length) 8 else 9

        
        label 8:
            pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
            (counter: u64) = move#last counter + 1u64;
            jump 7

        
        label 9:
            pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
            return BitVector<>{length: move#last length, bit_field: move#last bit_field}


    }
    #[]public set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
            *move#last x = true;
            return /*;()*/


    }
    #[]public shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        locals:
            %#2: &mut (std=0x1)::bit_vector::BitVector,
            %#3: u64,
            amount: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            elem: &mut bool,
            i: u64,
            i#1: u64,
            len: u64

        loop heads:

            2
            6
            12

        start=0

        label 0:
            jump_if(copy amount >= *&copy bitvector.length) 1 else 5

        
        label 1:
            (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
            (i: u64) = 0u64;
            jump 2

        
        label 2:
            jump_if(copy i < copy len) 3 else 4

        
        label 3:
            (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
            *move#last elem = false;
            (i: u64) = move#last i + 1u64;
            jump 2

        
        label 4:
            pop _ = move#last bitvector;
            jump 15

        
        label 5:
            (i#1: u64) = copy amount;
            jump 6

        
        label 6:
            jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

        
        label 7:
            ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
            jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

        
        label 8:
            pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
            jump 10

        
        label 9:
            pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
            jump 10

        
        label 10:
            (i#1: u64) = move#last i#1 + 1u64;
            jump 6

        
        label 11:
            (i#1: u64) = *&copy bitvector.length - move#last amount;
            jump 12

        
        label 12:
            jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

        
        label 13:
            pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
            (i#1: u64) = move#last i#1 + 1u64;
            jump 12

        
        label 14:
            pop _ = move#last bitvector;
            jump 15

        
        label 15:
            return /*()*/


    }
    #[]public unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
            *move#last x = false;
            return /*;()*/


    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public aborted(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((ABORTED, move#last r))


    }
    #[]public already_exists(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))


    }
    #[]public canonical(category: u64, reason: u64): u64 {
        locals:
            category: u64,
            reason: u64

        loop heads:


        start=0

        label 0:
            return move#last category << 16u8 + move#last reason


    }
    #[]public internal(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INTERNAL, move#last r))


    }
    #[]public invalid_argument(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))


    }
    #[]public invalid_state(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))


    }
    #[]public not_found(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))


    }
    #[]public not_implemented(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))


    }
    #[]public out_of_range(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))


    }
    #[]public permission_denied(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))


    }
    #[]public resource_exhausted(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))


    }
    #[]public unauthenticated(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))


    }
    #[]public unavailable(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))


    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32,
            val: u128

        loop heads:


        start=0

        label 0:
            (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
            jump_if(*&&num.value == copy floored_num) 1 else 3

        
        label 1:
            return@move#last floored_num >> 32u8

        
        label 3:
            (val: u128) = (move#last floored_num as u128) + 4294967296u128;
            return (move#last val >> 32u8 as u64)


    }
    #[]public create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: bool,
            denominator: u64,
            numerator: u64,
            quotient: u128,
            scaled_denominator: u128,
            scaled_numerator: u128

        loop heads:


        start=0

        label 0:
            (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
            (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
            jump_if(copy scaled_denominator != 0u128) 3 else 2

        
        label 2:
            abort EDENOMINATOR

        
        label 3:
            (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
            jump_if(copy quotient != 0u128) 4 else 5

        
        label 4:
            (%#1: bool) = true;
            jump 6

        
        label 5:
            (%#1: bool) = move#last numerator == 0u64;
            jump 6

        
        label 6:
            jump_if(move#last %#1) 9 else 8

        
        label 8:
            abort ERATIO_OUT_OF_RANGE

        
        label 9:
            jump_if(copy quotient <= MAX_U64) 12 else 11

        
        label 11:
            abort ERATIO_OUT_OF_RANGE

        
        label 12:
            return FixedPoint32<>{value: (move#last quotient as u64)}


    }
    #[]public create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            value: u64

        loop heads:


        start=0

        label 0:
            return FixedPoint32<>{value: move#last value}


    }
    #[]public create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            val: u64,
            value: u128

        loop heads:


        start=0

        label 0:
            (value: u128) = (move#last val as u128) << 32u8;
            jump_if(copy value <= MAX_U64) 3 else 2

        
        label 2:
            abort ERATIO_OUT_OF_RANGE

        
        label 3:
            return FixedPoint32<>{value: (move#last value as u64)}


    }
    #[]public divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            divisor: (std=0x1)::fixed_point32::FixedPoint32,
            quotient: u128,
            scaled_value: u128,
            val: u64

        loop heads:


        start=0

        label 0:
            jump_if(*&&divisor.value != 0u64) 3 else 2

        
        label 2:
            abort EDIVISION_BY_ZERO

        
        label 3:
            (scaled_value: u128) = (move#last val as u128) << 32u8;
            (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
            jump_if(copy quotient <= MAX_U64) 6 else 5

        
        label 5:
            abort EDIVISION

        
        label 6:
            return (move#last quotient as u64)


    }
    #[]public floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value >> 32u8


    }
    #[]public get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value


    }
    #[]public is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value == 0u64


    }
    #[]public max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            jump_if(*&&num1.value > *&&num2.value) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
            jump 3

        
        label 2:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            jump_if(*&&num1.value < *&&num2.value) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
            jump 3

        
        label 2:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            multiplier: (std=0x1)::fixed_point32::FixedPoint32,
            product: u128,
            unscaled_product: u128,
            val: u64

        loop heads:


        start=0

        label 0:
            (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
            (product: u128) = move#last unscaled_product >> 32u8;
            jump_if(copy product <= MAX_U64) 3 else 2

        
        label 2:
            abort EMULTIPLICATION

        
        label 3:
            return (move#last product as u64)


    }
    #[]public round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            %#1: u64,
            boundary: u64,
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
            (boundary: u64) = copy floored_num + 2147483648u64;
            jump_if(*&&num.value < move#last boundary) 1 else 2

        
        label 1:
            (%#1: u64) = move#last floored_num >> 32u8;
            jump 3

        
        label 2:
            (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
            jump 3

        
        label 3:
            return move#last %#1


    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native sha2_256(data: vector<u8>): vector<u8>;

    #[]public native sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#1> has copy drop store {
        vec: vector<Element#1>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public borrow<Element#2>(t: &(std=0x1)::option::Option<Element#2>): &Element#2 {
        locals:
            t: &(std=0x1)::option::Option<Element#2>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#2>(copy t)) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::borrow<Element#2>((&move#last t.vec, 0u64))


    }
    #[]public borrow_mut<Element#3>(t: &mut (std=0x1)::option::Option<Element#3>): &mut Element#3 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#3>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#3>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::borrow_mut<Element#3>((&mut move#last t.vec, 0u64))


    }
    #[]public borrow_with_default<Element#4>(t: &(std=0x1)::option::Option<Element#4>, default_ref: &Element#4): &Element#4 {
        locals:
            %#1: &Element#4,
            default_ref: &Element#4,
            t: &(std=0x1)::option::Option<Element#4>,
            vec_ref: &vector<Element#4>

        loop heads:


        start=0

        label 0:
            (vec_ref: &vector<Element#4>) = &move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#4>(copy vec_ref)) 1 else 2

        
        label 1:
            pop _ = move#last vec_ref;
            (%#1: &Element#4) = move#last default_ref;
            jump 3

        
        label 2:
            pop _ = move#last default_ref;
            (%#1: &Element#4) = (std=0x1)::vector::borrow<Element#4>((move#last vec_ref, 0u64));
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public contains<Element#5>(t: &(std=0x1)::option::Option<Element#5>, e_ref: &Element#5): bool {
        locals:
            e_ref: &Element#5,
            t: &(std=0x1)::option::Option<Element#5>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::contains<Element#5>((&move#last t.vec, move#last e_ref))


    }
    #[]public destroy_none<Element#6>(t: (std=0x1)::option::Option<Element#6>): () {
        locals:
            t: (std=0x1)::option::Option<Element#6>,
            vec: vector<Element#6>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_none<Element#6>(&t)) 3 else 2

        
        label 2:
            abort EOPTION_IS_SET

        
        label 3:
            Option<Element#6>{vec: (vec: vector<Element#6>)} = move#no-copy t;
            return (std=0x1)::vector::destroy_empty<Element#6>(move#no-copy vec)


    }
    #[]public destroy_some<Element#7>(t: (std=0x1)::option::Option<Element#7>): Element#7 {
        locals:
            elem: Element#7,
            t: (std=0x1)::option::Option<Element#7>,
            vec: vector<Element#7>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#7>(&t)) 3 else 2

        
        label 2:
            abort EOPTION_NOT_SET

        
        label 3:
            Option<Element#7>{vec: (vec: vector<Element#7>)} = move#no-copy t;
            (elem: Element#7) = (std=0x1)::vector::pop_back<Element#7>(&mut vec);
            pop  = (std=0x1)::vector::destroy_empty<Element#7>(move#no-copy vec);
            return move#no-copy elem


    }
    #[]public destroy_with_default<Element#8: drop>(t: (std=0x1)::option::Option<Element#8: drop>, default: Element#8: drop): Element#8: drop {
        locals:
            %#1: Element#8: drop,
            default: Element#8: drop,
            t: (std=0x1)::option::Option<Element#8: drop>,
            vec: vector<Element#8: drop>

        loop heads:


        start=0

        label 0:
            Option<Element#8: drop>{vec: (vec: vector<Element#8: drop>)} = move#no-copy t;
            jump_if((std=0x1)::vector::is_empty<Element#8: drop>(freeze(&mut vec))) 1 else 2

        
        label 1:
            (%#1: Element#8: drop) = move#no-copy default;
            jump 3

        
        label 2:
            (%#1: Element#8: drop) = (std=0x1)::vector::pop_back<Element#8: drop>(&mut vec);
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public extract<Element#9>(t: &mut (std=0x1)::option::Option<Element#9>): Element#9 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#9>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#9>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::pop_back<Element#9>(&mut move#last t.vec)


    }
    #[]public fill<Element#10>(t: &mut (std=0x1)::option::Option<Element#10>, e: Element#10): () {
        locals:
            e: Element#10,
            t: &mut (std=0x1)::option::Option<Element#10>,
            vec_ref: &mut vector<Element#10>

        loop heads:


        start=0

        label 0:
            (vec_ref: &mut vector<Element#10>) = &mut move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#10>(freeze(copy vec_ref))) 3 else 2

        
        label 2:
            pop _ = move#last vec_ref;
            abort EOPTION_IS_SET

        
        label 3:
            pop  = (std=0x1)::vector::push_back<Element#10>((move#last vec_ref, move#no-copy e));
            return /*()*/


    }
    #[]public get_with_default<Element#17: copy+drop>(t: &(std=0x1)::option::Option<Element#17: copy+drop>, default: Element#17: copy+drop): Element#17: copy+drop {
        locals:
            %#1: Element#17: copy+drop,
            default: Element#17: copy+drop,
            t: &(std=0x1)::option::Option<Element#17: copy+drop>,
            vec_ref: &vector<Element#17: copy+drop>

        loop heads:


        start=0

        label 0:
            (vec_ref: &vector<Element#17: copy+drop>) = &move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#17: copy+drop>(copy vec_ref)) 1 else 2

        
        label 1:
            pop _ = move#last vec_ref;
            (%#1: Element#17: copy+drop) = move#last default;
            jump 3

        
        label 2:
            (%#1: Element#17: copy+drop) = *(std=0x1)::vector::borrow<Element#17: copy+drop>((move#last vec_ref, 0u64));
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public is_none<Element#18>(t: &(std=0x1)::option::Option<Element#18>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#18>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::is_empty<Element#18>(&move#last t.vec)


    }
    #[]public is_some<Element#19>(t: &(std=0x1)::option::Option<Element#19>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#19>

        loop heads:


        start=0

        label 0:
            return ! (std=0x1)::vector::is_empty<Element#19>(&move#last t.vec)


    }
    #[]public none<Element#22>(): (std=0x1)::option::Option<Element#22> {
        locals:


        loop heads:


        start=0

        label 0:
            return Option<Element#22>{vec: (std=0x1)::vector::empty<Element#22>(())}


    }
    #[]public some<Element#23>(e: Element#23): (std=0x1)::option::Option<Element#23> {
        locals:
            e: Element#23

        loop heads:


        start=0

        label 0:
            return Option<Element#23>{vec: (std=0x1)::vector::singleton<Element#23>(move#no-copy e)}


    }
    #[]public swap<Element#24>(t: &mut (std=0x1)::option::Option<Element#24>, e: Element#24): Element#24 {
        locals:
            e: Element#24,
            old_value: Element#24,
            t: &mut (std=0x1)::option::Option<Element#24>,
            vec_ref: &mut vector<Element#24>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#24>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            (vec_ref: &mut vector<Element#24>) = &mut move#last t.vec;
            (old_value: Element#24) = (std=0x1)::vector::pop_back<Element#24>(copy vec_ref);
            pop  = (std=0x1)::vector::push_back<Element#24>((move#last vec_ref, move#no-copy e));
            return move#no-copy old_value


    }
    #[]public swap_or_fill<Element#25>(t: &mut (std=0x1)::option::Option<Element#25>, e: Element#25): (std=0x1)::option::Option<Element#25> {
        locals:
            %#1: (std=0x1)::option::Option<Element#25>,
            e: Element#25,
            old_value: (std=0x1)::option::Option<Element#25>,
            t: &mut (std=0x1)::option::Option<Element#25>,
            vec_ref: &mut vector<Element#25>

        loop heads:


        start=0

        label 0:
            (vec_ref: &mut vector<Element#25>) = &mut move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#25>(freeze(copy vec_ref))) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::none<Element#25>(());
            jump 3

        
        label 2:
            (%#1: (std=0x1)::option::Option<Element#25>) = (std=0x1)::option::some<Element#25>((std=0x1)::vector::pop_back<Element#25>(copy vec_ref));
            jump 3

        
        label 3:
            (old_value: (std=0x1)::option::Option<Element#25>) = move#last %#1;
            pop  = (std=0x1)::vector::push_back<Element#25>((move#last vec_ref, move#no-copy e));
            return move#no-copy old_value


    }
    #[]public to_vec<Element#26>(t: (std=0x1)::option::Option<Element#26>): vector<Element#26> {
        locals:
            t: (std=0x1)::option::Option<Element#26>,
            vec: vector<Element#26>

        loop heads:


        start=0

        label 0:
            Option<Element#26>{vec: (vec: vector<Element#26>)} = move#no-copy t;
            return move#no-copy vec


    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public address_of(s: &signer): address {
        locals:
            s: &signer

        loop heads:


        start=0

        label 0:
            return *(std=0x1)::signer::borrow_address<>(move#last s)


    }
    #[]public native borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        locals:
            r: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))


    }
    #[]public append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        locals:
            bytes: vector<u8>,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))


    }
    #[]public bytes(s: &(std=0x1)::string::String): &vector<u8> {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return &move#last s.bytes


    }
    #[]public index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        locals:
            r: &(std=0x1)::string::String,
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))


    }
    #[]public insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        locals:
            %#1: bool,
            %#2: &mut (std=0x1)::string::String,
            %#3: u64,
            %#4: u64,
            %#5: &mut (std=0x1)::string::String,
            %#6: u64,
            %#7: u64,
            at: u64,
            bytes: &vector<u8>,
            end: (std=0x1)::string::String,
            front: (std=0x1)::string::String,
            l: u64,
            o: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            (bytes: &vector<u8>) = &copy s.bytes;
            jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

        
        label 1:
            (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
            jump 3

        
        label 2:
            pop _ = move#last bytes;
            (%#1: bool) = false;
            jump 3

        
        label 3:
            jump_if(move#last %#1) 6 else 5

        
        label 5:
            pop _ = move#last s;
            abort EINVALID_INDEX

        
        label 6:
            (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
            ((%#2: &mut (std=0x1)::string::String), (%#4: u64)) = (copy s, copy at);
            (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), 0u64, move#last %#4));
            ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
            (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
            pop  = (std=0x1)::string::append<>((&mut front, move#last o));
            pop  = (std=0x1)::string::append<>((&mut front, move#last end));
            *move#last s = move#last front;
            return /*;()*/


    }
    #[] native internal_check_utf8(v: &vector<u8>): bool;

    #[] native internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public is_empty(s: &(std=0x1)::string::String): bool {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)


    }
    #[]public length(s: &(std=0x1)::string::String): u64 {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<u8>(&move#last s.bytes)


    }
    #[]public sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        locals:
            %#1: bool,
            %#2: bool,
            %#3: bool,
            bytes: &vector<u8>,
            i: u64,
            j: u64,
            l: u64,
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            (bytes: &vector<u8>) = &move#last s.bytes;
            (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
            jump_if(copy j <= move#last l) 1 else 2

        
        label 1:
            (%#1: bool) = copy i <= copy j;
            jump 3

        
        label 2:
            (%#1: bool) = false;
            jump 3

        
        label 3:
            jump_if(move#last %#1) 4 else 5

        
        label 4:
            (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
            jump 6

        
        label 5:
            (%#2: bool) = false;
            jump 6

        
        label 6:
            jump_if(move#last %#2) 7 else 8

        
        label 7:
            (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
            jump 9

        
        label 8:
            (%#3: bool) = false;
            jump 9

        
        label 9:
            jump_if(move#last %#3) 12 else 11

        
        label 11:
            pop _ = move#last bytes;
            abort EINVALID_INDEX

        
        label 12:
            return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}


    }
    #[]public try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        locals:
            %#1: (std=0x1)::option::Option<(std=0x1)::string::String>,
            bytes: vector<u8>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
            jump 3

        
        label 2:
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public utf8(bytes: vector<u8>): (std=0x1)::string::String {
        locals:
            bytes: vector<u8>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 3 else 2

        
        label 2:
            abort EINVALID_UTF8

        
        label 3:
            return String<>{bytes: move#last bytes}


    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        name: (std=0x1)::ascii::String
    }
    #[]public borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        locals:
            self: &(std=0x1)::type_name::TypeName

        loop heads:


        start=0

        label 0:
            return &move#last self.name


    }
    #[]public native get<T#27>(): (std=0x1)::type_name::TypeName;

    #[]public into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        locals:
            self: (std=0x1)::type_name::TypeName

        loop heads:


        start=0

        label 0:
            return *&&self.name


    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public append<Element#28>(lhs: &mut vector<Element#28>, other: vector<Element#28>): () {
        locals:
            lhs: &mut vector<Element#28>,
            other: vector<Element#28>

        loop heads:

            1

        start=0

        label 0:
            pop  = (std=0x1)::vector::reverse<Element#28>(&mut other);
            jump 1

        
        label 1:
            jump_if(! (std=0x1)::vector::is_empty<Element#28>(&other)) 2 else 3

        
        label 2:
            pop  = (std=0x1)::vector::push_back<Element#28>((copy lhs, (std=0x1)::vector::pop_back<Element#28>(&mut other)));
            jump 1

        
        label 3:
            pop _ = move#last lhs;
            pop  = (std=0x1)::vector::destroy_empty<Element#28>(move#no-copy other);
            return /*;()*/


    }
    #[bytecode_instruction]public native borrow<Element#29>(v: &vector<Element#29>, i: u64): &Element#29;

    #[bytecode_instruction]public native borrow_mut<Element#30>(v: &mut vector<Element#30>, i: u64): &mut Element#30;

    #[]public contains<Element#31>(v: &vector<Element#31>, e: &Element#31): bool {
        locals:
            e: &Element#31,
            i: u64,
            len: u64,
            v: &vector<Element#31>

        loop heads:

            1

        start=0

        label 0:
            (i: u64) = 0u64;
            (len: u64) = (std=0x1)::vector::length<Element#31>(copy v);
            jump 1

        
        label 1:
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            jump_if((std=0x1)::vector::borrow<Element#31>((copy v, copy i)) == copy e) 3 else 5

        
        label 3:
            pop _ = move#last v;
            pop _ = move#last e;
            return@true

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop _ = move#last v;
            pop _ = move#last e;
            return false


    }
    #[bytecode_instruction]public native destroy_empty<Element#32>(v: vector<Element#32>): ();

    #[bytecode_instruction]public native empty<Element#33>(): vector<Element#33>;

    #[]public index_of<Element#40>(v: &vector<Element#40>, e: &Element#40): (bool, u64) {
        locals:
            e: &Element#40,
            i: u64,
            len: u64,
            v: &vector<Element#40>

        loop heads:

            1

        start=0

        label 0:
            (i: u64) = 0u64;
            (len: u64) = (std=0x1)::vector::length<Element#40>(copy v);
            jump 1

        
        label 1:
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            jump_if((std=0x1)::vector::borrow<Element#40>((copy v, copy i)) == copy e) 3 else 5

        
        label 3:
            pop _ = move#last v;
            pop _ = move#last e;
            return@(true, move#last i)

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop _ = move#last v;
            pop _ = move#last e;
            return (false, 0u64)


    }
    #[]public is_empty<Element#41>(v: &vector<Element#41>): bool {
        locals:
            v: &vector<Element#41>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<Element#41>(move#last v) == 0u64


    }
    #[bytecode_instruction]public native length<Element#42>(v: &vector<Element#42>): u64;

    #[bytecode_instruction]public native pop_back<Element#45>(v: &mut vector<Element#45>): Element#45;

    #[bytecode_instruction]public native push_back<Element#46>(v: &mut vector<Element#46>, e: Element#46): ();

    #[]public remove<Element#47>(v: &mut vector<Element#47>, i: u64): Element#47 {
        locals:
            %#1: u64,
            %#2: &mut vector<Element#47>,
            i: u64,
            len: u64,
            v: &mut vector<Element#47>

        loop heads:

            4

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<Element#47>(freeze(copy v));
            jump_if(copy i >= copy len) 1 else 3

        
        label 1:
            pop _ = move#last v;
            abort EINDEX_OUT_OF_BOUNDS

        
        label 3:
            (len: u64) = move#last len - 1u64;
            jump 4

        
        label 4:
            jump_if(copy i < copy len) 5 else 6

        
        label 5:
            (%#2: &mut vector<Element#47>) = copy v;
            (%#1: u64) = copy i;
            (i: u64) = move#last i + 1u64;
            pop  = (std=0x1)::vector::swap<Element#47>((move#last %#2, move#last %#1, copy i));
            jump 4

        
        label 6:
            return (std=0x1)::vector::pop_back<Element#47>(move#last v)


    }
    #[]public reverse<Element#48>(v: &mut vector<Element#48>): () {
        locals:
            back_index: u64,
            front_index: u64,
            len: u64,
            v: &mut vector<Element#48>

        loop heads:

            4

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<Element#48>(freeze(copy v));
            jump_if(copy len == 0u64) 1 else 3

        
        label 1:
            pop _ = move#last v;
            return@()

        
        label 3:
            (front_index: u64) = 0u64;
            (back_index: u64) = move#last len - 1u64;
            jump 4

        
        label 4:
            jump_if(copy front_index < copy back_index) 5 else 6

        
        label 5:
            pop  = (std=0x1)::vector::swap<Element#48>((copy v, copy front_index, copy back_index));
            (front_index: u64) = move#last front_index + 1u64;
            (back_index: u64) = move#last back_index - 1u64;
            jump 4

        
        label 6:
            pop _ = move#last v;
            return /*()*/


    }
    #[]public singleton<Element#49>(e: Element#49): vector<Element#49> {
        locals:
            e: Element#49,
            v: vector<Element#49>

        loop heads:


        start=0

        label 0:
            (v: vector<Element#49>) = (std=0x1)::vector::empty<Element#49>(());
            pop  = (std=0x1)::vector::push_back<Element#49>((&mut v, move#no-copy e));
            return move#no-copy v


    }
    #[bytecode_instruction]public native swap<Element#50>(v: &mut vector<Element#50>, i: u64, j: u64): ();

    #[]public swap_remove<Element#51>(v: &mut vector<Element#51>, i: u64): Element#51 {
        locals:
            i: u64,
            last_idx: u64,
            v: &mut vector<Element#51>

        loop heads:


        start=0

        label 0:
            jump_if(! (std=0x1)::vector::is_empty<Element#51>(freeze(copy v))) 3 else 2

        
        label 2:
            pop _ = move#last v;
            abort EINDEX_OUT_OF_BOUNDS

        
        label 3:
            (last_idx: u64) = (std=0x1)::vector::length<Element#51>(freeze(copy v)) - 1u64;
            pop  = (std=0x1)::vector::swap<Element#51>((copy v, move#last i, move#last last_idx));
            return (std=0x1)::vector::pop_back<Element#51>(move#last v)


    }

}
Before expansion: program = ------ Lib Defs: ------

------ Source Defs: ------
no package
std => 0x1
module std::ascii {
    use std::vector;use std::option:: {
        Self, Option
    };const EINVALID_ASCII_CHARACTER:u64 = 0x10000;copy drop storestruct String {
        bytes: vector<u8>
    }spec String{invariant forall i in 0 .. len(bytes) : is_valid_char(bytes[i])}copy drop storestruct Char {
        byte: u8
    }spec Char{invariant is_valid_char(byte)}public fun char(byte: u8): Char {
        assert!(is_valid_char(byte), EINVALID_ASCII_CHARACTER);
        Char{byte: byte}
    }spec char{aborts_if ! is_valid_char(byte)EINVALID_ASCII_CHARACTER}public fun string(bytes: vector<u8>): String {
        let x = try_string(bytes);
        assert!(option::is_some(&x), EINVALID_ASCII_CHARACTER);
        option::destroy_some(x)
    }spec string{aborts_if exists i in 0 .. len(bytes) : ! is_valid_char(bytes[i])EINVALID_ASCII_CHARACTER}public fun try_string(bytes: vector<u8>): Option<String> {
        let len = vector::length(&bytes);
        let i = 0;
        while ( {
            spec {spec {invariant i <= len;
            invariant forall j in 0 .. i : is_valid_char(bytes[j])}};
            i < len
        }) {
            let possible_byte = *vector::borrow(&bytes, i);
            if (! is_valid_char(possible_byte)) return option::none();
            i = i + 1;

        };
        spec {spec {assert i == len;
        assert forall j in 0 .. len : is_valid_char(bytes[j])}};
        option::some(String{bytes: bytes})
    }public fun all_characters_printable(string: &String): bool {
        let len = vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec {spec {invariant i <= len;
            invariant forall j in 0 .. i : is_printable_char(string.bytes[j])}};
            i < len
        }) {
            let byte = *vector::borrow(&string.bytes, i);
            if (! is_printable_char(byte)) return false;
            i = i + 1;

        };
        spec {spec {assert i == len;
        assert forall j in 0 .. len : is_printable_char(string.bytes[j])}};
        true
    }spec all_characters_printable{ensures result ==> forall j in 0 .. len(string.bytes) : is_printable_char(string.bytes[j])}public fun push_char(string: &mut String, char: Char): () {
        vector::push_back(&mut string.bytes, char.byte);

    }spec push_char{ensures len(string.bytes) == len(old(string.bytes)) + 1}public fun pop_char(string: &mut String): Char {
        Char{byte: vector::pop_back(&mut string.bytes)}
    }spec pop_char{ensures len(string.bytes) == len(old(string.bytes)) - 1}public fun length(string: &String): u64 {
        vector::length(as_bytes(string))
    }public fun as_bytes(string: &String): &vector<u8> {
        &string.bytes
    }public fun into_bytes(string: String): vector<u8> {
        let String{bytes: bytes} = string;
        bytes
    }public fun byte(char: Char): u8 {
        let Char{byte: byte} = char;
        byte
    }public fun is_valid_char(b: u8): bool {
        b <= 0x7F
    }public fun is_printable_char(byte: u8): bool {
        byte >= 0x20 && byte <= 0x7E
    }
}no package
std => 0x1
module std::bcs {
    public native fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;
    spec module {}spec module {native fun serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }
}no package
std => 0x1
module std::bit_vector {
    use std::vector;const EINDEX:u64 = 0x20000;const ELENGTH:u64 = 0x20001;const WORD_SIZE:u64 = 1;const MAX_SIZE:u64 = 1024;copy drop storestruct BitVector {
        length: u64;
        bit_field: vector<bool>
    }public fun new(length: u64): BitVector {
        assert!(length > 0, ELENGTH);
        assert!(length < MAX_SIZE, ELENGTH);
        let counter = 0;
        let bit_field = vector::empty();
        while ( {
            spec {spec {invariant counter <= length;
            invariant len(bit_field) == counter}};
            counter < length
        }) {
            vector::push_back(&mut bit_field, false);
            counter = counter + 1;

        };
        spec {spec {assert counter == length;
        assert len(bit_field) == length}};
        BitVector{length: length, bit_field: bit_field}
    }spec new{include NewAbortsIf;
    ensures result.length == length;
    ensures len(result.bit_field) == length}spec schema NewAbortsIf{locallength: u64;
    aborts_if length <= 0ELENGTH;
    aborts_if length >= MAX_SIZEELENGTH}public fun set(bitvector: &mut BitVector, bit_index: u64): () {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;

    }spec set{include SetAbortsIf;
    ensures bitvector.bit_field[bit_index]}spec schema SetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}public fun unset(bitvector: &mut BitVector, bit_index: u64): () {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        let x = vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;

    }spec unset{include UnsetAbortsIf;
    ensures ! bitvector.bit_field[bit_index]}spec schema UnsetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}public fun shift_left(bitvector: &mut BitVector, amount: u64): () {
        if (amount >= bitvector.length)  {
            let len = vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;

            };

        } else  {
            let i = amount;
            while (i < bitvector.length) {
                if (is_index_set(bitvector, i)) set(bitvector, i - amount) else unset(bitvector, i - amount);
                i = i + 1;

            };
            i = bitvector.length - amount;
            while (i < bitvector.length) {
                unset(bitvector, i);
                i = i + 1;

            };

        }
    }public fun is_index_set(bitvector: &BitVector, bit_index: u64): bool {
        assert!(bit_index < vector::length(&bitvector.bit_field), EINDEX);
        *vector::borrow(&bitvector.bit_field, bit_index)
    }spec is_index_set{include IsIndexSetAbortsIf;
    ensures result == bitvector.bit_field[bit_index]}spec schema IsIndexSetAbortsIf{localbitvector: BitVector;
    localbit_index: u64;
    aborts_if bit_index >= length(bitvector)EINDEX}spec module {fun spec_is_index_set(bitvector: BitVector, bit_index: u64): bool {
        if (bit_index >= length(bitvector))  {
            false
        } else  {
            bitvector.bit_field[bit_index]
        }
    }}public fun length(bitvector: &BitVector): u64 {
        vector::length(&bitvector.bit_field)
    }public fun longest_set_sequence_starting_at(bitvector: &BitVector, start_index: u64): u64 {
        assert!(start_index < bitvector.length, EINDEX);
        let index = start_index;
        while (index < bitvector.length) {
            if (! is_index_set(bitvector, index)) break;
            index = index + 1;

        };
        index - start_index
    }
}no package
std => 0x1
module std::error {
    const INVALID_ARGUMENT:u64 = 0x1;const OUT_OF_RANGE:u64 = 0x2;const INVALID_STATE:u64 = 0x3;const UNAUTHENTICATED:u64 = 0x4;const PERMISSION_DENIED:u64 = 0x5;const NOT_FOUND:u64 = 0x6;const ABORTED:u64 = 0x7;const ALREADY_EXISTS:u64 = 0x8;const RESOURCE_EXHAUSTED:u64 = 0x9;const CANCELLED:u64 = 0xA;const INTERNAL:u64 = 0xB;const NOT_IMPLEMENTED:u64 = 0xC;const UNAVAILABLE:u64 = 0xD;public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }public fun invalid_argument(r: u64): u64 {
        canonical(INVALID_ARGUMENT, r)
    }public fun out_of_range(r: u64): u64 {
        canonical(OUT_OF_RANGE, r)
    }public fun invalid_state(r: u64): u64 {
        canonical(INVALID_STATE, r)
    }public fun unauthenticated(r: u64): u64 {
        canonical(UNAUTHENTICATED, r)
    }public fun permission_denied(r: u64): u64 {
        canonical(PERMISSION_DENIED, r)
    }public fun not_found(r: u64): u64 {
        canonical(NOT_FOUND, r)
    }public fun aborted(r: u64): u64 {
        canonical(ABORTED, r)
    }public fun already_exists(r: u64): u64 {
        canonical(ALREADY_EXISTS, r)
    }public fun resource_exhausted(r: u64): u64 {
        canonical(RESOURCE_EXHAUSTED, r)
    }public fun internal(r: u64): u64 {
        canonical(INTERNAL, r)
    }public fun not_implemented(r: u64): u64 {
        canonical(NOT_IMPLEMENTED, r)
    }public fun unavailable(r: u64): u64 {
        canonical(UNAVAILABLE, r)
    }
}no package
std => 0x1
module std::fixed_point32 {
    copy drop storestruct FixedPoint32 {
        value: u64
    }const MAX_U64:u128 = 18446744073709551615;const EDENOMINATOR:u64 = 0x10001;const EDIVISION:u64 = 0x20002;const EMULTIPLICATION:u64 = 0x20003;const EDIVISION_BY_ZERO:u64 = 0x10004;const ERATIO_OUT_OF_RANGE:u64 = 0x20005;public fun multiply_u64(val: u64, multiplier: FixedPoint32): u64 {
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert!(product <= MAX_U64, EMULTIPLICATION);
        (product as u64)
    }spec multiply_u64{pragma opaque;
    include MultiplyAbortsIf;
    ensures result == spec_multiply_u64(val, multiplier)}spec schema MultiplyAbortsIf{localval: num;
    localmultiplier: FixedPoint32;
    aborts_if spec_multiply_u64(val, multiplier) > MAX_U64EMULTIPLICATION}spec module {fun spec_multiply_u64(val: num, multiplier: FixedPoint32): num {
        val * multiplier.value >> 32
    }}public fun divide_u64(val: u64, divisor: FixedPoint32): u64 {
        assert!(divisor.value != 0, EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / (divisor.value as u128);
        assert!(quotient <= MAX_U64, EDIVISION);
        (quotient as u64)
    }spec divide_u64{pragma opaque;
    include DivideAbortsIf;
    ensures result == spec_divide_u64(val, divisor)}spec schema DivideAbortsIf{localval: num;
    localdivisor: FixedPoint32;
    aborts_if divisor.value == 0EDIVISION_BY_ZERO;
    aborts_if spec_divide_u64(val, divisor) > MAX_U64EDIVISION}spec module {fun spec_divide_u64(val: num, divisor: FixedPoint32): num {
        val << 32 / divisor.value
    }}public fun create_from_rational(numerator: u64, denominator: u64): FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert!(scaled_denominator != 0, EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);
        assert!(quotient <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32{value: (quotient as u64)}
    }spec create_from_rational{pragma verify = false;
    pragma opaque;
    include CreateFromRationalAbortsIf;
    ensures result == spec_create_from_rational(numerator, denominator)}spec schema CreateFromRationalAbortsIf{localnumerator: u64;
    localdenominator: u64;
    let scaled_numerator = (numerator as u128) << 64;
    let scaled_denominator = (denominator as u128) << 32;
    let quotient = scaled_numerator / scaled_denominator;
    aborts_if scaled_denominator == 0EDENOMINATOR;
    aborts_if quotient == 0 && scaled_numerator != 0ERATIO_OUT_OF_RANGE;
    aborts_if quotient > MAX_U64ERATIO_OUT_OF_RANGE}spec module {fun spec_create_from_rational(numerator: num, denominator: num): FixedPoint32 {
        FixedPoint32{value: numerator << 64 / denominator << 32}
    }}public fun create_from_raw_value(value: u64): FixedPoint32 {
        FixedPoint32{value: value}
    }spec create_from_raw_value{pragma opaque;
    aborts_if false;
    ensures result.value == value}public fun get_raw_value(num: FixedPoint32): u64 {
        num.value
    }public fun is_zero(num: FixedPoint32): bool {
        num.value == 0
    }public fun min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }spec min{pragma opaque;
    aborts_if false;
    ensures result == spec_min(num1, num2)}spec module {fun spec_min(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }}public fun max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }spec max{pragma opaque;
    aborts_if false;
    ensures result == spec_max(num1, num2)}spec module {fun spec_max(num1: FixedPoint32, num2: FixedPoint32): FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }}public fun create_from_u64(val: u64): FixedPoint32 {
        let value = (val as u128) << 32;
        assert!(value <= MAX_U64, ERATIO_OUT_OF_RANGE);
        FixedPoint32{value: (value as u64)}
    }spec create_from_u64{pragma opaque;
    include CreateFromU64AbortsIf;
    ensures result == spec_create_from_u64(val)}spec schema CreateFromU64AbortsIf{localval: num;
    let scaled_value = (val as u128) << 32;
    aborts_if scaled_value > MAX_U64}spec module {fun spec_create_from_u64(val: num): FixedPoint32 {
        FixedPoint32{value: val << 32}
    }}public fun floor(num: FixedPoint32): u64 {
        num.value >> 32
    }spec floor{pragma opaque;
    aborts_if false;
    ensures result == spec_floor(num)}spec module {fun spec_floor(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional >> 32
        }
    }}public fun ceil(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        if (num.value == floored_num)  {
            return floored_num >> 32
        };
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }spec ceil{pragma verify = false;
    pragma opaque;
    aborts_if false;
    ensures result == spec_ceil(num)}spec module {fun spec_ceil(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let one = 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}public fun round(num: FixedPoint32): u64 {
        let floored_num = floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if (num.value < boundary)  {
            floored_num >> 32
        } else  {
            ceil(num)
        }
    }spec round{pragma opaque;
    pragma timeout = 120;
    aborts_if false;
    ensures result == spec_round(num)}spec module {fun spec_round(val: FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let boundary = 1 << 32 / 2;
        let one = 1 << 32;
        if (fractional < boundary)  {
            val.value - fractional >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}spec module {}spec module {pragma aborts_if_is_strict}
}no package
std => 0x1
module std::hash {
    public native fun sha2_256(data: vector<u8>): vector<u8>;
    public native fun sha3_256(data: vector<u8>): vector<u8>;

}no package
std => 0x1
module std::option {
    use std::vector;copy drop storestruct Option<Element> {
        vec: vector<Element>
    }spec Option{invariant len(vec) <= 1}const EOPTION_IS_SET:u64 = 0x40000;const EOPTION_NOT_SET:u64 = 0x40001;public fun none<Element>(): Option<Element> {
        Option{vec: vector::empty()}
    }spec none{pragma opaque;
    aborts_if false;
    ensures result == spec_none<Element>()}spec module {fun spec_none<Element>(): Option<Element> {
        Option{vec: vec()}
    }}public fun some<Element>(e: Element): Option<Element> {
        Option{vec: vector::singleton(e)}
    }spec some{pragma opaque;
    aborts_if false;
    ensures result == spec_some(e)}spec module {fun spec_some<Element>(e: Element): Option<Element> {
        Option{vec: vec(e)}
    }}public fun is_none<Element>(t: &Option<Element>): bool {
        vector::is_empty(&t.vec)
    }spec is_none{pragma opaque;
    aborts_if false;
    ensures result == is_none(t)}public fun is_some<Element>(t: &Option<Element>): bool {
        ! vector::is_empty(&t.vec)
    }spec is_some{pragma opaque;
    aborts_if false;
    ensures result == is_some(t)}public fun contains<Element>(t: &Option<Element>, e_ref: &Element): bool {
        vector::contains(&t.vec, e_ref)
    }spec contains{pragma opaque;
    aborts_if false;
    ensures result == spec_contains(t, e_ref)}spec module {fun spec_contains<Element>(t: Option<Element>, e: Element): bool {
        is_some(t) && borrow(t) == e
    }}public fun borrow<Element>(t: &Option<Element>): &Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow(&t.vec, 0)
    }spec borrow{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t)}public fun borrow_with_default<Element>(t: &Option<Element>, default_ref: &Element): &Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default_ref else vector::borrow(vec_ref, 0)
    }spec borrow_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default_ref}public fun get_with_default<Element: copy+drop>(t: &Option<Element>, default: Element): Element {
        let vec_ref = &t.vec;
        if (vector::is_empty(vec_ref)) default else *vector::borrow(vec_ref, 0)
    }spec get_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default}public fun fill<Element>(t: &mut Option<Element>, e: Element): () {
        let vec_ref = &mut t.vec;
        if (vector::is_empty(vec_ref)) vector::push_back(vec_ref, e) else abort EOPTION_IS_SET
    }spec fill{pragma opaque;
    aborts_if is_some(t)EOPTION_IS_SET;
    ensures is_some(t);
    ensures borrow(t) == e}public fun extract<Element>(t: &mut Option<Element>): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::pop_back(&mut t.vec)
    }spec extract{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(old(t));
    ensures is_none(t)}public fun borrow_mut<Element>(t: &mut Option<Element>): &mut Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        vector::borrow_mut(&mut t.vec, 0)
    }spec borrow_mut{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t);
    ensures t == old(t)}public fun swap<Element>(t: &mut Option<Element>, e: Element): Element {
        assert!(is_some(t), EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = vector::pop_back(vec_ref);
        vector::push_back(vec_ref, e);
        old_value
    }spec swap{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(old(t));
    ensures is_some(t);
    ensures borrow(t) == e}public fun swap_or_fill<Element>(t: &mut Option<Element>, e: Element): Option<Element> {
        let vec_ref = &mut t.vec;
        let old_value = if (vector::is_empty(vec_ref)) none() else some(vector::pop_back(vec_ref));
        vector::push_back(vec_ref, e);
        old_value
    }spec swap_or_fill{pragma opaque;
    ensures result == old(t);
    ensures borrow(t) == e}public fun destroy_with_default<Element: drop>(t: Option<Element>, default: Element): Element {
        let Option{vec: vec} = t;
        if (vector::is_empty(&mut vec)) default else vector::pop_back(&mut vec)
    }spec destroy_with_default{pragma opaque;
    aborts_if false;
    ensures result == if (is_some(t)) borrow(t) else default}public fun destroy_some<Element>(t: Option<Element>): Element {
        assert!(is_some(&t), EOPTION_NOT_SET);
        let Option{vec: vec} = t;
        let elem = vector::pop_back(&mut vec);
        vector::destroy_empty(vec);
        elem
    }spec destroy_some{pragma opaque;
    include AbortsIfNone<Element>;
    ensures result == borrow(t)}public fun destroy_none<Element>(t: Option<Element>): () {
        assert!(is_none(&t), EOPTION_IS_SET);
        let Option{vec: vec} = t;
        vector::destroy_empty(vec)
    }spec destroy_none{pragma opaque;
    aborts_if is_some(t)EOPTION_IS_SET}public fun to_vec<Element>(t: Option<Element>): vector<Element> {
        let Option{vec: vec} = t;
        vec
    }spec to_vec{pragma opaque;
    aborts_if false;
    ensures result == t.vec}public inline fun for_each<Element>(o: Option<Element>, f: (Element):()): () {
        if (is_some(&o))  {
            f(destroy_some(o))
        } else  {
            destroy_none(o)
        }
    }public inline fun for_each_ref<Element>(o: &Option<Element>, f: (&Element):()): () {
        if (is_some(o))  {
            f(borrow(o))
        }
    }public inline fun for_each_mut<Element>(o: &mut Option<Element>, f: (&mut Element):()): () {
        if (is_some(o))  {
            f(borrow_mut(o))
        }
    }public inline fun fold<Accumulator, Element>(o: Option<Element>, init: Accumulator, f: (Accumulator, Element):Accumulator): Accumulator {
        if (is_some(&o))  {
            f(init, destroy_some(o))
        } else  {
            destroy_none(o);
            init
        }
    }public inline fun map<Element, OtherElement>(o: Option<Element>, f: (Element):OtherElement): Option<OtherElement> {
        if (is_some(&o))  {
            some(f(destroy_some(o)))
        } else  {
            destroy_none(o);
            none()
        }
    }public inline fun filter<Element: drop>(o: Option<Element>, f: (&Element):bool): Option<Element> {
        if (is_some(&o) && f(borrow(&o)))  {
            o
        } else  {
            none()
        }
    }spec module {}spec module {pragma aborts_if_is_strict}spec schema AbortsIfNone<Element>{localt: Option<Element>;
    aborts_if is_none(t)EOPTION_NOT_SET}
}no package
std => 0x1
module std::signer {
    public native fun borrow_address(s: &signer): &address;
    public fun address_of(s: &signer): address {
        *borrow_address(s)
    }spec module {native fun is_txn_signer(s: signer): bool;
    }spec module {native fun is_txn_signer_addr(a: address): bool;
    }
}no package
std => 0x1
module std::string {
    use std::vector;use std::option:: {
        Self, Option
    };const EINVALID_UTF8:u64 = 1;const EINVALID_INDEX:u64 = 2;copy drop storestruct String {
        bytes: vector<u8>
    }public fun utf8(bytes: vector<u8>): String {
        assert!(internal_check_utf8(&bytes), EINVALID_UTF8);
        String{bytes: bytes}
    }public fun try_utf8(bytes: vector<u8>): Option<String> {
        if (internal_check_utf8(&bytes))  {
            option::some(String{bytes: bytes})
        } else  {
            option::none()
        }
    }public fun bytes(s: &String): &vector<u8> {
        &s.bytes
    }public fun is_empty(s: &String): bool {
        vector::is_empty(&s.bytes)
    }public fun length(s: &String): u64 {
        vector::length(&s.bytes)
    }public fun append(s: &mut String, r: String): () {
        vector::append(&mut s.bytes, r.bytes)
    }public fun append_utf8(s: &mut String, bytes: vector<u8>): () {
        append(s, utf8(bytes))
    }public fun insert(s: &mut String, at: u64, o: String): () {
        let bytes = &s.bytes;
        assert!(at <= vector::length(bytes) && internal_is_char_boundary(bytes, at), EINVALID_INDEX);
        let l = length(s);
        let front = sub_string(s, 0, at);
        let end = sub_string(s, at, l);
        append(&mut front, o);
        append(&mut front, end);
        *s = front;

    }public fun sub_string(s: &String, i: u64, j: u64): String {
        let bytes = &s.bytes;
        let l = vector::length(bytes);
        assert!(j <= l && i <= j && internal_is_char_boundary(bytes, i) && internal_is_char_boundary(bytes, j), EINVALID_INDEX);
        String{bytes: internal_sub_string(bytes, i, j)}
    }public fun index_of(s: &String, r: &String): u64 {
        internal_index_of(&s.bytes, &r.bytes)
    } native fun internal_check_utf8(v: &vector<u8>): bool;
     native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;
     native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;
     native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

}no package
std => 0x1
module std::type_name {
    use std::ascii:: {
        String
    };copy drop storestruct TypeName {
        name: String
    }public native fun get<T>(): TypeName;
    public fun borrow_string(self: &TypeName): &String {
        &self.name
    }public fun into_string(self: TypeName): String {
        self.name
    }
}no package
std => 0x1
module std::vector {
    const EINDEX_OUT_OF_BOUNDS:u64 = 0x20000;#[bytecode_instruction]public native fun empty<Element>(): vector<Element>;
    #[bytecode_instruction]public native fun length<Element>(v: &vector<Element>): u64;
    #[bytecode_instruction]public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;
    #[bytecode_instruction]public native fun push_back<Element>(v: &mut vector<Element>, e: Element): ();
    #[bytecode_instruction]public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;
    #[bytecode_instruction]public native fun pop_back<Element>(v: &mut vector<Element>): Element;
    #[bytecode_instruction]public native fun destroy_empty<Element>(v: vector<Element>): ();
    #[bytecode_instruction]public native fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64): ();
    public fun singleton<Element>(e: Element): vector<Element> {
        let v = empty();
        push_back(&mut v, e);
        v
    }spec singleton{aborts_if false;
    ensures result == vec(e)}public fun reverse<Element>(v: &mut vector<Element>): () {
        let len = length(v);
        if (len == 0) return ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;

        }
    }spec reverse{pragma intrinsic = true}public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>): () {
        reverse(&mut other);
        while (! is_empty(&other))push_back(lhs, pop_back(&mut other));
        destroy_empty(other);

    }spec append{pragma intrinsic = true}spec is_empty{pragma intrinsic = true}public fun is_empty<Element>(v: &vector<Element>): bool {
        length(v) == 0
    }public fun contains<Element>(v: &vector<Element>, e: &Element): bool {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return true;
            i = i + 1;

        };
        false
    }spec contains{pragma intrinsic = true}public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {
        let i = 0;
        let len = length(v);
        while (i < len) {
            if (borrow(v, i) == e) return (true, i);
            i = i + 1;

        };
        (false, 0)
    }spec index_of{pragma intrinsic = true}public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {
        let len = length(v);
        if (i >= len) abort EINDEX_OUT_OF_BOUNDS;
        len = len - 1;
        while (i < len)swap(v, i,  {
            i = i + 1;
            i
        });
        pop_back(v)
    }spec remove{pragma intrinsic = true}public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {
        assert!(! is_empty(v), EINDEX_OUT_OF_BOUNDS);
        let last_idx = length(v) - 1;
        swap(v, i, last_idx);
        pop_back(v)
    }spec swap_remove{pragma intrinsic = true}public inline fun for_each<Element>(v: vector<Element>, f: (Element):()): () {
        reverse(&mut v);
        while (! is_empty(&v)) {
            let e = pop_back(&mut v);
            f(e);

        };

    }public inline fun for_each_ref<Element>(v: &vector<Element>, f: (&Element):()): () {
        let i = 0;
        while (i < length(v)) {
            f(borrow(v, i));
            i = i + 1
        }
    }public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: (&mut Element):()): () {
        let i = 0;
        while (i < length(v)) {
            f(borrow_mut(v, i));
            i = i + 1
        }
    }public inline fun fold<Accumulator, Element>(v: vector<Element>, init: Accumulator, f: (Accumulator, Element):Accumulator): Accumulator {
        let accu = init;
        for_each(v, |elem|accu = f(accu, elem));
        accu
    }public inline fun map<Element, NewElement>(v: vector<Element>, f: (Element):NewElement): vector<NewElement> {
        let result = vector<NewElement>[];
        for_each(v, |elem|push_back(&mut result, f(elem)));
        result
    }public inline fun filter<Element: drop>(v: vector<Element>, p: (&Element):bool): vector<Element> {
        let result = vector<Element>[];
        for_each(v, |elem| {
            if (p(&elem)) push_back(&mut result, elem);

        });
        result
    }spec module {}spec module {fun eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
        len(v1) == len(v2) + 1 && v1[len(v1) - 1] == e && v1[0 .. len(v1) - 1] == v2[0 .. len(v2)]
    };
    fun eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
        len(v) == len(v1) + len(v2) && v[0 .. len(v1)] == v1 && v[len(v1) .. len(v)] == v2
    };
    fun eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1 == v2[1 .. len(v2)]
    };
    fun eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1[0 .. i] == v2[0 .. i] && v1[i .. len(v1)] == v2[i + 1 .. len(v2)]
    }}
}
After expansion: program = module (std=0x1)::ascii {
    #[]source module
    dependency order #2
    neighbor#dependency (std=0x1)::option;
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len = (std=0x1)::vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec #0 uses [i, len, string];
            i < len
        }) {
            let byte = *(std=0x1)::vector::borrow(&string.bytes, i);
            if (! (std=0x1)::ascii::is_printable_char(byte)) return false else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [i, len, string];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char{0#byte: byte} = char;
        byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert!((std=0x1)::ascii::is_valid_char(byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::ascii::Char{0#byte: byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String{0#bytes: bytes} = string;
        bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        byte >= 32 && byte <= 126
    }
    #[]public fun is_valid_char(b: u8): bool {
        b <= 127
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length((std=0x1)::ascii::as_bytes(string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char{0#byte: (std=0x1)::vector::pop_back(&mut string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back(&mut string.bytes, char.byte);
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x = (std=0x1)::ascii::try_string(bytes);
        assert!((std=0x1)::option::is_some(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::option::destroy_some(x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len = (std=0x1)::vector::length(&bytes);
        let i = 0;
        while ( {
            spec #0 uses [bytes, i, len];
            i < len
        }) {
            let possible_byte = *(std=0x1)::vector::borrow(&bytes, i);
            if (! (std=0x1)::ascii::is_valid_char(possible_byte)) return (std=0x1)::option::none() else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [bytes, i, len];
        (std=0x1)::option::some((std=0x1)::ascii::String{0#bytes: bytes})
    }
     spec String{invariant forall i in 0 .. len(bytes) : (std=0x1)::ascii::is_valid_char(bytes[i])}
     spec Char{invariant (std=0x1)::ascii::is_valid_char(byte)}
     spec char{aborts_if ! (std=0x1)::ascii::is_valid_char(byte)(std=0x1)::ascii::EINVALID_ASCII_CHARACTER}
     spec string{aborts_if exists i in 0 .. len(bytes) : ! (std=0x1)::ascii::is_valid_char(bytes[i])(std=0x1)::ascii::EINVALID_ASCII_CHARACTER}
     spec all_characters_printable{ensures result ==> forall j in 0 .. len(string.bytes) : (std=0x1)::ascii::is_printable_char(string.bytes[j])}
     spec push_char{ensures len(string.bytes) == len(old(string.bytes)) + 1}
     spec pop_char{ensures len(string.bytes) == len(old(string.bytes)) - 1}

}
module (std=0x1)::bcs {
    #[]source module
    dependency order #0
    #[]public native fun to_bytes<MoveValue>(v: &MoveValue): vector<u8>;

     spec module {}
     spec module {native define serialize<MoveValue>(v: &MoveValue): vector<u8>;
    }

}
module (std=0x1)::bit_vector {
    #[]source module
    dependency order #3
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        *(std=0x1)::vector::borrow(&bitvector.bit_field, bit_index)
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length(&bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert!(start_index < bitvector.length, (std=0x1)::bit_vector::EINDEX);
        let index = start_index;
        while (index < bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set(bitvector, index)) break else ();
            index = index + 1;
            /*()*/
        };
        index - start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert!(length > 0, (std=0x1)::bit_vector::ELENGTH);
        assert!(length < (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH);
        let counter = 0;
        let bit_field = (std=0x1)::vector::empty();
        while ( {
            spec #0 uses [bit_field, counter, length] applies [len];
            counter < length
        }) {
            (std=0x1)::vector::push_back(&mut bit_field, false);
            counter = counter + 1;
            /*()*/
        };
        spec #1 uses [bit_field, counter, length] applies [len];
        (std=0x1)::bit_vector::BitVector{1#bit_field: bit_field, 0#length: length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (amount >= bitvector.length)  {
            let len = (std=0x1)::vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;
                /*()*/
            };
            /*()*/
        } else  {
            let i = amount;
            while (i < bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set(bitvector, i)) (std=0x1)::bit_vector::set(bitvector, i - amount) else (std=0x1)::bit_vector::unset(bitvector, i - amount);
                i = i + 1;
                /*()*/
            };
            i = bitvector.length - amount;
            while (i < bitvector.length) {
                (std=0x1)::bit_vector::unset(bitvector, i);
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert!(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;
        /*()*/
    }
     spec new{include (std=0x1)::bit_vector::NewAbortsIf;
    ensures result.length == length;
    ensures len(result.bit_field) == length}
     spec schema NewAbortsIf{locallength: u64;
    aborts_if length <= 0(std=0x1)::bit_vector::ELENGTH;
    aborts_if length >= (std=0x1)::bit_vector::MAX_SIZE(std=0x1)::bit_vector::ELENGTH}
     spec set{include (std=0x1)::bit_vector::SetAbortsIf;
    ensures bitvector.bit_field[bit_index]}
     spec schema SetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec unset{include (std=0x1)::bit_vector::UnsetAbortsIf;
    ensures ! bitvector.bit_field[bit_index]}
     spec schema UnsetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec is_index_set{include (std=0x1)::bit_vector::IsIndexSetAbortsIf;
    ensures result == bitvector.bit_field[bit_index]}
     spec schema IsIndexSetAbortsIf{localbitvector: (std=0x1)::bit_vector::BitVector;
    localbit_index: u64;
    aborts_if bit_index >= (std=0x1)::bit_vector::length(bitvector)(std=0x1)::bit_vector::EINDEX}
     spec module {define spec_is_index_set(bitvector: (std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        if (bit_index >= (std=0x1)::bit_vector::length(bitvector))  {
            false
        } else  {
            bitvector.bit_field[bit_index]
        }
    }}

}
module (std=0x1)::error {
    #[]source module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ABORTED, r)
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ALREADY_EXISTS, r)
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INTERNAL, r)
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_ARGUMENT, r)
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_STATE, r)
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_FOUND, r)
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_IMPLEMENTED, r)
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::OUT_OF_RANGE, r)
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::PERMISSION_DENIED, r)
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::RESOURCE_EXHAUSTED, r)
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAUTHENTICATED, r)
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAVAILABLE, r)
    }

}
module (std=0x1)::fixed_point32 {
    #[]source module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        if (num.value == floored_num)  {
            return floored_num >> 32
        } else ();
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert!(scaled_denominator != 0, (std=0x1)::fixed_point32::EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert!(quotient != 0 || numerator == 0, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        assert!(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value = (val as u128) << 32;
        assert!(value <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert!(divisor.value != 0, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / (divisor.value as u128);
        assert!(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION);
        (quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        num.value >> 32
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        num.value == 0
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product = (val as u128) * (multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert!(product <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION);
        (product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if (num.value < boundary)  {
            floored_num >> 32
        } else  {
            (std=0x1)::fixed_point32::ceil(num)
        }
    }
     spec multiply_u64{pragma opaque;
    include (std=0x1)::fixed_point32::MultiplyAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_multiply_u64(val, multiplier)}
     spec schema MultiplyAbortsIf{localval: num;
    localmultiplier: (std=0x1)::fixed_point32::FixedPoint32;
    aborts_if (std=0x1)::fixed_point32::spec_multiply_u64(val, multiplier) > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::EMULTIPLICATION}
     spec module {define spec_multiply_u64(val: num, multiplier: (std=0x1)::fixed_point32::FixedPoint32): num {
        val * multiplier.value >> 32
    }}
     spec divide_u64{pragma opaque;
    include (std=0x1)::fixed_point32::DivideAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_divide_u64(val, divisor)}
     spec schema DivideAbortsIf{localval: num;
    localdivisor: (std=0x1)::fixed_point32::FixedPoint32;
    aborts_if divisor.value == 0(std=0x1)::fixed_point32::EDIVISION_BY_ZERO;
    aborts_if (std=0x1)::fixed_point32::spec_divide_u64(val, divisor) > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::EDIVISION}
     spec module {define spec_divide_u64(val: num, divisor: (std=0x1)::fixed_point32::FixedPoint32): num {
        val << 32 / divisor.value
    }}
     spec create_from_rational{pragma verify = false;
    pragma opaque;
    include (std=0x1)::fixed_point32::CreateFromRationalAbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_create_from_rational(numerator, denominator)}
     spec schema CreateFromRationalAbortsIf{localnumerator: u64;
    localdenominator: u64;
    let scaled_numerator = (numerator as u128) << 64;
    let scaled_denominator = (denominator as u128) << 32;
    let quotient = scaled_numerator / scaled_denominator;
    aborts_if scaled_denominator == 0(std=0x1)::fixed_point32::EDENOMINATOR;
    aborts_if quotient == 0 && scaled_numerator != 0(std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE;
    aborts_if quotient > (std=0x1)::fixed_point32::MAX_U64(std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE}
     spec module {define spec_create_from_rational(numerator: num, denominator: num): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: numerator << 64 / denominator << 32}
    }}
     spec create_from_raw_value{pragma opaque;
    aborts_if false;
    ensures result.value == value}
     spec min{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_min(num1, num2)}
     spec module {define spec_min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value < num2.value)  {
            num1
        } else  {
            num2
        }
    }}
     spec max{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_max(num1, num2)}
     spec module {define spec_max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (num1.value > num2.value)  {
            num1
        } else  {
            num2
        }
    }}
     spec create_from_u64{pragma opaque;
    include (std=0x1)::fixed_point32::CreateFromU64AbortsIf;
    ensures result == (std=0x1)::fixed_point32::spec_create_from_u64(val)}
     spec schema CreateFromU64AbortsIf{localval: num;
    let scaled_value = (val as u128) << 32;
    aborts_if scaled_value > (std=0x1)::fixed_point32::MAX_U64}
     spec module {define spec_create_from_u64(val: num): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: val << 32}
    }}
     spec floor{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_floor(num)}
     spec module {define spec_floor(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional >> 32
        }
    }}
     spec ceil{pragma verify = false;
    pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_ceil(num)}
     spec module {define spec_ceil(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let one = 1 << 32;
        if (fractional == 0)  {
            val.value >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}
     spec round{pragma opaque;
    pragma timeout = 120;
    aborts_if false;
    ensures result == (std=0x1)::fixed_point32::spec_round(num)}
     spec module {define spec_round(val: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let fractional = val.value % 1 << 32;
        let boundary = 1 << 32 / 2;
        let one = 1 << 32;
        if (fractional < boundary)  {
            val.value - fractional >> 32
        } else  {
            val.value - fractional + one >> 32
        }
    }}
     spec module {}
     spec module {pragma aborts_if_is_strict}

}
module (std=0x1)::hash {
    #[]source module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]source module
    dependency order #1
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct Option<Element> has copy drop store {
        0#vec: vector<Element>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public fun borrow<Element>(t: &(std=0x1)::option::Option<Element>): &Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow(&t.vec, 0)
    }
    #[]public fun borrow_mut<Element>(t: &mut (std=0x1)::option::Option<Element>): &mut Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow_mut(&mut t.vec, 0)
    }
    #[]public fun borrow_with_default<Element>(t: &(std=0x1)::option::Option<Element>, default_ref: &Element): &Element {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default_ref else (std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun contains<Element>(t: &(std=0x1)::option::Option<Element>, e_ref: &Element): bool {
        (std=0x1)::vector::contains(&t.vec, e_ref)
    }
    #[]public fun destroy_none<Element>(t: (std=0x1)::option::Option<Element>): () {
        assert!((std=0x1)::option::is_none(&t), (std=0x1)::option::EOPTION_IS_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        (std=0x1)::vector::destroy_empty(vec)
    }
    #[]public fun destroy_some<Element>(t: (std=0x1)::option::Option<Element>): Element {
        assert!((std=0x1)::option::is_some(&t), (std=0x1)::option::EOPTION_NOT_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        let elem = (std=0x1)::vector::pop_back(&mut vec);
        (std=0x1)::vector::destroy_empty(vec);
        elem
    }
    #[]public fun destroy_with_default<Element: drop>(t: (std=0x1)::option::Option<Element>, default: Element): Element {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        if ((std=0x1)::vector::is_empty(&mut vec)) default else (std=0x1)::vector::pop_back(&mut vec)
    }
    #[]public fun extract<Element>(t: &mut (std=0x1)::option::Option<Element>): Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::pop_back(&mut t.vec)
    }
    #[]public fun fill<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): () {
        let vec_ref = &mut t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::vector::push_back(vec_ref, e) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public inline fun filter<Element: drop>(o: (std=0x1)::option::Option<Element>, f: |&Element|bool): (std=0x1)::option::Option<Element> {
        if ((std=0x1)::option::is_some(&o) && f((std=0x1)::option::borrow(&o)))  {
            o
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public inline fun fold<Accumulator, Element>(o: (std=0x1)::option::Option<Element>, init: Accumulator, f: |Accumulator, Element|Accumulator): Accumulator {
        if ((std=0x1)::option::is_some(&o))  {
            f(init, (std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o);
            init
        }
    }
    #[]public inline fun for_each<Element>(o: (std=0x1)::option::Option<Element>, f: |Element|()): () {
        if ((std=0x1)::option::is_some(&o))  {
            f((std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o)
        }
    }
    #[]public inline fun for_each_mut<Element>(o: &mut (std=0x1)::option::Option<Element>, f: |&mut Element|()): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow_mut(o))
        } else ()
    }
    #[]public inline fun for_each_ref<Element>(o: &(std=0x1)::option::Option<Element>, f: |&Element|()): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow(o))
        } else ()
    }
    #[]public fun get_with_default<Element: copy+drop>(t: &(std=0x1)::option::Option<Element>, default: Element): Element {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default else *(std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun is_none<Element>(t: &(std=0x1)::option::Option<Element>): bool {
        (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public fun is_some<Element>(t: &(std=0x1)::option::Option<Element>): bool {
        ! (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public inline fun map<Element, OtherElement>(o: (std=0x1)::option::Option<Element>, f: |Element|OtherElement): (std=0x1)::option::Option<OtherElement> {
        if ((std=0x1)::option::is_some(&o))  {
            (std=0x1)::option::some(f((std=0x1)::option::destroy_some(o)))
        } else  {
            (std=0x1)::option::destroy_none(o);
            (std=0x1)::option::none()
        }
    }
    #[]public fun none<Element>(): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::empty()}
    }
    #[]public fun some<Element>(e: Element): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::singleton(e)}
    }
    #[]public fun swap<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): Element {
        assert!((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = (std=0x1)::vector::pop_back(vec_ref);
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun swap_or_fill<Element>(t: &mut (std=0x1)::option::Option<Element>, e: Element): (std=0x1)::option::Option<Element> {
        let vec_ref = &mut t.vec;
        let old_value = if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::option::none() else (std=0x1)::option::some((std=0x1)::vector::pop_back(vec_ref));
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun to_vec<Element>(t: (std=0x1)::option::Option<Element>): vector<Element> {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        vec
    }
     spec Option{invariant len(vec) <= 1}
     spec none{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_none<Element>()}
     spec module {define spec_none<Element>(): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: vec()}
    }}
     spec some{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_some(e)}
     spec module {define spec_some<Element>(e: Element): (std=0x1)::option::Option<Element> {
        (std=0x1)::option::Option{0#vec: vec(e)}
    }}
     spec is_none{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::is_none(t)}
     spec is_some{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::is_some(t)}
     spec contains{pragma opaque;
    aborts_if false;
    ensures result == (std=0x1)::option::spec_contains(t, e_ref)}
     spec module {define spec_contains<Element>(t: (std=0x1)::option::Option<Element>, e: Element): bool {
        (std=0x1)::option::is_some(t) && (std=0x1)::option::borrow(t) == e
    }}
     spec borrow{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t)}
     spec borrow_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default_ref}
     spec get_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default}
     spec fill{pragma opaque;
    aborts_if (std=0x1)::option::is_some(t)(std=0x1)::option::EOPTION_IS_SET;
    ensures (std=0x1)::option::is_some(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec extract{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(old(t));
    ensures (std=0x1)::option::is_none(t)}
     spec borrow_mut{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t);
    ensures t == old(t)}
     spec swap{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(old(t));
    ensures (std=0x1)::option::is_some(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec swap_or_fill{pragma opaque;
    ensures result == old(t);
    ensures (std=0x1)::option::borrow(t) == e}
     spec destroy_with_default{pragma opaque;
    aborts_if false;
    ensures result == if ((std=0x1)::option::is_some(t)) (std=0x1)::option::borrow(t) else default}
     spec destroy_some{pragma opaque;
    include (std=0x1)::option::AbortsIfNone<Element>;
    ensures result == (std=0x1)::option::borrow(t)}
     spec destroy_none{pragma opaque;
    aborts_if (std=0x1)::option::is_some(t)(std=0x1)::option::EOPTION_IS_SET}
     spec to_vec{pragma opaque;
    aborts_if false;
    ensures result == t.vec}
     spec module {}
     spec module {pragma aborts_if_is_strict}
     spec schema AbortsIfNone<Element>{localt: (std=0x1)::option::Option<Element>;
    aborts_if (std=0x1)::option::is_none(t)(std=0x1)::option::EOPTION_NOT_SET}

}
module (std=0x1)::signer {
    #[]source module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address(s)
    }
    #[]public native fun borrow_address(s: &signer): &address;

     spec module {native define is_txn_signer(s: signer): bool;
    }
     spec module {native define is_txn_signer_addr(a: address): bool;
    }

}
module (std=0x1)::string {
    #[]source module
    dependency order #4
    neighbor#dependency (std=0x1)::option;
    neighbor#dependency (std=0x1)::vector;
    uses address (std=0x1);
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append(&mut s.bytes, r.bytes)
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append(s, (std=0x1)::string::utf8(bytes))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of(&s.bytes, &r.bytes)
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes = &s.bytes;
        assert!(at <= (std=0x1)::vector::length(bytes) && (std=0x1)::string::internal_is_char_boundary(bytes, at), (std=0x1)::string::EINVALID_INDEX);
        let l = (std=0x1)::string::length(s);
        let front = (std=0x1)::string::sub_string(s, 0, at);
        let end = (std=0x1)::string::sub_string(s, at, l);
        (std=0x1)::string::append(&mut front, o);
        (std=0x1)::string::append(&mut front, end);
        *s = front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty(&s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length(&s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes = &s.bytes;
        let l = (std=0x1)::vector::length(bytes);
        assert!(j <= l && i <= j && (std=0x1)::string::internal_is_char_boundary(bytes, i) && (std=0x1)::string::internal_is_char_boundary(bytes, j), (std=0x1)::string::EINVALID_INDEX);
        (std=0x1)::string::String{0#bytes: (std=0x1)::string::internal_sub_string(bytes, i, j)}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8(&bytes))  {
            (std=0x1)::option::some((std=0x1)::string::String{0#bytes: bytes})
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert!((std=0x1)::string::internal_check_utf8(&bytes), (std=0x1)::string::EINVALID_UTF8);
        (std=0x1)::string::String{0#bytes: bytes}
    }

}
module (std=0x1)::type_name {
    #[]source module
    dependency order #5
    neighbor#dependency (std=0x1)::ascii;
    uses address (std=0x1);
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &self.name
    }
    #[]public native fun get<T>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        self.name
    }

}
module (std=0x1)::vector {
    #[]source module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public fun append<Element>(lhs: &mut vector<Element>, other: vector<Element>): () {
        (std=0x1)::vector::reverse(&mut other);
        while (! (std=0x1)::vector::is_empty(&other))(std=0x1)::vector::push_back(lhs, (std=0x1)::vector::pop_back(&mut other));
        (std=0x1)::vector::destroy_empty(other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;

    #[bytecode_instruction]public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;

    #[]public fun contains<Element>(v: &vector<Element>, e: &Element): bool {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return true else ();
            i = i + 1;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element>(v: vector<Element>): ();

    #[bytecode_instruction]public native fun empty<Element>(): vector<Element>;

    #[]public inline fun filter<Element: drop>(v: vector<Element>, p: |&Element|bool): vector<Element> {
        let result = vector<Element>[];
        (std=0x1)::vector::for_each(v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back(&mut result, elem) else ();
            /*()*/
        });
        result
    }
    #[]public inline fun fold<Accumulator, Element>(v: vector<Element>, init: Accumulator, f: |Accumulator, Element|Accumulator): Accumulator {
        let accu = init;
        (std=0x1)::vector::for_each(v, |elem|accu = f(accu, elem));
        accu
    }
    #[]public inline fun for_each<Element>(v: vector<Element>, f: |Element|()): () {
        (std=0x1)::vector::reverse(&mut v);
        while (! (std=0x1)::vector::is_empty(&v)) {
            let e = (std=0x1)::vector::pop_back(&mut v);
            f(e);
            /*()*/
        };
        /*()*/
    }
    #[]public inline fun for_each_mut<Element>(v: &mut vector<Element>, f: |&mut Element|()): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow_mut(v, i));
            i = i + 1
        }
    }
    #[]public inline fun for_each_ref<Element>(v: &vector<Element>, f: |&Element|()): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow(v, i));
            i = i + 1
        }
    }
    #[]public fun index_of<Element>(v: &vector<Element>, e: &Element): (bool, u64) {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return (true, i) else ();
            i = i + 1;
            /*()*/
        };
        (false, 0)
    }
    #[]public fun is_empty<Element>(v: &vector<Element>): bool {
        (std=0x1)::vector::length(v) == 0
    }
    #[bytecode_instruction]public native fun length<Element>(v: &vector<Element>): u64;

    #[]public inline fun map<Element, NewElement>(v: vector<Element>, f: |Element|NewElement): vector<NewElement> {
        let result = vector<NewElement>[];
        (std=0x1)::vector::for_each(v, |elem|(std=0x1)::vector::push_back(&mut result, f(elem)));
        result
    }
    #[bytecode_instruction]public native fun pop_back<Element>(v: &mut vector<Element>): Element;

    #[bytecode_instruction]public native fun push_back<Element>(v: &mut vector<Element>, e: Element): ();

    #[]public fun remove<Element>(v: &mut vector<Element>, i: u64): Element {
        let len = (std=0x1)::vector::length(v);
        if (i >= len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len = len - 1;
        while (i < len)(std=0x1)::vector::swap(v, i,  {
            i = i + 1;
            i
        });
        (std=0x1)::vector::pop_back(v)
    }
    #[]public fun reverse<Element>(v: &mut vector<Element>): () {
        let len = (std=0x1)::vector::length(v);
        if (len == 0) return () else ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            (std=0x1)::vector::swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;
            /*()*/
        }
    }
    #[]public fun singleton<Element>(e: Element): vector<Element> {
        let v = (std=0x1)::vector::empty();
        (std=0x1)::vector::push_back(&mut v, e);
        v
    }
    #[bytecode_instruction]public native fun swap<Element>(v: &mut vector<Element>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element>(v: &mut vector<Element>, i: u64): Element {
        assert!(! (std=0x1)::vector::is_empty(v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS);
        let last_idx = (std=0x1)::vector::length(v) - 1;
        (std=0x1)::vector::swap(v, i, last_idx);
        (std=0x1)::vector::pop_back(v)
    }
     spec singleton{aborts_if false;
    ensures result == vec(e)}
     spec reverse{pragma intrinsic = true}
     spec append{pragma intrinsic = true}
     spec is_empty{pragma intrinsic = true}
     spec contains{pragma intrinsic = true}
     spec index_of{pragma intrinsic = true}
     spec remove{pragma intrinsic = true}
     spec swap_remove{pragma intrinsic = true}
     spec module {}
     spec module {define eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
        len(v1) == len(v2) + 1 && v1[len(v1) - 1] == e && v1[0 .. len(v1) - 1] == v2[0 .. len(v2)]
    };
    define eq_append<Element>(v: vector<Element>, v1: vector<Element>, v2: vector<Element>): bool {
        len(v) == len(v1) + len(v2) && v[0 .. len(v1)] == v1 && v[len(v1) .. len(v)] == v2
    };
    define eq_pop_front<Element>(v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1 == v2[1 .. len(v2)]
    };
    define eq_remove_elem_at_index<Element>(i: u64, v1: vector<Element>, v2: vector<Element>): bool {
        len(v1) + 1 == len(v2) && v1[0 .. i] == v2[0 .. i] && v1[i .. len(v1)] == v2[i + 1 .. len(v2)]
    }}

}
After naming: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len = (std=0x1)::vector::length(&string.bytes);
        let i = 0;
        while ( {
            spec #0 uses [i, len, string];
            i < len
        }) {
            let byte = *(std=0x1)::vector::borrow(&string.bytes, i);
            if (! (std=0x1)::ascii::is_printable_char(byte)) return false else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [i, len, string];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char{0#byte: byte} = char;
        byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert((std=0x1)::ascii::is_valid_char(byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::ascii::Char{0#byte: byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String{0#bytes: bytes} = string;
        bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        byte >= 32 && byte <= 126
    }
    #[]public fun is_valid_char(b: u8): bool {
        b <= 127
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length((std=0x1)::ascii::as_bytes(string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char{0#byte: (std=0x1)::vector::pop_back(&mut string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back(&mut string.bytes, (&*)char.byte);
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x = (std=0x1)::ascii::try_string(bytes);
        assert((std=0x1)::option::is_some(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER);
        (std=0x1)::option::destroy_some(x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len = (std=0x1)::vector::length(&bytes);
        let i = 0;
        while ( {
            spec #0 uses [bytes, i, len];
            i < len
        }) {
            let possible_byte = *(std=0x1)::vector::borrow(&bytes, i);
            if (! (std=0x1)::ascii::is_valid_char(possible_byte)) return (std=0x1)::option::none() else ();
            i = i + 1;
            /*()*/
        };
        spec #1 uses [bytes, i, len];
        (std=0x1)::option::some((std=0x1)::ascii::String{0#bytes: bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#483>(v: &MoveValue#483): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        *(std=0x1)::vector::borrow(&bitvector.bit_field, bit_index)
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length(&bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert(start_index < (&*)bitvector.length, (std=0x1)::bit_vector::EINDEX);
        let index = start_index;
        while (index < (&*)bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set(bitvector, index)) break else ();
            index = index + 1;
            /*()*/
        };
        index - start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert(length > 0, (std=0x1)::bit_vector::ELENGTH);
        assert(length < (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH);
        let counter = 0;
        let bit_field = (std=0x1)::vector::empty();
        while ( {
            spec #0 uses [bit_field, counter, length] applies [len];
            counter < length
        }) {
            (std=0x1)::vector::push_back(&mut bit_field, false);
            counter = counter + 1;
            /*()*/
        };
        spec #1 uses [bit_field, counter, length] applies [len];
        (std=0x1)::bit_vector::BitVector{1#bit_field: bit_field, 0#length: length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (amount >= (&*)bitvector.length)  {
            let len = (std=0x1)::vector::length(&bitvector.bit_field);
            let i = 0;
            while (i < len) {
                let elem = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, i);
                *elem = false;
                i = i + 1;
                /*()*/
            };
            /*()*/
        } else  {
            let i = amount;
            while (i < (&*)bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set(bitvector, i)) (std=0x1)::bit_vector::set(bitvector, i - amount) else (std=0x1)::bit_vector::unset(bitvector, i - amount);
                i = i + 1;
                /*()*/
            };
            i = (&*)bitvector.length - amount;
            while (i < (&*)bitvector.length) {
                (std=0x1)::bit_vector::unset(bitvector, i);
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert(bit_index < (std=0x1)::vector::length(&bitvector.bit_field), (std=0x1)::bit_vector::EINDEX);
        let x = (std=0x1)::vector::borrow_mut(&mut bitvector.bit_field, bit_index);
        *x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ABORTED, r)
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::ALREADY_EXISTS, r)
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        category << 16 + reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INTERNAL, r)
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_ARGUMENT, r)
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::INVALID_STATE, r)
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_FOUND, r)
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::NOT_IMPLEMENTED, r)
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::OUT_OF_RANGE, r)
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::PERMISSION_DENIED, r)
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::RESOURCE_EXHAUSTED, r)
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAUTHENTICATED, r)
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical((std=0x1)::error::UNAVAILABLE, r)
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        if ((&*)num.value == floored_num)  {
            return floored_num >> 32
        } else ();
        let val = (floored_num as u128) + 1 << 32;
        (val >> 32 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator = (numerator as u128) << 64;
        let scaled_denominator = (denominator as u128) << 32;
        assert(scaled_denominator != 0, (std=0x1)::fixed_point32::EDENOMINATOR);
        let quotient = scaled_numerator / scaled_denominator;
        assert(quotient != 0 || numerator == 0, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        assert(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32{0#value: value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value = (val as u128) << 32;
        assert(value <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE);
        (std=0x1)::fixed_point32::FixedPoint32{0#value: (value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((&*)divisor.value != 0, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO);
        let scaled_value = (val as u128) << 32;
        let quotient = scaled_value / ((&*)divisor.value as u128);
        assert(quotient <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION);
        (quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        (&*)num.value >> 32
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        (&*)num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        (&*)num.value == 0
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if ((&*)num1.value > (&*)num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if ((&*)num1.value < (&*)num2.value)  {
            num1
        } else  {
            num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product = (val as u128) * ((&*)multiplier.value as u128);
        let product = unscaled_product >> 32;
        assert(product <= (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION);
        (product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num = (std=0x1)::fixed_point32::floor(num) << 32;
        let boundary = floored_num + 1 << 32 / 2;
        if ((&*)num.value < boundary)  {
            floored_num >> 32
        } else  {
            (std=0x1)::fixed_point32::ceil(num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#484> has copy drop store {
        0#vec: vector<Element#484>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public fun borrow<Element#485>(t: &(std=0x1)::option::Option<Element#485>): &Element#485 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow(&t.vec, 0)
    }
    #[]public fun borrow_mut<Element#486>(t: &mut (std=0x1)::option::Option<Element#486>): &mut Element#486 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::borrow_mut(&mut t.vec, 0)
    }
    #[]public fun borrow_with_default<Element#487>(t: &(std=0x1)::option::Option<Element#487>, default_ref: &Element#487): &Element#487 {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default_ref else (std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun contains<Element#488>(t: &(std=0x1)::option::Option<Element#488>, e_ref: &Element#488): bool {
        (std=0x1)::vector::contains(&t.vec, e_ref)
    }
    #[]public fun destroy_none<Element#489>(t: (std=0x1)::option::Option<Element#489>): () {
        assert((std=0x1)::option::is_none(&t), (std=0x1)::option::EOPTION_IS_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        (std=0x1)::vector::destroy_empty(vec)
    }
    #[]public fun destroy_some<Element#490>(t: (std=0x1)::option::Option<Element#490>): Element#490 {
        assert((std=0x1)::option::is_some(&t), (std=0x1)::option::EOPTION_NOT_SET);
        let (std=0x1)::option::Option{0#vec: vec} = t;
        let elem = (std=0x1)::vector::pop_back(&mut vec);
        (std=0x1)::vector::destroy_empty(vec);
        elem
    }
    #[]public fun destroy_with_default<Element#491: drop>(t: (std=0x1)::option::Option<Element#491: drop>, default: Element#491: drop): Element#491: drop {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        if ((std=0x1)::vector::is_empty(&mut vec)) default else (std=0x1)::vector::pop_back(&mut vec)
    }
    #[]public fun extract<Element#492>(t: &mut (std=0x1)::option::Option<Element#492>): Element#492 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        (std=0x1)::vector::pop_back(&mut t.vec)
    }
    #[]public fun fill<Element#493>(t: &mut (std=0x1)::option::Option<Element#493>, e: Element#493): () {
        let vec_ref = &mut t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::vector::push_back(vec_ref, e) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public inline fun filter<Element#494: drop>(o: (std=0x1)::option::Option<Element#494: drop>, f: |..|..<&Element#494: drop, bool>): (std=0x1)::option::Option<Element#494: drop> {
        if ((std=0x1)::option::is_some(&o) && f((std=0x1)::option::borrow(&o)))  {
            o
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public inline fun fold<Accumulator#495, Element#496>(o: (std=0x1)::option::Option<Element#496>, init: Accumulator#495, f: |..|..<Accumulator#495, Element#496, Accumulator#495>): Accumulator#495 {
        if ((std=0x1)::option::is_some(&o))  {
            f(init, (std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o);
            init
        }
    }
    #[]public inline fun for_each<Element#497>(o: (std=0x1)::option::Option<Element#497>, f: |..|..<Element#497, ()>): () {
        if ((std=0x1)::option::is_some(&o))  {
            f((std=0x1)::option::destroy_some(o))
        } else  {
            (std=0x1)::option::destroy_none(o)
        }
    }
    #[]public inline fun for_each_mut<Element#498>(o: &mut (std=0x1)::option::Option<Element#498>, f: |..|..<&mut Element#498, ()>): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow_mut(o))
        } else ()
    }
    #[]public inline fun for_each_ref<Element#499>(o: &(std=0x1)::option::Option<Element#499>, f: |..|..<&Element#499, ()>): () {
        if ((std=0x1)::option::is_some(o))  {
            f((std=0x1)::option::borrow(o))
        } else ()
    }
    #[]public fun get_with_default<Element#500: copy+drop>(t: &(std=0x1)::option::Option<Element#500: copy+drop>, default: Element#500: copy+drop): Element#500: copy+drop {
        let vec_ref = &t.vec;
        if ((std=0x1)::vector::is_empty(vec_ref)) default else *(std=0x1)::vector::borrow(vec_ref, 0)
    }
    #[]public fun is_none<Element#501>(t: &(std=0x1)::option::Option<Element#501>): bool {
        (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public fun is_some<Element#502>(t: &(std=0x1)::option::Option<Element#502>): bool {
        ! (std=0x1)::vector::is_empty(&t.vec)
    }
    #[]public inline fun map<Element#503, OtherElement#504>(o: (std=0x1)::option::Option<Element#503>, f: |..|..<Element#503, OtherElement#504>): (std=0x1)::option::Option<OtherElement#504> {
        if ((std=0x1)::option::is_some(&o))  {
            (std=0x1)::option::some(f((std=0x1)::option::destroy_some(o)))
        } else  {
            (std=0x1)::option::destroy_none(o);
            (std=0x1)::option::none()
        }
    }
    #[]public fun none<Element#505>(): (std=0x1)::option::Option<Element#505> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::empty()}
    }
    #[]public fun some<Element#506>(e: Element#506): (std=0x1)::option::Option<Element#506> {
        (std=0x1)::option::Option{0#vec: (std=0x1)::vector::singleton(e)}
    }
    #[]public fun swap<Element#507>(t: &mut (std=0x1)::option::Option<Element#507>, e: Element#507): Element#507 {
        assert((std=0x1)::option::is_some(t), (std=0x1)::option::EOPTION_NOT_SET);
        let vec_ref = &mut t.vec;
        let old_value = (std=0x1)::vector::pop_back(vec_ref);
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun swap_or_fill<Element#508>(t: &mut (std=0x1)::option::Option<Element#508>, e: Element#508): (std=0x1)::option::Option<Element#508> {
        let vec_ref = &mut t.vec;
        let old_value = if ((std=0x1)::vector::is_empty(vec_ref)) (std=0x1)::option::none() else (std=0x1)::option::some((std=0x1)::vector::pop_back(vec_ref));
        (std=0x1)::vector::push_back(vec_ref, e);
        old_value
    }
    #[]public fun to_vec<Element#509>(t: (std=0x1)::option::Option<Element#509>): vector<Element#509> {
        let (std=0x1)::option::Option{0#vec: vec} = t;
        vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address(s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append(&mut s.bytes, (&*)r.bytes)
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append(s, (std=0x1)::string::utf8(bytes))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of(&s.bytes, &r.bytes)
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes = &s.bytes;
        assert(at <= (std=0x1)::vector::length(bytes) && (std=0x1)::string::internal_is_char_boundary(bytes, at), (std=0x1)::string::EINVALID_INDEX);
        let l = (std=0x1)::string::length(s);
        let front = (std=0x1)::string::sub_string(s, 0, at);
        let end = (std=0x1)::string::sub_string(s, at, l);
        (std=0x1)::string::append(&mut front, o);
        (std=0x1)::string::append(&mut front, end);
        *s = front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty(&s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length(&s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes = &s.bytes;
        let l = (std=0x1)::vector::length(bytes);
        assert(j <= l && i <= j && (std=0x1)::string::internal_is_char_boundary(bytes, i) && (std=0x1)::string::internal_is_char_boundary(bytes, j), (std=0x1)::string::EINVALID_INDEX);
        (std=0x1)::string::String{0#bytes: (std=0x1)::string::internal_sub_string(bytes, i, j)}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8(&bytes))  {
            (std=0x1)::option::some((std=0x1)::string::String{0#bytes: bytes})
        } else  {
            (std=0x1)::option::none()
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert((std=0x1)::string::internal_check_utf8(&bytes), (std=0x1)::string::EINVALID_UTF8);
        (std=0x1)::string::String{0#bytes: bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &self.name
    }
    #[]public native fun get<T#510>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        (&*)self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public fun append<Element#511>(lhs: &mut vector<Element#511>, other: vector<Element#511>): () {
        (std=0x1)::vector::reverse(&mut other);
        while (! (std=0x1)::vector::is_empty(&other))(std=0x1)::vector::push_back(lhs, (std=0x1)::vector::pop_back(&mut other));
        (std=0x1)::vector::destroy_empty(other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#512>(v: &vector<Element#512>, i: u64): &Element#512;

    #[bytecode_instruction]public native fun borrow_mut<Element#513>(v: &mut vector<Element#513>, i: u64): &mut Element#513;

    #[]public fun contains<Element#514>(v: &vector<Element#514>, e: &Element#514): bool {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return true else ();
            i = i + 1;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#515>(v: vector<Element#515>): ();

    #[bytecode_instruction]public native fun empty<Element#516>(): vector<Element#516>;

    #[]public inline fun filter<Element#517: drop>(v: vector<Element#517: drop>, p: |..|..<&Element#517: drop, bool>): vector<Element#517: drop> {
        let result = vector<Element#517: drop>[];
        (std=0x1)::vector::for_each(v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back(&mut result, elem) else ();
            /*()*/
        });
        result
    }
    #[]public inline fun fold<Accumulator#518, Element#519>(v: vector<Element#519>, init: Accumulator#518, f: |..|..<Accumulator#518, Element#519, Accumulator#518>): Accumulator#518 {
        let accu = init;
        (std=0x1)::vector::for_each(v, |elem|accu = f(accu, elem));
        accu
    }
    #[]public inline fun for_each<Element#520>(v: vector<Element#520>, f: |..|..<Element#520, ()>): () {
        (std=0x1)::vector::reverse(&mut v);
        while (! (std=0x1)::vector::is_empty(&v)) {
            let e = (std=0x1)::vector::pop_back(&mut v);
            f(e);
            /*()*/
        };
        /*()*/
    }
    #[]public inline fun for_each_mut<Element#521>(v: &mut vector<Element#521>, f: |..|..<&mut Element#521, ()>): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow_mut(v, i));
            i = i + 1
        }
    }
    #[]public inline fun for_each_ref<Element#522>(v: &vector<Element#522>, f: |..|..<&Element#522, ()>): () {
        let i = 0;
        while (i < (std=0x1)::vector::length(v)) {
            f((std=0x1)::vector::borrow(v, i));
            i = i + 1
        }
    }
    #[]public fun index_of<Element#523>(v: &vector<Element#523>, e: &Element#523): (bool, u64) {
        let i = 0;
        let len = (std=0x1)::vector::length(v);
        while (i < len) {
            if ((std=0x1)::vector::borrow(v, i) == e) return (true, i) else ();
            i = i + 1;
            /*()*/
        };
        (false, 0)
    }
    #[]public fun is_empty<Element#524>(v: &vector<Element#524>): bool {
        (std=0x1)::vector::length(v) == 0
    }
    #[bytecode_instruction]public native fun length<Element#525>(v: &vector<Element#525>): u64;

    #[]public inline fun map<Element#526, NewElement#527>(v: vector<Element#526>, f: |..|..<Element#526, NewElement#527>): vector<NewElement#527> {
        let result = vector<NewElement#527>[];
        (std=0x1)::vector::for_each(v, |elem|(std=0x1)::vector::push_back(&mut result, f(elem)));
        result
    }
    #[bytecode_instruction]public native fun pop_back<Element#528>(v: &mut vector<Element#528>): Element#528;

    #[bytecode_instruction]public native fun push_back<Element#529>(v: &mut vector<Element#529>, e: Element#529): ();

    #[]public fun remove<Element#530>(v: &mut vector<Element#530>, i: u64): Element#530 {
        let len = (std=0x1)::vector::length(v);
        if (i >= len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len = len - 1;
        while (i < len)(std=0x1)::vector::swap(v, i,  {
            i = i + 1;
            i
        });
        (std=0x1)::vector::pop_back(v)
    }
    #[]public fun reverse<Element#531>(v: &mut vector<Element#531>): () {
        let len = (std=0x1)::vector::length(v);
        if (len == 0) return () else ();
        let front_index = 0;
        let back_index = len - 1;
        while (front_index < back_index) {
            (std=0x1)::vector::swap(v, front_index, back_index);
            front_index = front_index + 1;
            back_index = back_index - 1;
            /*()*/
        }
    }
    #[]public fun singleton<Element#532>(e: Element#532): vector<Element#532> {
        let v = (std=0x1)::vector::empty();
        (std=0x1)::vector::push_back(&mut v, e);
        v
    }
    #[bytecode_instruction]public native fun swap<Element#533>(v: &mut vector<Element#533>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#534>(v: &mut vector<Element#534>, i: u64): Element#534 {
        assert(! (std=0x1)::vector::is_empty(v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS);
        let last_idx = (std=0x1)::vector::length(v) - 1;
        (std=0x1)::vector::swap(v, i, last_idx);
        (std=0x1)::vector::pop_back(v)
    }

}
After typing: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536u64;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy string.bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [i (i), len (len), string (string)];
            copy i <@u64 copy len
        }) {
            let byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char[parameter_types: [u8]<>(copy byte)) return false else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 uses [i (i), len (len), string (string)];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char<>{0#byte: byte}: ((std=0x1)::ascii::Char) = copy char;
        copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert(((std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::ascii::Char<>{(0#byte:u8): copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String<>{0#bytes: bytes}: ((std=0x1)::ascii::String) = copy string;
        copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        copy byte >=@u8 32u8 &&@bool copy byte <=@u8 126u8
    }
    #[]public fun is_valid_char(b: u8): bool {
        copy b <=@u8 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>((std=0x1)::ascii::as_bytes[parameter_types: [&(std=0x1)::ascii::String]<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char<>{(0#byte:u8): (std=0x1)::vector::pop_back[parameter_types: [&mut vector<u8>]<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<u8>, u8]<u8>((&mut copy string.bytes, *&&char.byte));
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x: ((std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string[parameter_types: [vector<u8>]<>(copy bytes);
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [bytes (bytes), i (i), len (len)];
            copy i <@u64 copy len
        }) {
            let possible_byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy possible_byte)) return (std=0x1)::option::none<(std=0x1)::ascii::String>(()) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 uses [bytes (bytes), i (i), len (len)];
        (std=0x1)::option::some[parameter_types: [(std=0x1)::ascii::String]<(std=0x1)::ascii::String>((std=0x1)::ascii::String<>{(0#bytes:vector<u8>): copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#483>(v: &MoveValue#483): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072u64;
    #[]const ELENGTH:u64 = 131073u64;
    #[]const MAX_SIZE:u64 = 1024u64;
    #[]const WORD_SIZE:u64 = 1u64;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        *(std=0x1)::vector::borrow[parameter_types: [&vector<bool>, u64]<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert((copy start_index <@u64 *&copy bitvector.length, (std=0x1)::bit_vector::EINDEX));
        let index: (u64) = copy start_index;
        while (copy index <@u64 *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy index))) break else ();
            index: (u64) = copy index +@u64 1u64;
            /*()*/
        };
        copy index -@u64 copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert((copy length >@u64 0u64, (std=0x1)::bit_vector::ELENGTH));
        assert((copy length <@u64 (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH));
        let counter: (u64) = 0u64;
        let bit_field: (vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            spec #0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter <@u64 copy length
        }) {
            (std=0x1)::vector::push_back[parameter_types: [&mut vector<bool>, bool]<bool>((&mut bit_field, false));
            counter: (u64) = copy counter +@u64 1u64;
            /*()*/
        };
        spec #1 uses [bit_field (bit_field), counter (counter), length (length)];
        (std=0x1)::bit_vector::BitVector<>{(1#bit_field:vector<bool>): copy bit_field, (0#length:u64): copy length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (copy amount >=@u64 *&copy bitvector.length)  {
            let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field);
            let i: (u64) = 0u64;
            while (copy i <@u64 copy len) {
                let elem: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        } else  {
            let i: (u64) = copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i))) (std=0x1)::bit_vector::set[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount)) else (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            i: (u64) = *&copy bitvector.length -@u64 copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7u64;
    #[]const ALREADY_EXISTS:u64 = 8u64;
    #[]const CANCELLED:u64 = 10u64;
    #[]const INTERNAL:u64 = 11u64;
    #[]const INVALID_ARGUMENT:u64 = 1u64;
    #[]const INVALID_STATE:u64 = 3u64;
    #[]const NOT_FOUND:u64 = 6u64;
    #[]const NOT_IMPLEMENTED:u64 = 12u64;
    #[]const OUT_OF_RANGE:u64 = 2u64;
    #[]const PERMISSION_DENIED:u64 = 5u64;
    #[]const RESOURCE_EXHAUSTED:u64 = 9u64;
    #[]const UNAUTHENTICATED:u64 = 4u64;
    #[]const UNAVAILABLE:u64 = 13u64;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        copy category <<@u64 16u8 +@u64 copy reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537u64;
    #[]const EDIVISION:u64 = 131074u64;
    #[]const EDIVISION_BY_ZERO:u64 = 65540u64;
    #[]const EMULTIPLICATION:u64 = 131075u64;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077u64;
    #[]const MAX_U64:u128 = 18446744073709551615u128;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        if (*&&num.value ==@u64 copy floored_num)  {
            return copy floored_num >>@u64 32u8
        } else ();
        let val: (u128) = (copy floored_num as u128) +@u128 1u128 <<@u128 32u8;
        (copy val >>@u128 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator: (u128) = (copy numerator as u128) <<@u128 64u8;
        let scaled_denominator: (u128) = (copy denominator as u128) <<@u128 32u8;
        assert((copy scaled_denominator !=@u128 0u128, (std=0x1)::fixed_point32::EDENOMINATOR));
        let quotient: (u128) = copy scaled_numerator /@u128 copy scaled_denominator;
        assert((copy quotient !=@u128 0u128 ||@bool copy numerator ==@u64 0u64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value: (u128) = (copy val as u128) <<@u128 32u8;
        assert((copy value <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((*&&divisor.value !=@u64 0u64, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO));
        let scaled_value: (u128) = (copy val as u128) <<@u128 32u8;
        let quotient: (u128) = copy scaled_value /@u128 (*&&divisor.value as u128);
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION));
        (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value >>@u64 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        *&&num.value ==@u64 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value >@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value <@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product: (u128) = (copy val as u128) *@u128 (*&&multiplier.value as u128);
        let product: (u128) = copy unscaled_product >>@u128 32u8;
        assert((copy product <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION));
        (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        let boundary: (u64) = copy floored_num +@u64 1u64 <<@u64 32u8 /@u64 2u64;
        if (*&&num.value <@u64 copy boundary)  {
            copy floored_num >>@u64 32u8
        } else  {
            (std=0x1)::fixed_point32::ceil[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#484> has copy drop store {
        0#vec: vector<Element#484>
    }
    #[]const EOPTION_IS_SET:u64 = 262144u64;
    #[]const EOPTION_NOT_SET:u64 = 262145u64;
    #[]public fun borrow<Element#485>(t: &(std=0x1)::option::Option<Element#485>): &Element#485 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#485>]<Element#485>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow[parameter_types: [&vector<Element#485>, u64]<Element#485>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#486>(t: &mut (std=0x1)::option::Option<Element#486>): &mut Element#486 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#486>]<Element#486>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#486>, u64]<Element#486>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#487>(t: &(std=0x1)::option::Option<Element#487>, default_ref: &Element#487): &Element#487 {
        let vec_ref: (&vector<Element#487>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#487>]<Element#487>(copy vec_ref)) copy default_ref else (std=0x1)::vector::borrow[parameter_types: [&vector<Element#487>, u64]<Element#487>((copy vec_ref, 0u64))
    }
    #[]public fun contains<Element#488>(t: &(std=0x1)::option::Option<Element#488>, e_ref: &Element#488): bool {
        (std=0x1)::vector::contains[parameter_types: [&vector<Element#488>, &Element#488]<Element#488>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#489>(t: (std=0x1)::option::Option<Element#489>): () {
        assert(((std=0x1)::option::is_none[parameter_types: [&(std=0x1)::option::Option<Element#489>]<Element#489>(&t), (std=0x1)::option::EOPTION_IS_SET));
        let (std=0x1)::option::Option<Element#489>{0#vec: vec}: ((std=0x1)::option::Option<Element#489>) = move t;
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#489>]<Element#489>(move vec)
    }
    #[]public fun destroy_some<Element#490>(t: (std=0x1)::option::Option<Element#490>): Element#490 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#490>]<Element#490>(&t), (std=0x1)::option::EOPTION_NOT_SET));
        let (std=0x1)::option::Option<Element#490>{0#vec: vec}: ((std=0x1)::option::Option<Element#490>) = move t;
        let elem: (Element#490) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#490>]<Element#490>(&mut vec);
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#490>]<Element#490>(move vec);
        move elem
    }
    #[]public fun destroy_with_default<Element#491: drop>(t: (std=0x1)::option::Option<Element#491: drop>, default: Element#491: drop): Element#491: drop {
        let (std=0x1)::option::Option<Element#491: drop>{0#vec: vec}: ((std=0x1)::option::Option<Element#491: drop>) = move t;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#491: drop>]<Element#491: drop>(&mut vec)) move default else (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#491: drop>]<Element#491: drop>(&mut vec)
    }
    #[]public fun extract<Element#492>(t: &mut (std=0x1)::option::Option<Element#492>): Element#492 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#492>]<Element#492>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#492>]<Element#492>(&mut copy t.vec)
    }
    #[]public fun fill<Element#493>(t: &mut (std=0x1)::option::Option<Element#493>, e: Element#493): () {
        let vec_ref: (&mut vector<Element#493>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#493>]<Element#493>(copy vec_ref)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#493>, Element#493]<Element#493>((copy vec_ref, move e)) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public fun filter!<Element#494: drop>(o: (std=0x1)::option::Option<Element#494: drop>, f: |..|..<&Element#494: drop, bool>): (std=0x1)::option::Option<Element#494: drop> {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#494: drop>]<Element#494: drop>(&o) &&@bool f((std=0x1)::option::borrow[parameter_types: [&(std=0x1)::option::Option<Element#494: drop>]<Element#494: drop>(&o)))  {
            move o
        } else  {
            (std=0x1)::option::none<Element#494: drop>(())
        }
    }
    #[]public fun fold!<Accumulator#495, Element#496>(o: (std=0x1)::option::Option<Element#496>, init: Accumulator#495, f: |..|..<Accumulator#495, Element#496, Accumulator#495>): Accumulator#495 {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#496>]<Element#496>(&o))  {
            f((move init, (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#496>]<Element#496>(move o)))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#496>]<Element#496>(move o);
            move init
        }
    }
    #[]public fun for_each!<Element#497>(o: (std=0x1)::option::Option<Element#497>, f: |..|..<Element#497, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#497>]<Element#497>(&o))  {
            f((std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#497>]<Element#497>(move o))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#497>]<Element#497>(move o)
        }
    }
    #[]public fun for_each_mut!<Element#498>(o: &mut (std=0x1)::option::Option<Element#498>, f: |..|..<&mut Element#498, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#498>]<Element#498>(copy o))  {
            f((std=0x1)::option::borrow_mut[parameter_types: [&mut (std=0x1)::option::Option<Element#498>]<Element#498>(copy o))
        } else ()
    }
    #[]public fun for_each_ref!<Element#499>(o: &(std=0x1)::option::Option<Element#499>, f: |..|..<&Element#499, ()>): () {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#499>]<Element#499>(copy o))  {
            f((std=0x1)::option::borrow[parameter_types: [&(std=0x1)::option::Option<Element#499>]<Element#499>(copy o))
        } else ()
    }
    #[]public fun get_with_default<Element#500: copy+drop>(t: &(std=0x1)::option::Option<Element#500: copy+drop>, default: Element#500: copy+drop): Element#500: copy+drop {
        let vec_ref: (&vector<Element#500: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#500: copy+drop>]<Element#500: copy+drop>(copy vec_ref)) copy default else *(std=0x1)::vector::borrow[parameter_types: [&vector<Element#500: copy+drop>, u64]<Element#500: copy+drop>((copy vec_ref, 0u64))
    }
    #[]public fun is_none<Element#501>(t: &(std=0x1)::option::Option<Element#501>): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#501>]<Element#501>(&copy t.vec)
    }
    #[]public fun is_some<Element#502>(t: &(std=0x1)::option::Option<Element#502>): bool {
        ! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#502>]<Element#502>(&copy t.vec)
    }
    #[]public fun map!<Element#503, OtherElement#504>(o: (std=0x1)::option::Option<Element#503>, f: |..|..<Element#503, OtherElement#504>): (std=0x1)::option::Option<OtherElement#504> {
        if ((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#503>]<Element#503>(&o))  {
            (std=0x1)::option::some[parameter_types: [OtherElement#504]<OtherElement#504>(f((std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<Element#503>]<Element#503>(move o)))
        } else  {
            (std=0x1)::option::destroy_none[parameter_types: [(std=0x1)::option::Option<Element#503>]<Element#503>(move o);
            (std=0x1)::option::none<OtherElement#504>(())
        }
    }
    #[]public fun none<Element#505>(): (std=0x1)::option::Option<Element#505> {
        (std=0x1)::option::Option<Element#505>{(0#vec:vector<Element#505>): (std=0x1)::vector::empty<Element#505>(())}
    }
    #[]public fun some<Element#506>(e: Element#506): (std=0x1)::option::Option<Element#506> {
        (std=0x1)::option::Option<Element#506>{(0#vec:vector<Element#506>): (std=0x1)::vector::singleton[parameter_types: [Element#506]<Element#506>(move e)}
    }
    #[]public fun swap<Element#507>(t: &mut (std=0x1)::option::Option<Element#507>, e: Element#507): Element#507 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#507>]<Element#507>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        let vec_ref: (&mut vector<Element#507>) = &mut copy t.vec;
        let old_value: (Element#507) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#507>]<Element#507>(copy vec_ref);
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#507>, Element#507]<Element#507>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun swap_or_fill<Element#508>(t: &mut (std=0x1)::option::Option<Element#508>, e: Element#508): (std=0x1)::option::Option<Element#508> {
        let vec_ref: (&mut vector<Element#508>) = &mut copy t.vec;
        let old_value: ((std=0x1)::option::Option<Element#508>) = if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#508>]<Element#508>(copy vec_ref)) (std=0x1)::option::none<Element#508>(()) else (std=0x1)::option::some[parameter_types: [Element#508]<Element#508>((std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#508>]<Element#508>(copy vec_ref));
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#508>, Element#508]<Element#508>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun to_vec<Element#509>(t: (std=0x1)::option::Option<Element#509>): vector<Element#509> {
        let (std=0x1)::option::Option<Element#509>{0#vec: vec}: ((std=0x1)::option::Option<Element#509>) = move t;
        move vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address[parameter_types: [&signer]<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2u64;
    #[]const EINVALID_UTF8:u64 = 1u64;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append[parameter_types: [&mut vector<u8>, vector<u8>]<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((copy s, (std=0x1)::string::utf8[parameter_types: [vector<u8>]<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of[parameter_types: [&vector<u8>, &vector<u8>]<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes: (&vector<u8>) = &copy s.bytes;
        assert((copy at <=@u64 (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy at)), (std=0x1)::string::EINVALID_INDEX));
        let l: (u64) = (std=0x1)::string::length[parameter_types: [&(std=0x1)::string::String]<>(copy s);
        let front: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, 0u64, copy at));
        let end: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, copy at, copy l));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy o));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy end));
        *copy s = copy front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes: (&vector<u8>) = &copy s.bytes;
        let l: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes);
        assert((copy j <=@u64 copy l &&@bool copy i <=@u64 copy j &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy i)) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy j)), (std=0x1)::string::EINVALID_INDEX));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): (std=0x1)::string::internal_sub_string[parameter_types: [&vector<u8>, u64, u64]<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes))  {
            (std=0x1)::option::some[parameter_types: [(std=0x1)::string::String]<(std=0x1)::string::String>((std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes})
        } else  {
            (std=0x1)::option::none<(std=0x1)::string::String>(())
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert(((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes), (std=0x1)::string::EINVALID_UTF8));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &copy self.name
    }
    #[]public native fun get<T#510>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072u64;
    #[]public fun append<Element#511>(lhs: &mut vector<Element#511>, other: vector<Element#511>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#511>]<Element#511>(&mut other);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#511>]<Element#511>(&other))(std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#511>, Element#511]<Element#511>((copy lhs, (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#511>]<Element#511>(&mut other)));
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#511>]<Element#511>(move other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#512>(v: &vector<Element#512>, i: u64): &Element#512;

    #[bytecode_instruction]public native fun borrow_mut<Element#513>(v: &mut vector<Element#513>, i: u64): &mut Element#513;

    #[]public fun contains<Element#514>(v: &vector<Element#514>, e: &Element#514): bool {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#514>]<Element#514>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#514>, u64]<Element#514>((copy v, copy i)) ==@&Element#514 copy e) return true else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#515>(v: vector<Element#515>): ();

    #[bytecode_instruction]public native fun empty<Element#516>(): vector<Element#516>;

    #[]public fun filter!<Element#517: drop>(v: vector<Element#517: drop>, p: |..|..<&Element#517: drop, bool>): vector<Element#517: drop> {
        let result: (vector<Element#517: drop>) = vector#0<Element#517: drop>[()];
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#517: drop>, |..|..<Element#517: drop, ()>]<Element#517: drop>((move v, |elem| {
            if (p(&elem)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#517: drop>, Element#517: drop]<Element#517: drop>((&mut result, move elem)) else ();
            /*()*/
        }));
        move result
    }
    #[]public fun fold!<Accumulator#518, Element#519>(v: vector<Element#519>, init: Accumulator#518, f: |..|..<Accumulator#518, Element#519, Accumulator#518>): Accumulator#518 {
        let accu: (Accumulator#518) = move init;
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#519>, |..|..<Element#519, ()>]<Element#519>((move v, |elem|accu: (Accumulator#518) = f((move accu, move elem))));
        move accu
    }
    #[]public fun for_each!<Element#520>(v: vector<Element#520>, f: |..|..<Element#520, ()>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#520>]<Element#520>(&mut v);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#520>]<Element#520>(&v)) {
            let e: (Element#520) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#520>]<Element#520>(&mut v);
            f(move e);
            /*()*/
        };
        /*()*/
    }
    #[]public fun for_each_mut!<Element#521>(v: &mut vector<Element#521>, f: |..|..<&mut Element#521, ()>): () {
        let i: (u64) = 0u64;
        while (copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<Element#521>]<Element#521>(copy v)) {
            f((std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#521>, u64]<Element#521>((copy v, copy i)));
            i: (u64) = copy i +@u64 1u64
        }
    }
    #[]public fun for_each_ref!<Element#522>(v: &vector<Element#522>, f: |..|..<&Element#522, ()>): () {
        let i: (u64) = 0u64;
        while (copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<Element#522>]<Element#522>(copy v)) {
            f((std=0x1)::vector::borrow[parameter_types: [&vector<Element#522>, u64]<Element#522>((copy v, copy i)));
            i: (u64) = copy i +@u64 1u64
        }
    }
    #[]public fun index_of<Element#523>(v: &vector<Element#523>, e: &Element#523): (bool, u64) {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#523>]<Element#523>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#523>, u64]<Element#523>((copy v, copy i)) ==@&Element#523 copy e) return (true, copy i) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        (false, 0u64)
    }
    #[]public fun is_empty<Element#524>(v: &vector<Element#524>): bool {
        (std=0x1)::vector::length[parameter_types: [&vector<Element#524>]<Element#524>(copy v) ==@u64 0u64
    }
    #[bytecode_instruction]public native fun length<Element#525>(v: &vector<Element#525>): u64;

    #[]public fun map!<Element#526, NewElement#527>(v: vector<Element#526>, f: |..|..<Element#526, NewElement#527>): vector<NewElement#527> {
        let result: (vector<NewElement#527>) = vector#0<NewElement#527>[()];
        (std=0x1)::vector::for_each[parameter_types: [vector<Element#526>, |..|..<Element#526, ()>]<Element#526>((move v, |elem|(std=0x1)::vector::push_back[parameter_types: [&mut vector<NewElement#527>, NewElement#527]<NewElement#527>((&mut result, f(move elem)))));
        move result
    }
    #[bytecode_instruction]public native fun pop_back<Element#528>(v: &mut vector<Element#528>): Element#528;

    #[bytecode_instruction]public native fun push_back<Element#529>(v: &mut vector<Element#529>, e: Element#529): ();

    #[]public fun remove<Element#530>(v: &mut vector<Element#530>, i: u64): Element#530 {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#530>]<Element#530>(copy v);
        if (copy i >=@u64 copy len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len: (u64) = copy len -@u64 1u64;
        while (copy i <@u64 copy len)(std=0x1)::vector::swap[parameter_types: [&mut vector<Element#530>, u64, u64]<Element#530>((copy v, copy i,  {
            i: (u64) = copy i +@u64 1u64;
            copy i
        }));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#530>]<Element#530>(copy v)
    }
    #[]public fun reverse<Element#531>(v: &mut vector<Element#531>): () {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#531>]<Element#531>(copy v);
        if (copy len ==@u64 0u64) return () else ();
        let front_index: (u64) = 0u64;
        let back_index: (u64) = copy len -@u64 1u64;
        while (copy front_index <@u64 copy back_index) {
            (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#531>, u64, u64]<Element#531>((copy v, copy front_index, copy back_index));
            front_index: (u64) = copy front_index +@u64 1u64;
            back_index: (u64) = copy back_index -@u64 1u64;
            /*()*/
        }
    }
    #[]public fun singleton<Element#532>(e: Element#532): vector<Element#532> {
        let v: (vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#532>, Element#532]<Element#532>((&mut v, move e));
        move v
    }
    #[bytecode_instruction]public native fun swap<Element#533>(v: &mut vector<Element#533>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#534>(v: &mut vector<Element#534>, i: u64): Element#534 {
        assert((! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#534>]<Element#534>(copy v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS));
        let last_idx: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#534>]<Element#534>(copy v) -@u64 1u64;
        (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#534>, u64, u64]<Element#534>((copy v, copy i, copy last_idx));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#534>]<Element#534>(copy v)
    }

}
After inlining: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        0#byte: u8
    }
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536u64;
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy string.bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            copy i <@u64 copy len
        }) {
            let byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char[parameter_types: [u8]<>(copy byte)) return false else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        let (std=0x1)::ascii::Char<>{0#byte: byte}: ((std=0x1)::ascii::Char) = copy char;
        copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        assert(((std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy byte), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::ascii::Char<>{(0#byte:u8): copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        let (std=0x1)::ascii::String<>{0#bytes: bytes}: ((std=0x1)::ascii::String) = copy string;
        copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        copy byte >=@u8 32u8 &&@bool copy byte <=@u8 126u8
    }
    #[]public fun is_valid_char(b: u8): bool {
        copy b <=@u8 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>((std=0x1)::ascii::as_bytes[parameter_types: [&(std=0x1)::ascii::String]<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        (std=0x1)::ascii::Char<>{(0#byte:u8): (std=0x1)::vector::pop_back[parameter_types: [&mut vector<u8>]<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<u8>, u8]<u8>((&mut copy string.bytes, *&&char.byte));
        /*()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        let x: ((std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string[parameter_types: [vector<u8>]<>(copy bytes);
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(&x), (std=0x1)::ascii::EINVALID_ASCII_CHARACTER));
        (std=0x1)::option::destroy_some[parameter_types: [(std=0x1)::option::Option<(std=0x1)::ascii::String>]<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&bytes);
        let i: (u64) = 0u64;
        while ( {
            spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            copy i <@u64 copy len
        }) {
            let possible_byte: (u8) = *(std=0x1)::vector::borrow[parameter_types: [&vector<u8>, u64]<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char[parameter_types: [u8]<>(copy possible_byte)) return (std=0x1)::option::none<(std=0x1)::ascii::String>(()) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        (std=0x1)::option::some[parameter_types: [(std=0x1)::ascii::String]<(std=0x1)::ascii::String>((std=0x1)::ascii::String<>{(0#bytes:vector<u8>): copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#483>(v: &MoveValue#483): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        1#bit_field: vector<bool>,
        0#length: u64
    }
    #[]const EINDEX:u64 = 131072u64;
    #[]const ELENGTH:u64 = 131073u64;
    #[]const MAX_SIZE:u64 = 1024u64;
    #[]const WORD_SIZE:u64 = 1u64;
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        *(std=0x1)::vector::borrow[parameter_types: [&vector<bool>, u64]<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        assert((copy start_index <@u64 *&copy bitvector.length, (std=0x1)::bit_vector::EINDEX));
        let index: (u64) = copy start_index;
        while (copy index <@u64 *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy index))) break else ();
            index: (u64) = copy index +@u64 1u64;
            /*()*/
        };
        copy index -@u64 copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        assert((copy length >@u64 0u64, (std=0x1)::bit_vector::ELENGTH));
        assert((copy length <@u64 (std=0x1)::bit_vector::MAX_SIZE, (std=0x1)::bit_vector::ELENGTH));
        let counter: (u64) = 0u64;
        let bit_field: (vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter <@u64 copy length
        }) {
            (std=0x1)::vector::push_back[parameter_types: [&mut vector<bool>, bool]<bool>((&mut bit_field, false));
            counter: (u64) = copy counter +@u64 1u64;
            /*()*/
        };
        spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        (std=0x1)::bit_vector::BitVector<>{(1#bit_field:vector<bool>): copy bit_field, (0#length:u64): copy length}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        /*()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        if (copy amount >=@u64 *&copy bitvector.length)  {
            let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field);
            let i: (u64) = 0u64;
            while (copy i <@u64 copy len) {
                let elem: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        } else  {
            let i: (u64) = copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                if ((std=0x1)::bit_vector::is_index_set[parameter_types: [&(std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i))) (std=0x1)::bit_vector::set[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount)) else (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i -@u64 copy amount));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            i: (u64) = *&copy bitvector.length -@u64 copy amount;
            while (copy i <@u64 *&copy bitvector.length) {
                (std=0x1)::bit_vector::unset[parameter_types: [&mut (std=0x1)::bit_vector::BitVector, u64]<>((copy bitvector, copy i));
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        assert((copy bit_index <@u64 (std=0x1)::vector::length[parameter_types: [&vector<bool>]<bool>(&copy bitvector.bit_field), (std=0x1)::bit_vector::EINDEX));
        let x: (&mut bool) = (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<bool>, u64]<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        /*()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7u64;
    #[]const ALREADY_EXISTS:u64 = 8u64;
    #[]const CANCELLED:u64 = 10u64;
    #[]const INTERNAL:u64 = 11u64;
    #[]const INVALID_ARGUMENT:u64 = 1u64;
    #[]const INVALID_STATE:u64 = 3u64;
    #[]const NOT_FOUND:u64 = 6u64;
    #[]const NOT_IMPLEMENTED:u64 = 12u64;
    #[]const OUT_OF_RANGE:u64 = 2u64;
    #[]const PERMISSION_DENIED:u64 = 5u64;
    #[]const RESOURCE_EXHAUSTED:u64 = 9u64;
    #[]const UNAUTHENTICATED:u64 = 4u64;
    #[]const UNAVAILABLE:u64 = 13u64;
    #[]public fun aborted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        copy category <<@u64 16u8 +@u64 copy reason
    }
    #[]public fun internal(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        (std=0x1)::error::canonical[parameter_types: [u64, u64]<>(((std=0x1)::error::UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        0#value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537u64;
    #[]const EDIVISION:u64 = 131074u64;
    #[]const EDIVISION_BY_ZERO:u64 = 65540u64;
    #[]const EMULTIPLICATION:u64 = 131075u64;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077u64;
    #[]const MAX_U64:u128 = 18446744073709551615u128;
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        if (*&&num.value ==@u64 copy floored_num)  {
            return copy floored_num >>@u64 32u8
        } else ();
        let val: (u128) = (copy floored_num as u128) +@u128 1u128 <<@u128 32u8;
        (copy val >>@u128 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let scaled_numerator: (u128) = (copy numerator as u128) <<@u128 64u8;
        let scaled_denominator: (u128) = (copy denominator as u128) <<@u128 32u8;
        assert((copy scaled_denominator !=@u128 0u128, (std=0x1)::fixed_point32::EDENOMINATOR));
        let quotient: (u128) = copy scaled_numerator /@u128 copy scaled_denominator;
        assert((copy quotient !=@u128 0u128 ||@bool copy numerator ==@u64 0u64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        let value: (u128) = (copy val as u128) <<@u128 32u8;
        assert((copy value <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::ERATIO_OUT_OF_RANGE));
        (std=0x1)::fixed_point32::FixedPoint32<>{(0#value:u64): (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        assert((*&&divisor.value !=@u64 0u64, (std=0x1)::fixed_point32::EDIVISION_BY_ZERO));
        let scaled_value: (u128) = (copy val as u128) <<@u128 32u8;
        let quotient: (u128) = copy scaled_value /@u128 (*&&divisor.value as u128);
        assert((copy quotient <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EDIVISION));
        (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value >>@u64 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        *&&num.value ==@u64 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value >@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        if (*&&num1.value <@u64 *&&num2.value)  {
            copy num1
        } else  {
            copy num2
        }
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let unscaled_product: (u128) = (copy val as u128) *@u128 (*&&multiplier.value as u128);
        let product: (u128) = copy unscaled_product >>@u128 32u8;
        assert((copy product <=@u128 (std=0x1)::fixed_point32::MAX_U64, (std=0x1)::fixed_point32::EMULTIPLICATION));
        (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        let floored_num: (u64) = (std=0x1)::fixed_point32::floor[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num) <<@u64 32u8;
        let boundary: (u64) = copy floored_num +@u64 1u64 <<@u64 32u8 /@u64 2u64;
        if (*&&num.value <@u64 copy boundary)  {
            copy floored_num >>@u64 32u8
        } else  {
            (std=0x1)::fixed_point32::ceil[parameter_types: [(std=0x1)::fixed_point32::FixedPoint32]<>(copy num)
        }
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#484> has copy drop store {
        0#vec: vector<Element#484>
    }
    #[]const EOPTION_IS_SET:u64 = 262144u64;
    #[]const EOPTION_NOT_SET:u64 = 262145u64;
    #[]public fun borrow<Element#485>(t: &(std=0x1)::option::Option<Element#485>): &Element#485 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#485>]<Element#485>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow[parameter_types: [&vector<Element#485>, u64]<Element#485>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#486>(t: &mut (std=0x1)::option::Option<Element#486>): &mut Element#486 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#486>]<Element#486>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::borrow_mut[parameter_types: [&mut vector<Element#486>, u64]<Element#486>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#487>(t: &(std=0x1)::option::Option<Element#487>, default_ref: &Element#487): &Element#487 {
        let vec_ref: (&vector<Element#487>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#487>]<Element#487>(copy vec_ref)) copy default_ref else (std=0x1)::vector::borrow[parameter_types: [&vector<Element#487>, u64]<Element#487>((copy vec_ref, 0u64))
    }
    #[]public fun contains<Element#488>(t: &(std=0x1)::option::Option<Element#488>, e_ref: &Element#488): bool {
        (std=0x1)::vector::contains[parameter_types: [&vector<Element#488>, &Element#488]<Element#488>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#489>(t: (std=0x1)::option::Option<Element#489>): () {
        assert(((std=0x1)::option::is_none[parameter_types: [&(std=0x1)::option::Option<Element#489>]<Element#489>(&t), (std=0x1)::option::EOPTION_IS_SET));
        let (std=0x1)::option::Option<Element#489>{0#vec: vec}: ((std=0x1)::option::Option<Element#489>) = move t;
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#489>]<Element#489>(move vec)
    }
    #[]public fun destroy_some<Element#490>(t: (std=0x1)::option::Option<Element#490>): Element#490 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#490>]<Element#490>(&t), (std=0x1)::option::EOPTION_NOT_SET));
        let (std=0x1)::option::Option<Element#490>{0#vec: vec}: ((std=0x1)::option::Option<Element#490>) = move t;
        let elem: (Element#490) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#490>]<Element#490>(&mut vec);
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#490>]<Element#490>(move vec);
        move elem
    }
    #[]public fun destroy_with_default<Element#491: drop>(t: (std=0x1)::option::Option<Element#491: drop>, default: Element#491: drop): Element#491: drop {
        let (std=0x1)::option::Option<Element#491: drop>{0#vec: vec}: ((std=0x1)::option::Option<Element#491: drop>) = move t;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#491: drop>]<Element#491: drop>(&mut vec)) move default else (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#491: drop>]<Element#491: drop>(&mut vec)
    }
    #[]public fun extract<Element#492>(t: &mut (std=0x1)::option::Option<Element#492>): Element#492 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#492>]<Element#492>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#492>]<Element#492>(&mut copy t.vec)
    }
    #[]public fun fill<Element#493>(t: &mut (std=0x1)::option::Option<Element#493>, e: Element#493): () {
        let vec_ref: (&mut vector<Element#493>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#493>]<Element#493>(copy vec_ref)) (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#493>, Element#493]<Element#493>((copy vec_ref, move e)) else abort (std=0x1)::option::EOPTION_IS_SET
    }
    #[]public fun get_with_default<Element#500: copy+drop>(t: &(std=0x1)::option::Option<Element#500: copy+drop>, default: Element#500: copy+drop): Element#500: copy+drop {
        let vec_ref: (&vector<Element#500: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#500: copy+drop>]<Element#500: copy+drop>(copy vec_ref)) copy default else *(std=0x1)::vector::borrow[parameter_types: [&vector<Element#500: copy+drop>, u64]<Element#500: copy+drop>((copy vec_ref, 0u64))
    }
    #[]public fun is_none<Element#501>(t: &(std=0x1)::option::Option<Element#501>): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#501>]<Element#501>(&copy t.vec)
    }
    #[]public fun is_some<Element#502>(t: &(std=0x1)::option::Option<Element#502>): bool {
        ! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#502>]<Element#502>(&copy t.vec)
    }
    #[]public fun none<Element#505>(): (std=0x1)::option::Option<Element#505> {
        (std=0x1)::option::Option<Element#505>{(0#vec:vector<Element#505>): (std=0x1)::vector::empty<Element#505>(())}
    }
    #[]public fun some<Element#506>(e: Element#506): (std=0x1)::option::Option<Element#506> {
        (std=0x1)::option::Option<Element#506>{(0#vec:vector<Element#506>): (std=0x1)::vector::singleton[parameter_types: [Element#506]<Element#506>(move e)}
    }
    #[]public fun swap<Element#507>(t: &mut (std=0x1)::option::Option<Element#507>, e: Element#507): Element#507 {
        assert(((std=0x1)::option::is_some[parameter_types: [&(std=0x1)::option::Option<Element#507>]<Element#507>(copy t), (std=0x1)::option::EOPTION_NOT_SET));
        let vec_ref: (&mut vector<Element#507>) = &mut copy t.vec;
        let old_value: (Element#507) = (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#507>]<Element#507>(copy vec_ref);
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#507>, Element#507]<Element#507>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun swap_or_fill<Element#508>(t: &mut (std=0x1)::option::Option<Element#508>, e: Element#508): (std=0x1)::option::Option<Element#508> {
        let vec_ref: (&mut vector<Element#508>) = &mut copy t.vec;
        let old_value: ((std=0x1)::option::Option<Element#508>) = if ((std=0x1)::vector::is_empty[parameter_types: [&vector<Element#508>]<Element#508>(copy vec_ref)) (std=0x1)::option::none<Element#508>(()) else (std=0x1)::option::some[parameter_types: [Element#508]<Element#508>((std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#508>]<Element#508>(copy vec_ref));
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#508>, Element#508]<Element#508>((copy vec_ref, move e));
        move old_value
    }
    #[]public fun to_vec<Element#509>(t: (std=0x1)::option::Option<Element#509>): vector<Element#509> {
        let (std=0x1)::option::Option<Element#509>{0#vec: vec}: ((std=0x1)::option::Option<Element#509>) = move t;
        move vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        *(std=0x1)::signer::borrow_address[parameter_types: [&signer]<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        0#bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2u64;
    #[]const EINVALID_UTF8:u64 = 1u64;
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        (std=0x1)::vector::append[parameter_types: [&mut vector<u8>, vector<u8>]<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((copy s, (std=0x1)::string::utf8[parameter_types: [vector<u8>]<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        (std=0x1)::string::internal_index_of[parameter_types: [&vector<u8>, &vector<u8>]<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        let bytes: (&vector<u8>) = &copy s.bytes;
        assert((copy at <=@u64 (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy at)), (std=0x1)::string::EINVALID_INDEX));
        let l: (u64) = (std=0x1)::string::length[parameter_types: [&(std=0x1)::string::String]<>(copy s);
        let front: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, 0u64, copy at));
        let end: ((std=0x1)::string::String) = (std=0x1)::string::sub_string[parameter_types: [&(std=0x1)::string::String, u64, u64]<>((copy s, copy at, copy l));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy o));
        (std=0x1)::string::append[parameter_types: [&mut (std=0x1)::string::String, (std=0x1)::string::String]<>((&mut front, copy end));
        *copy s = copy front;
        /*()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        (std=0x1)::vector::is_empty[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        let bytes: (&vector<u8>) = &copy s.bytes;
        let l: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<u8>]<u8>(copy bytes);
        assert((copy j <=@u64 copy l &&@bool copy i <=@u64 copy j &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy i)) &&@bool (std=0x1)::string::internal_is_char_boundary[parameter_types: [&vector<u8>, u64]<>((copy bytes, copy j)), (std=0x1)::string::EINVALID_INDEX));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): (std=0x1)::string::internal_sub_string[parameter_types: [&vector<u8>, u64, u64]<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        if ((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes))  {
            (std=0x1)::option::some[parameter_types: [(std=0x1)::string::String]<(std=0x1)::string::String>((std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes})
        } else  {
            (std=0x1)::option::none<(std=0x1)::string::String>(())
        }
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        assert(((std=0x1)::string::internal_check_utf8[parameter_types: [&vector<u8>]<>(&bytes), (std=0x1)::string::EINVALID_UTF8));
        (std=0x1)::string::String<>{(0#bytes:vector<u8>): copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        0#name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        &copy self.name
    }
    #[]public native fun get<T#510>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072u64;
    #[]public fun append<Element#511>(lhs: &mut vector<Element#511>, other: vector<Element#511>): () {
        (std=0x1)::vector::reverse[parameter_types: [&mut vector<Element#511>]<Element#511>(&mut other);
        while (! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#511>]<Element#511>(&other))(std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#511>, Element#511]<Element#511>((copy lhs, (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#511>]<Element#511>(&mut other)));
        (std=0x1)::vector::destroy_empty[parameter_types: [vector<Element#511>]<Element#511>(move other);
        /*()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#512>(v: &vector<Element#512>, i: u64): &Element#512;

    #[bytecode_instruction]public native fun borrow_mut<Element#513>(v: &mut vector<Element#513>, i: u64): &mut Element#513;

    #[]public fun contains<Element#514>(v: &vector<Element#514>, e: &Element#514): bool {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#514>]<Element#514>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#514>, u64]<Element#514>((copy v, copy i)) ==@&Element#514 copy e) return true else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#515>(v: vector<Element#515>): ();

    #[bytecode_instruction]public native fun empty<Element#516>(): vector<Element#516>;

    #[]public fun index_of<Element#523>(v: &vector<Element#523>, e: &Element#523): (bool, u64) {
        let i: (u64) = 0u64;
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#523>]<Element#523>(copy v);
        while (copy i <@u64 copy len) {
            if ((std=0x1)::vector::borrow[parameter_types: [&vector<Element#523>, u64]<Element#523>((copy v, copy i)) ==@&Element#523 copy e) return (true, copy i) else ();
            i: (u64) = copy i +@u64 1u64;
            /*()*/
        };
        (false, 0u64)
    }
    #[]public fun is_empty<Element#524>(v: &vector<Element#524>): bool {
        (std=0x1)::vector::length[parameter_types: [&vector<Element#524>]<Element#524>(copy v) ==@u64 0u64
    }
    #[bytecode_instruction]public native fun length<Element#525>(v: &vector<Element#525>): u64;

    #[bytecode_instruction]public native fun pop_back<Element#528>(v: &mut vector<Element#528>): Element#528;

    #[bytecode_instruction]public native fun push_back<Element#529>(v: &mut vector<Element#529>, e: Element#529): ();

    #[]public fun remove<Element#530>(v: &mut vector<Element#530>, i: u64): Element#530 {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#530>]<Element#530>(copy v);
        if (copy i >=@u64 copy len) abort (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS else ();
        len: (u64) = copy len -@u64 1u64;
        while (copy i <@u64 copy len)(std=0x1)::vector::swap[parameter_types: [&mut vector<Element#530>, u64, u64]<Element#530>((copy v, copy i,  {
            i: (u64) = copy i +@u64 1u64;
            copy i
        }));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#530>]<Element#530>(copy v)
    }
    #[]public fun reverse<Element#531>(v: &mut vector<Element#531>): () {
        let len: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#531>]<Element#531>(copy v);
        if (copy len ==@u64 0u64) return () else ();
        let front_index: (u64) = 0u64;
        let back_index: (u64) = copy len -@u64 1u64;
        while (copy front_index <@u64 copy back_index) {
            (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#531>, u64, u64]<Element#531>((copy v, copy front_index, copy back_index));
            front_index: (u64) = copy front_index +@u64 1u64;
            back_index: (u64) = copy back_index -@u64 1u64;
            /*()*/
        }
    }
    #[]public fun singleton<Element#532>(e: Element#532): vector<Element#532> {
        let v: (vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        (std=0x1)::vector::push_back[parameter_types: [&mut vector<Element#532>, Element#532]<Element#532>((&mut v, move e));
        move v
    }
    #[bytecode_instruction]public native fun swap<Element#533>(v: &mut vector<Element#533>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#534>(v: &mut vector<Element#534>, i: u64): Element#534 {
        assert((! (std=0x1)::vector::is_empty[parameter_types: [&vector<Element#534>]<Element#534>(copy v), (std=0x1)::vector::EINDEX_OUT_OF_BOUNDS));
        let last_idx: (u64) = (std=0x1)::vector::length[parameter_types: [&vector<Element#534>]<Element#534>(copy v) -@u64 1u64;
        (std=0x1)::vector::swap[parameter_types: [&mut vector<Element#534>, u64, u64]<Element#534>((copy v, copy i, copy last_idx));
        (std=0x1)::vector::pop_back[parameter_types: [&mut vector<Element#534>]<Element#534>(copy v)
    }

}
After hlir: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        byte: u8
    }
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 =  {
        locals:


        return 65536u64
    };
    #[]public fun all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        locals:
            byte: u8,
            i: u64,
            len: u64,
            string: &(std=0x1)::ascii::String

        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        while ( {
            pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            copy i < copy len
        }) {
            (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
            if (! (std=0x1)::ascii::is_printable_char<>(copy byte))  {
                return@false
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
    }
    #[]public fun as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        locals:
            string: &(std=0x1)::ascii::String

        return &copy string.bytes
    }
    #[]public fun byte(char: (std=0x1)::ascii::Char): u8 {
        locals:
            byte: u8,
            char: (std=0x1)::ascii::Char

        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
    }
    #[]public fun char(byte: u8): (std=0x1)::ascii::Char {
        locals:
            byte: u8

        if ((std=0x1)::ascii::is_valid_char<>(copy byte))  {
            pop  = ()
        } else  {
            abort EINVALID_ASCII_CHARACTER
        };
        pop  = /*()*/;
        return Char<>{byte: copy byte}
    }
    #[]public fun into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        locals:
            bytes: vector<u8>,
            string: (std=0x1)::ascii::String

        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
    }
    #[]public fun is_printable_char(byte: u8): bool {
        locals:
            %#1: bool,
            byte: u8

        if (copy byte >= 32u8)  {
            (%#1: bool) = copy byte <= 126u8
        } else  {
            (%#1: bool) = false
        };
        return move#last %#1
    }
    #[]public fun is_valid_char(b: u8): bool {
        locals:
            b: u8

        return copy b <= 127u8
    }
    #[]public fun length(string: &(std=0x1)::ascii::String): u64 {
        locals:
            string: &(std=0x1)::ascii::String

        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
    }
    #[]public fun pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        locals:
            string: &mut (std=0x1)::ascii::String

        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
    }
    #[]public fun push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        locals:
            char: (std=0x1)::ascii::Char,
            string: &mut (std=0x1)::ascii::String

        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
    }
    #[]public fun string(bytes: vector<u8>): (std=0x1)::ascii::String {
        locals:
            bytes: vector<u8>,
            x: (std=0x1)::option::Option<(std=0x1)::ascii::String>

        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        if ((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x))  {
            pop  = ()
        } else  {
            abort EINVALID_ASCII_CHARACTER
        };
        pop  = /*()*/;
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
    }
    #[]public fun try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        locals:
            bytes: vector<u8>,
            i: u64,
            len: u64,
            possible_byte: u8

        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        while ( {
            pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            copy i < copy len
        }) {
            (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
            if (! (std=0x1)::ascii::is_valid_char<>(copy possible_byte))  {
                return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native fun to_bytes<MoveValue#483>(v: &MoveValue#483): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        length: u64;
        bit_field: vector<bool>
    }
    #[]const EINDEX:u64 =  {
        locals:


        return 131072u64
    };
    #[]const ELENGTH:u64 =  {
        locals:


        return 131073u64
    };
    #[]const MAX_SIZE:u64 =  {
        locals:


        return 1024u64
    };
    #[]const WORD_SIZE:u64 =  {
        locals:


        return 1u64
    };
    #[]public fun is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        locals:
            bit_index: u64,
            bitvector: &(std=0x1)::bit_vector::BitVector

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
    }
    #[]public fun length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector

        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
    }
    #[]public fun longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector,
            index: u64,
            start_index: u64

        if (copy start_index < *&copy bitvector.length)  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (index: u64) = copy start_index;
        while (copy index < *&copy bitvector.length) {
            if (! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index)))  {
                break
            } else  {
                pop  = ()
            };
            (index: u64) = copy index + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return copy index - copy start_index
    }
    #[]public fun new(length: u64): (std=0x1)::bit_vector::BitVector {
        locals:
            bit_field: vector<bool>,
            counter: u64,
            length: u64

        if (copy length > 0u64)  {
            pop  = ()
        } else  {
            abort ELENGTH
        };
        pop  = /*()*/;
        if (copy length < MAX_SIZE)  {
            pop  = ()
        } else  {
            abort ELENGTH
        };
        pop  = /*()*/;
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        while ( {
            pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            copy counter < copy length
        }) {
            pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
            (counter: u64) = copy counter + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
    }
    #[]public fun set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        pop  = /*()*/;
        return /*;()*/
    }
    #[]public fun shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        locals:
            %#2: &mut (std=0x1)::bit_vector::BitVector,
            %#3: u64,
            amount: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            elem: &mut bool,
            i: u64,
            i#1: u64,
            len: u64

        if (copy amount >= *&copy bitvector.length)  {
            (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
            (i: u64) = 0u64;
            while (copy i < copy len) {
                (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
                *copy elem = false;
                pop  = /*()*/;
                (i: u64) = copy i + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        } else  {
            (i#1: u64) = copy amount;
            while (copy i#1 < *&copy bitvector.length) {
                ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
                if ((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3)))  {
                    pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount))
                } else  {
                    pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount))
                };
                (i#1: u64) = copy i#1 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            (i#1: u64) = *&copy bitvector.length - copy amount;
            pop  = /*()*/;
            while (copy i#1 < *&copy bitvector.length) {
                pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
                (i#1: u64) = copy i#1 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        };
        return /*()*/
    }
    #[]public fun unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        if (copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field))  {
            pop  = ()
        } else  {
            abort EINDEX
        };
        pop  = /*()*/;
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        pop  = /*()*/;
        return /*;()*/
    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 =  {
        locals:


        return 7u64
    };
    #[]const ALREADY_EXISTS:u64 =  {
        locals:


        return 8u64
    };
    #[]const CANCELLED:u64 =  {
        locals:


        return 10u64
    };
    #[]const INTERNAL:u64 =  {
        locals:


        return 11u64
    };
    #[]const INVALID_ARGUMENT:u64 =  {
        locals:


        return 1u64
    };
    #[]const INVALID_STATE:u64 =  {
        locals:


        return 3u64
    };
    #[]const NOT_FOUND:u64 =  {
        locals:


        return 6u64
    };
    #[]const NOT_IMPLEMENTED:u64 =  {
        locals:


        return 12u64
    };
    #[]const OUT_OF_RANGE:u64 =  {
        locals:


        return 2u64
    };
    #[]const PERMISSION_DENIED:u64 =  {
        locals:


        return 5u64
    };
    #[]const RESOURCE_EXHAUSTED:u64 =  {
        locals:


        return 9u64
    };
    #[]const UNAUTHENTICATED:u64 =  {
        locals:


        return 4u64
    };
    #[]const UNAVAILABLE:u64 =  {
        locals:


        return 13u64
    };
    #[]public fun aborted(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((ABORTED, copy r))
    }
    #[]public fun already_exists(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
    }
    #[]public fun canonical(category: u64, reason: u64): u64 {
        locals:
            category: u64,
            reason: u64

        return copy category << 16u8 + copy reason
    }
    #[]public fun internal(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
    }
    #[]public fun invalid_argument(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
    }
    #[]public fun invalid_state(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
    }
    #[]public fun not_found(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
    }
    #[]public fun not_implemented(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
    }
    #[]public fun out_of_range(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
    }
    #[]public fun permission_denied(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
    }
    #[]public fun resource_exhausted(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
    }
    #[]public fun unauthenticated(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
    }
    #[]public fun unavailable(r: u64): u64 {
        locals:
            r: u64

        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        value: u64
    }
    #[]const EDENOMINATOR:u64 =  {
        locals:


        return 65537u64
    };
    #[]const EDIVISION:u64 =  {
        locals:


        return 131074u64
    };
    #[]const EDIVISION_BY_ZERO:u64 =  {
        locals:


        return 65540u64
    };
    #[]const EMULTIPLICATION:u64 =  {
        locals:


        return 131075u64
    };
    #[]const ERATIO_OUT_OF_RANGE:u64 =  {
        locals:


        return 131077u64
    };
    #[]const MAX_U64:u128 =  {
        locals:


        return 18446744073709551615u128
    };
    #[]public fun ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32,
            val: u128

        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        if (*&&num.value == copy floored_num)  {
            return@copy floored_num >> 32u8
        } else  {
            pop  = ()
        };
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
    }
    #[]public fun create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: bool,
            denominator: u64,
            numerator: u64,
            quotient: u128,
            scaled_denominator: u128,
            scaled_numerator: u128

        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        if (copy scaled_denominator != 0u128)  {
            pop  = ()
        } else  {
            abort EDENOMINATOR
        };
        pop  = /*()*/;
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        if (copy quotient != 0u128)  {
            (%#1: bool) = true
        } else  {
            (%#1: bool) = copy numerator == 0u64
        };
        if (move#last %#1)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        if (copy quotient <= MAX_U64)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        return FixedPoint32<>{value: (copy quotient as u64)}
    }
    #[]public fun create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            value: u64

        return FixedPoint32<>{value: copy value}
    }
    #[]public fun create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            val: u64,
            value: u128

        (value: u128) = (copy val as u128) << 32u8;
        if (copy value <= MAX_U64)  {
            pop  = ()
        } else  {
            abort ERATIO_OUT_OF_RANGE
        };
        pop  = /*()*/;
        return FixedPoint32<>{value: (copy value as u64)}
    }
    #[]public fun divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            divisor: (std=0x1)::fixed_point32::FixedPoint32,
            quotient: u128,
            scaled_value: u128,
            val: u64

        if (*&&divisor.value != 0u64)  {
            pop  = ()
        } else  {
            abort EDIVISION_BY_ZERO
        };
        pop  = /*()*/;
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        if (copy quotient <= MAX_U64)  {
            pop  = ()
        } else  {
            abort EDIVISION
        };
        pop  = /*()*/;
        return (copy quotient as u64)
    }
    #[]public fun floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value >> 32u8
    }
    #[]public fun get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value
    }
    #[]public fun is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        return *&&num.value == 0u64
    }
    #[]public fun max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        if (*&&num1.value > *&&num2.value)  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1
        } else  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2
        };
        return move#last %#1
    }
    #[]public fun min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        if (*&&num1.value < *&&num2.value)  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1
        } else  {
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2
        };
        return move#last %#1
    }
    #[]public fun multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            multiplier: (std=0x1)::fixed_point32::FixedPoint32,
            product: u128,
            unscaled_product: u128,
            val: u64

        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        if (copy product <= MAX_U64)  {
            pop  = ()
        } else  {
            abort EMULTIPLICATION
        };
        pop  = /*()*/;
        return (copy product as u64)
    }
    #[]public fun round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            %#1: u64,
            boundary: u64,
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32

        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        if (*&&num.value < copy boundary)  {
            (%#1: u64) = copy floored_num >> 32u8
        } else  {
            (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num)
        };
        return move#last %#1
    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native fun sha2_256(data: vector<u8>): vector<u8>;

    #[]public native fun sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#484> has copy drop store {
        vec: vector<Element#484>
    }
    #[]const EOPTION_IS_SET:u64 =  {
        locals:


        return 262144u64
    };
    #[]const EOPTION_NOT_SET:u64 =  {
        locals:


        return 262145u64
    };
    #[]public fun borrow<Element#485>(t: &(std=0x1)::option::Option<Element#485>): &Element#485 {
        locals:
            t: &(std=0x1)::option::Option<Element#485>

        if ((std=0x1)::option::is_some<Element#485>(copy t))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::borrow<Element#485>((&copy t.vec, 0u64))
    }
    #[]public fun borrow_mut<Element#486>(t: &mut (std=0x1)::option::Option<Element#486>): &mut Element#486 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#486>

        if ((std=0x1)::option::is_some<Element#486>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::borrow_mut<Element#486>((&mut copy t.vec, 0u64))
    }
    #[]public fun borrow_with_default<Element#487>(t: &(std=0x1)::option::Option<Element#487>, default_ref: &Element#487): &Element#487 {
        locals:
            %#1: &Element#487,
            default_ref: &Element#487,
            t: &(std=0x1)::option::Option<Element#487>,
            vec_ref: &vector<Element#487>

        (vec_ref: &vector<Element#487>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#487>(copy vec_ref))  {
            (%#1: &Element#487) = copy default_ref
        } else  {
            (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((copy vec_ref, 0u64))
        };
        return move#last %#1
    }
    #[]public fun contains<Element#488>(t: &(std=0x1)::option::Option<Element#488>, e_ref: &Element#488): bool {
        locals:
            e_ref: &Element#488,
            t: &(std=0x1)::option::Option<Element#488>

        return (std=0x1)::vector::contains<Element#488>((&copy t.vec, copy e_ref))
    }
    #[]public fun destroy_none<Element#489>(t: (std=0x1)::option::Option<Element#489>): () {
        locals:
            t: (std=0x1)::option::Option<Element#489>,
            vec: vector<Element#489>

        if ((std=0x1)::option::is_none<Element#489>(&t))  {
            pop  = ()
        } else  {
            abort EOPTION_IS_SET
        };
        pop  = /*()*/;
        Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)
    }
    #[]public fun destroy_some<Element#490>(t: (std=0x1)::option::Option<Element#490>): Element#490 {
        locals:
            elem: Element#490,
            t: (std=0x1)::option::Option<Element#490>,
            vec: vector<Element#490>

        if ((std=0x1)::option::is_some<Element#490>(&t))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
        (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
        return move#no-copy elem
    }
    #[]public fun destroy_with_default<Element#491: drop>(t: (std=0x1)::option::Option<Element#491: drop>, default: Element#491: drop): Element#491: drop {
        locals:
            %#1: Element#491: drop,
            default: Element#491: drop,
            t: (std=0x1)::option::Option<Element#491: drop>,
            vec: vector<Element#491: drop>

        Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
        if ((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec)))  {
            (%#1: Element#491: drop) = move#no-copy default
        } else  {
            (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec)
        };
        return move#last %#1
    }
    #[]public fun extract<Element#492>(t: &mut (std=0x1)::option::Option<Element#492>): Element#492 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#492>

        if ((std=0x1)::option::is_some<Element#492>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        return (std=0x1)::vector::pop_back<Element#492>(&mut copy t.vec)
    }
    #[]public fun fill<Element#493>(t: &mut (std=0x1)::option::Option<Element#493>, e: Element#493): () {
        locals:
            e: Element#493,
            t: &mut (std=0x1)::option::Option<Element#493>,
            vec_ref: &mut vector<Element#493>

        (vec_ref: &mut vector<Element#493>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref)))  {
            pop  = (std=0x1)::vector::push_back<Element#493>((copy vec_ref, move#no-copy e))
        } else  {
            abort EOPTION_IS_SET
        };
        return /*()*/
    }
    #[]public fun get_with_default<Element#500: copy+drop>(t: &(std=0x1)::option::Option<Element#500: copy+drop>, default: Element#500: copy+drop): Element#500: copy+drop {
        locals:
            %#1: Element#500: copy+drop,
            default: Element#500: copy+drop,
            t: &(std=0x1)::option::Option<Element#500: copy+drop>,
            vec_ref: &vector<Element#500: copy+drop>

        (vec_ref: &vector<Element#500: copy+drop>) = &copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref))  {
            (%#1: Element#500: copy+drop) = copy default
        } else  {
            (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((copy vec_ref, 0u64))
        };
        return move#last %#1
    }
    #[]public fun is_none<Element#501>(t: &(std=0x1)::option::Option<Element#501>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#501>

        return (std=0x1)::vector::is_empty<Element#501>(&copy t.vec)
    }
    #[]public fun is_some<Element#502>(t: &(std=0x1)::option::Option<Element#502>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#502>

        return ! (std=0x1)::vector::is_empty<Element#502>(&copy t.vec)
    }
    #[]public fun none<Element#505>(): (std=0x1)::option::Option<Element#505> {
        locals:


        return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}
    }
    #[]public fun some<Element#506>(e: Element#506): (std=0x1)::option::Option<Element#506> {
        locals:
            e: Element#506

        return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}
    }
    #[]public fun swap<Element#507>(t: &mut (std=0x1)::option::Option<Element#507>, e: Element#507): Element#507 {
        locals:
            e: Element#507,
            old_value: Element#507,
            t: &mut (std=0x1)::option::Option<Element#507>,
            vec_ref: &mut vector<Element#507>

        if ((std=0x1)::option::is_some<Element#507>(freeze(copy t)))  {
            pop  = ()
        } else  {
            abort EOPTION_NOT_SET
        };
        pop  = /*()*/;
        (vec_ref: &mut vector<Element#507>) = &mut copy t.vec;
        (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#507>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
    }
    #[]public fun swap_or_fill<Element#508>(t: &mut (std=0x1)::option::Option<Element#508>, e: Element#508): (std=0x1)::option::Option<Element#508> {
        locals:
            %#1: (std=0x1)::option::Option<Element#508>,
            e: Element#508,
            old_value: (std=0x1)::option::Option<Element#508>,
            t: &mut (std=0x1)::option::Option<Element#508>,
            vec_ref: &mut vector<Element#508>

        (vec_ref: &mut vector<Element#508>) = &mut copy t.vec;
        if ((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref)))  {
            (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(())
        } else  {
            (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref))
        };
        (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#508>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
    }
    #[]public fun to_vec<Element#509>(t: (std=0x1)::option::Option<Element#509>): vector<Element#509> {
        locals:
            t: (std=0x1)::option::Option<Element#509>,
            vec: vector<Element#509>

        Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
        return move#no-copy vec
    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public fun address_of(s: &signer): address {
        locals:
            s: &signer

        return *(std=0x1)::signer::borrow_address<>(copy s)
    }
    #[]public native fun borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 =  {
        locals:


        return 2u64
    };
    #[]const EINVALID_UTF8:u64 =  {
        locals:


        return 1u64
    };
    #[]public fun append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        locals:
            r: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
    }
    #[]public fun append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        locals:
            bytes: vector<u8>,
            s: &mut (std=0x1)::string::String

        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
    }
    #[]public fun bytes(s: &(std=0x1)::string::String): &vector<u8> {
        locals:
            s: &(std=0x1)::string::String

        return &copy s.bytes
    }
    #[]public fun index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        locals:
            r: &(std=0x1)::string::String,
            s: &(std=0x1)::string::String

        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
    }
    #[]public fun insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        locals:
            %#1: bool,
            %#2: &mut (std=0x1)::string::String,
            %#3: u64,
            %#4: u64,
            %#5: &mut (std=0x1)::string::String,
            %#6: u64,
            %#7: u64,
            at: u64,
            bytes: &vector<u8>,
            end: (std=0x1)::string::String,
            front: (std=0x1)::string::String,
            l: u64,
            o: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        (bytes: &vector<u8>) = &copy s.bytes;
        if (copy at <= (std=0x1)::vector::length<u8>(copy bytes))  {
            (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at))
        } else  {
            (%#1: bool) = false
        };
        if (move#last %#1)  {
            pop  = ()
        } else  {
            abort EINVALID_INDEX
        };
        pop  = /*()*/;
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        pop  = /*()*/;
        return /*;()*/
    }
    #[] native fun internal_check_utf8(v: &vector<u8>): bool;

    #[] native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public fun is_empty(s: &(std=0x1)::string::String): bool {
        locals:
            s: &(std=0x1)::string::String

        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
    }
    #[]public fun length(s: &(std=0x1)::string::String): u64 {
        locals:
            s: &(std=0x1)::string::String

        return (std=0x1)::vector::length<u8>(&copy s.bytes)
    }
    #[]public fun sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        locals:
            %#1: bool,
            %#2: bool,
            %#3: bool,
            bytes: &vector<u8>,
            i: u64,
            j: u64,
            l: u64,
            s: &(std=0x1)::string::String

        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        if (copy j <= copy l)  {
            (%#1: bool) = copy i <= copy j
        } else  {
            (%#1: bool) = false
        };
        if (move#last %#1)  {
            (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i))
        } else  {
            (%#2: bool) = false
        };
        if (move#last %#2)  {
            (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j))
        } else  {
            (%#3: bool) = false
        };
        if (move#last %#3)  {
            pop  = ()
        } else  {
            abort EINVALID_INDEX
        };
        pop  = /*()*/;
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
    }
    #[]public fun try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        locals:
            %#1: (std=0x1)::option::Option<(std=0x1)::string::String>,
            bytes: vector<u8>

        if ((std=0x1)::string::internal_check_utf8<>(&bytes))  {
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes})
        } else  {
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(())
        };
        return move#last %#1
    }
    #[]public fun utf8(bytes: vector<u8>): (std=0x1)::string::String {
        locals:
            bytes: vector<u8>

        if ((std=0x1)::string::internal_check_utf8<>(&bytes))  {
            pop  = ()
        } else  {
            abort EINVALID_UTF8
        };
        pop  = /*()*/;
        return String<>{bytes: copy bytes}
    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        name: (std=0x1)::ascii::String
    }
    #[]public fun borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        locals:
            self: &(std=0x1)::type_name::TypeName

        return &copy self.name
    }
    #[]public native fun get<T#510>(): (std=0x1)::type_name::TypeName;

    #[]public fun into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        locals:
            self: (std=0x1)::type_name::TypeName

        return *&&self.name
    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 =  {
        locals:


        return 131072u64
    };
    #[]public fun append<Element#511>(lhs: &mut vector<Element#511>, other: vector<Element#511>): () {
        locals:
            lhs: &mut vector<Element#511>,
            other: vector<Element#511>

        pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
        while (! (std=0x1)::vector::is_empty<Element#511>(&other)) {
            pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)))
        };
        pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
        return /*;()*/
    }
    #[bytecode_instruction]public native fun borrow<Element#512>(v: &vector<Element#512>, i: u64): &Element#512;

    #[bytecode_instruction]public native fun borrow_mut<Element#513>(v: &mut vector<Element#513>, i: u64): &mut Element#513;

    #[]public fun contains<Element#514>(v: &vector<Element#514>, e: &Element#514): bool {
        locals:
            e: &Element#514,
            i: u64,
            len: u64,
            v: &vector<Element#514>

        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
        while (copy i < copy len) {
            if ((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e)  {
                return@true
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return false
    }
    #[bytecode_instruction]public native fun destroy_empty<Element#515>(v: vector<Element#515>): ();

    #[bytecode_instruction]public native fun empty<Element#516>(): vector<Element#516>;

    #[]public fun index_of<Element#523>(v: &vector<Element#523>, e: &Element#523): (bool, u64) {
        locals:
            e: &Element#523,
            i: u64,
            len: u64,
            v: &vector<Element#523>

        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
        while (copy i < copy len) {
            if ((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e)  {
                return@(true, copy i)
            } else  {
                pop  = ()
            };
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return (false, 0u64)
    }
    #[]public fun is_empty<Element#524>(v: &vector<Element#524>): bool {
        locals:
            v: &vector<Element#524>

        return (std=0x1)::vector::length<Element#524>(copy v) == 0u64
    }
    #[bytecode_instruction]public native fun length<Element#525>(v: &vector<Element#525>): u64;

    #[bytecode_instruction]public native fun pop_back<Element#528>(v: &mut vector<Element#528>): Element#528;

    #[bytecode_instruction]public native fun push_back<Element#529>(v: &mut vector<Element#529>, e: Element#529): ();

    #[]public fun remove<Element#530>(v: &mut vector<Element#530>, i: u64): Element#530 {
        locals:
            %#1: u64,
            %#2: &mut vector<Element#530>,
            i: u64,
            len: u64,
            v: &mut vector<Element#530>

        (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
        if (copy i >= copy len)  {
            abort EINDEX_OUT_OF_BOUNDS
        } else  {
            pop  = ()
        };
        (len: u64) = copy len - 1u64;
        pop  = /*()*/;
        while (copy i < copy len) {
            (%#2: &mut vector<Element#530>) = copy v;
            (%#1: u64) = copy i;
            (i: u64) = copy i + 1u64;
            pop  = /*()*/;
            pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i))
        };
        return (std=0x1)::vector::pop_back<Element#530>(copy v)
    }
    #[]public fun reverse<Element#531>(v: &mut vector<Element#531>): () {
        locals:
            back_index: u64,
            front_index: u64,
            len: u64,
            v: &mut vector<Element#531>

        (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
        if (copy len == 0u64)  {
            return@()
        } else  {
            pop  = ()
        };
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        while (copy front_index < copy back_index) {
            pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
            (front_index: u64) = copy front_index + 1u64;
            pop  = /*()*/;
            (back_index: u64) = copy back_index - 1u64;
            pop  = /*()*/;
            pop  = /*;()*/
        };
        return /*()*/
    }
    #[]public fun singleton<Element#532>(e: Element#532): vector<Element#532> {
        locals:
            e: Element#532,
            v: vector<Element#532>

        (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
        return move#no-copy v
    }
    #[bytecode_instruction]public native fun swap<Element#533>(v: &mut vector<Element#533>, i: u64, j: u64): ();

    #[]public fun swap_remove<Element#534>(v: &mut vector<Element#534>, i: u64): Element#534 {
        locals:
            i: u64,
            last_idx: u64,
            v: &mut vector<Element#534>

        if (! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v)))  {
            pop  = ()
        } else  {
            abort EINDEX_OUT_OF_BOUNDS
        };
        pop  = /*()*/;
        (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#534>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#534>(copy v)
    }

}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(copy byte)) 3 else 4

    
    label 3:
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(copy byte)) 3 else 4

    
    label 3:
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 4

    
    label 3:
        pop _ = move#last string;
        return@false

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 5

    
    label 3:
        pop _ = move#last string;
        return@false

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
        return true
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy string.bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy string.bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last string.bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last string.bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = copy char;
        return copy byte
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = move#last char;
        return move#last byte
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Char<>{byte: (byte: u8)} = move#last char;
        return move#last byte
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: copy byte}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: copy byte}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: move#last byte}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 3 else 2

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return Char<>{byte: move#last byte}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = copy string;
        return copy bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = move#last string;
        return move#last bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        String<>{bytes: (bytes: vector<u8>)} = move#last string;
        return move#last bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = copy byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = copy byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = move#last byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy byte >= 32u8) 1 else 2

    
    label 1:
        (%#1: bool) = move#last byte <= 126u8;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy b <= 127u8
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy b <= 127u8
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last b <= 127u8
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last b <= 127u8
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(copy string))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut copy string.bytes)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut copy string.bytes, *&&char.byte));
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(copy bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(copy x)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
        jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 3 else 2

    
    label 2:
        abort EINVALID_ASCII_CHARACTER

    
    label 3:
        return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(copy possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(copy possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: copy bytes})
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 4

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
        (i: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
        jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 5

    
    label 3:
        return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
        return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&copy bitvector.bit_field, copy bit_index))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 9]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [4, 6]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 2

loop heads:
    loop head: 4. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 9

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 9]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [4, 6]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 2

loop heads:
    loop head: 4. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index

    
    label 13:
        jump 9
After recompute, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 7
    7 => 8
    8 => 13
    13 => 2

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = copy index + 1u64;
        jump 4

    
    label 9:
        return copy index - copy start_index

    
    label 13:
        jump 9
dead_blocks is 
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 7]
    6 => [9]
    7 => [8]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    7 <= [5]
    8 <= [7]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 7
    7 => 8
    8 => 13
    13 => 2

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 7

    
    label 6:
        pop _ = move#last bitvector;
        jump@9

    
    label 7:
        jump 8

    
    label 8:
        (index: u64) = move#last index + 1u64;
        jump 4

    
    label 9:
        return move#last index - move#last start_index

    
    label 13:
        pop _ = move#last bitvector;
        jump 9
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [4]
    4 => [5, 13]
    5 => [6, 8]
    6 => [9]
    8 => [4]
    9 => []
    13 => [9]

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    4 <= [3, 8]
    5 <= [4]
    6 <= [5]
    8 <= [5]
    9 <= [6, 13]
    13 <= [4]

traversal:
    0 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 9
    9 => 8
    8 => 13

loop heads:
    loop head: 4. back edge predecessor: 8
    loop head: 9. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy start_index < *&copy bitvector.length) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (index: u64) = copy start_index;
        jump 4

    
    label 4:
        jump_if(copy index < *&copy bitvector.length) 5 else 13

    
    label 5:
        jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 8

    
    label 6:
        pop _ = move#last bitvector;
        jump@9

    
    label 8:
        (index: u64) = move#last index + 1u64;
        jump 4

    
    label 9:
        return move#last index - move#last start_index

    
    label 13:
        pop _ = move#last bitvector;
        jump 9
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = copy counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = copy counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: copy length, bit_field: copy bit_field}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 5
    5 => 2

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = move#last counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: move#last length, bit_field: move#last bit_field}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [5, 6]
    5 => []
    6 => [7]
    7 => [8, 9]
    8 => [7]
    9 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    5 <= [3]
    6 <= [3]
    7 <= [6, 8]
    8 <= [7]
    9 <= [7]

traversal:
    0 => 2
    2 => 3
    3 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9

loop heads:
    loop head: 7. back edge predecessor: 8

start: 0
blocks:

    label 0:
        jump_if(copy length > 0u64) 3 else 2

    
    label 2:
        abort ELENGTH

    
    label 3:
        jump_if(copy length < MAX_SIZE) 6 else 5

    
    label 5:
        abort ELENGTH

    
    label 6:
        (counter: u64) = 0u64;
        (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
        jump 7

    
    label 7:
        pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
        jump_if(copy counter < copy length) 8 else 9

    
    label 8:
        pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
        (counter: u64) = move#last counter + 1u64;
        jump 7

    
    label 9:
        pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
        return BitVector<>{length: move#last length, bit_field: move#last bit_field}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = true;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = true;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = true;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *copy elem = false;
        (i: u64) = copy i + 1u64;
        jump 2

    
    label 4:
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = copy i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - copy amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = copy i#1 + 1u64;
        jump 12

    
    label 14:
        jump 15

    
    label 15:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *copy elem = false;
        (i: u64) = copy i + 1u64;
        jump 2

    
    label 4:
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = copy i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - copy amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = copy i#1 + 1u64;
        jump 12

    
    label 14:
        jump 15

    
    label 15:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *move#last elem = false;
        (i: u64) = move#last i + 1u64;
        jump 2

    
    label 4:
        pop _ = move#last bitvector;
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = move#last i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - move#last amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = move#last i#1 + 1u64;
        jump 12

    
    label 14:
        pop _ = move#last bitvector;
        jump 15

    
    label 15:
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 5]
    1 => [2]
    2 => [3, 4]
    3 => [2]
    4 => [15]
    5 => [6]
    6 => [7, 11]
    7 => [8, 9]
    8 => [10]
    9 => [10]
    10 => [6]
    11 => [12]
    12 => [13, 14]
    13 => [12]
    14 => [15]
    15 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [1, 3]
    3 <= [2]
    4 <= [2]
    5 <= [0]
    6 <= [5, 10]
    7 <= [6]
    8 <= [7]
    9 <= [7]
    10 <= [8, 9]
    11 <= [6]
    12 <= [11, 13]
    13 <= [12]
    14 <= [12]
    15 <= [4, 14]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 11
    11 => 12
    12 => 13
    13 => 14
    14 => 15

loop heads:
    loop head: 2. back edge predecessor: 3
    loop head: 6. back edge predecessor: 10
    loop head: 12. back edge predecessor: 13

start: 0
blocks:

    label 0:
        jump_if(copy amount >= *&copy bitvector.length) 1 else 5

    
    label 1:
        (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
        (i: u64) = 0u64;
        jump 2

    
    label 2:
        jump_if(copy i < copy len) 3 else 4

    
    label 3:
        (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
        *move#last elem = false;
        (i: u64) = move#last i + 1u64;
        jump 2

    
    label 4:
        pop _ = move#last bitvector;
        jump 15

    
    label 5:
        (i#1: u64) = copy amount;
        jump 6

    
    label 6:
        jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

    
    label 7:
        ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
        jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

    
    label 8:
        pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 9:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
        jump 10

    
    label 10:
        (i#1: u64) = move#last i#1 + 1u64;
        jump 6

    
    label 11:
        (i#1: u64) = *&copy bitvector.length - move#last amount;
        jump 12

    
    label 12:
        jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

    
    label 13:
        pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
        (i#1: u64) = move#last i#1 + 1u64;
        jump 12

    
    label 14:
        pop _ = move#last bitvector;
        jump 15

    
    label 15:
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy bit_index));
        *copy x = false;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = false;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

    
    label 2:
        pop _ = move#last bitvector;
        abort EINDEX

    
    label 3:
        (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
        *move#last x = false;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ABORTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy category << 16u8 + copy reason
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return copy category << 16u8 + copy reason
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last category << 16u8 + move#last reason
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return move#last category << 16u8 + move#last reason
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INTERNAL, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, copy r))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@copy floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@copy floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (copy floored_num as u128) + 1u128 << 32u8;
        return (copy val >> 32u8 as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 2

    
    label 1:
        return@move#last floored_num >> 32u8

    
    label 2:
        jump 3

    
    label 3:
        (val: u128) = (move#last floored_num as u128) + 1u128 << 32u8;
        return (move#last val >> 32u8 as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]

traversal:
    0 => 1
    1 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        jump_if(*&&num.value == copy floored_num) 1 else 3

    
    label 1:
        return@move#last floored_num >> 32u8

    
    label 3:
        (val: u128) = (move#last floored_num as u128) + 4294967296u128;
        return (move#last val >> 32u8 as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = copy numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (copy quotient as u64)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (copy denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = copy scaled_numerator / copy scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = copy numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (copy quotient as u64)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => []
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 9
    9 => 10
    10 => 12
    12 => 11
    11 => 8
    8 => 2

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = move#last numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 7 else 8

    
    label 7:
        jump 9

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (move#last quotient as u64)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [8, 9]
    8 => []
    9 => [11, 12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    8 <= [6]
    9 <= [6]
    11 <= [9]
    12 <= [9]

traversal:
    0 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 8
    8 => 9
    9 => 11
    11 => 12

loop heads:

start: 0
blocks:

    label 0:
        (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
        (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
        jump_if(copy scaled_denominator != 0u128) 3 else 2

    
    label 2:
        abort EDENOMINATOR

    
    label 3:
        (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
        jump_if(copy quotient != 0u128) 4 else 5

    
    label 4:
        (%#1: bool) = true;
        jump 6

    
    label 5:
        (%#1: bool) = move#last numerator == 0u64;
        jump 6

    
    label 6:
        jump_if(move#last %#1) 9 else 8

    
    label 8:
        abort ERATIO_OUT_OF_RANGE

    
    label 9:
        jump_if(copy quotient <= MAX_U64) 12 else 11

    
    label 11:
        abort ERATIO_OUT_OF_RANGE

    
    label 12:
        return FixedPoint32<>{value: (move#last quotient as u64)}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: copy value}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: copy value}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: move#last value}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return FixedPoint32<>{value: move#last value}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (copy val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (copy value as u64)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (copy val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (copy value as u64)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (move#last val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (move#last value as u64)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (value: u128) = (move#last val as u128) << 32u8;
        jump_if(copy value <= MAX_U64) 3 else 2

    
    label 2:
        abort ERATIO_OUT_OF_RANGE

    
    label 3:
        return FixedPoint32<>{value: (move#last value as u64)}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (copy quotient as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (copy val as u128) << 32u8;
        (quotient: u128) = copy scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (copy quotient as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 6
    6 => 5
    5 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (move#last val as u128) << 32u8;
        (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (move#last quotient as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => [5, 6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]
    5 <= [3]
    6 <= [3]

traversal:
    0 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&divisor.value != 0u64) 3 else 2

    
    label 2:
        abort EDIVISION_BY_ZERO

    
    label 3:
        (scaled_value: u128) = (move#last val as u128) << 32u8;
        (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
        jump_if(copy quotient <= MAX_U64) 6 else 5

    
    label 5:
        abort EDIVISION

    
    label 6:
        return (move#last quotient as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value >> 32u8
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&num.value == 0u64
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value > *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = copy num2;
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(*&&num1.value < *&&num2.value) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
        jump 3

    
    label 2:
        (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (copy product as u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (copy val as u128) * (*&&multiplier.value as u128);
        (product: u128) = copy unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (copy product as u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
        (product: u128) = move#last unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (move#last product as u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
        (product: u128) = move#last unscaled_product >> 32u8;
        jump_if(copy product <= MAX_U64) 3 else 2

    
    label 2:
        abort EMULTIPLICATION

    
    label 3:
        return (move#last product as u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < copy boundary) 1 else 2

    
    label 1:
        (%#1: u64) = copy floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num);
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < copy boundary) 1 else 2

    
    label 1:
        (%#1: u64) = copy floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(copy num);
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 1u64 << 32u8 / 2u64;
        jump_if(*&&num.value < move#last boundary) 1 else 2

    
    label 1:
        (%#1: u64) = move#last floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
        (boundary: u64) = copy floored_num + 2147483648u64;
        jump_if(*&&num.value < move#last boundary) 1 else 2

    
    label 1:
        (%#1: u64) = move#last floored_num >> 32u8;
        jump 3

    
    label 2:
        (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#485>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#485>((&copy t.vec, 0u64))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#485>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#485>((&copy t.vec, 0u64))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#485>(copy t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#485>((&move#last t.vec, 0u64))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#485>(copy t)) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow<Element#485>((&move#last t.vec, 0u64))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#486>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#486>((&mut copy t.vec, 0u64))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#486>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#486>((&mut copy t.vec, 0u64))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#486>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#486>((&mut move#last t.vec, 0u64))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#486>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::borrow_mut<Element#486>((&mut move#last t.vec, 0u64))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#487>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#487>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: &Element#487) = copy default_ref;
        jump 3

    
    label 2:
        (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#487>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#487>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: &Element#487) = copy default_ref;
        jump 3

    
    label 2:
        (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#487>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#487>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: &Element#487) = move#last default_ref;
        jump 3

    
    label 2:
        pop _ = move#last default_ref;
        (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#487>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#487>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: &Element#487) = move#last default_ref;
        jump 3

    
    label 2:
        pop _ = move#last default_ref;
        (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#488>((&copy t.vec, copy e_ref))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#488>((&copy t.vec, copy e_ref))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#488>((&move#last t.vec, move#last e_ref))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::contains<Element#488>((&move#last t.vec, move#last e_ref))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#489>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#489>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#489>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_none<Element#489>(&t)) 3 else 2

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
        return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#490>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
        (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
        return move#no-copy elem
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#490>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
        (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
        return move#no-copy elem
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#490>(&t)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
        (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
        return move#no-copy elem
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#490>(&t)) 3 else 2

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
        (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
        pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
        return move#no-copy elem
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#491: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#491: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#491: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
        jump_if((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec))) 1 else 2

    
    label 1:
        (%#1: Element#491: drop) = move#no-copy default;
        jump 3

    
    label 2:
        (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec);
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#492>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#492>(&mut copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#492>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#492>(&mut copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#492>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#492>(&mut move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#492>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        return (std=0x1)::vector::pop_back<Element#492>(&mut move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#493>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#493>((copy vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#493>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#493>((copy vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#493>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        pop  = (std=0x1)::vector::push_back<Element#493>((move#last vec_ref, move#no-copy e));
        jump 3

    
    label 2:
        pop _ = move#last vec_ref;
        abort EOPTION_IS_SET

    
    label 3:
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#493>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref))) 3 else 2

    
    label 2:
        pop _ = move#last vec_ref;
        abort EOPTION_IS_SET

    
    label 3:
        pop  = (std=0x1)::vector::push_back<Element#493>((move#last vec_ref, move#no-copy e));
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#500: copy+drop>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: Element#500: copy+drop) = copy default;
        jump 3

    
    label 2:
        (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#500: copy+drop>) = &copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        (%#1: Element#500: copy+drop) = copy default;
        jump 3

    
    label 2:
        (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((copy vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#500: copy+drop>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: Element#500: copy+drop) = move#last default;
        jump 3

    
    label 2:
        (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &vector<Element#500: copy+drop>) = &move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref)) 1 else 2

    
    label 1:
        pop _ = move#last vec_ref;
        (%#1: Element#500: copy+drop) = move#last default;
        jump 3

    
    label 2:
        (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((move#last vec_ref, 0u64));
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#501>(&copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#501>(&copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#501>(&move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<Element#501>(&move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#502>(&copy t.vec)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#502>(&copy t.vec)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#502>(&move#last t.vec)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return ! (std=0x1)::vector::is_empty<Element#502>(&move#last t.vec)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#507>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#507>) = &mut copy t.vec;
        (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#507>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#507>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#507>) = &mut copy t.vec;
        (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#507>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#507>(freeze(copy t))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#507>) = &mut move#last t.vec;
        (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#507>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::option::is_some<Element#507>(freeze(copy t))) 3 else 2

    
    label 2:
        pop _ = move#last t;
        abort EOPTION_NOT_SET

    
    label 3:
        (vec_ref: &mut vector<Element#507>) = &mut move#last t.vec;
        (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
        pop  = (std=0x1)::vector::push_back<Element#507>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#508>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#508>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#508>) = &mut copy t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#508>((copy vec_ref, move#no-copy e));
        return move#no-copy old_value
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#508>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#508>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        (vec_ref: &mut vector<Element#508>) = &mut move#last t.vec;
        jump_if((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref))) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(());
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref));
        jump 3

    
    label 3:
        (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
        pop  = (std=0x1)::vector::push_back<Element#508>((move#last vec_ref, move#no-copy e));
        return move#no-copy old_value
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
        return move#no-copy vec
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
        return move#no-copy vec
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
        return move#no-copy vec
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
        return move#no-copy vec
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(copy s)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(copy s)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(move#last s)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *(std=0x1)::signer::borrow_address<>(move#last s)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut copy s.bytes, *&&r.bytes))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((copy s, (std=0x1)::string::utf8<>(copy bytes)))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy s.bytes
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy s.bytes
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last s.bytes
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last s.bytes
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&copy s.bytes, &copy r.bytes))
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at));
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy at));
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, copy at, copy l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, copy o));
        pop  = (std=0x1)::string::append<>((&mut front, copy end));
        *copy s = copy front;
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 6
    6 => 5

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
        jump 3

    
    label 2:
        pop _ = move#last bytes;
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        jump 6

    
    label 5:
        pop _ = move#last s;
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#3: u64), (%#4: u64)) = (copy s, 0u64, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), move#last %#3, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, move#last o));
        pop  = (std=0x1)::string::append<>((&mut front, move#last end));
        *move#last s = move#last front;
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [5, 6]
    5 => []
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    5 <= [3]
    6 <= [3]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

    
    label 1:
        (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
        jump 3

    
    label 2:
        pop _ = move#last bytes;
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 6 else 5

    
    label 5:
        pop _ = move#last s;
        abort EINVALID_INDEX

    
    label 6:
        (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
        ((%#2: &mut (std=0x1)::string::String), (%#4: u64)) = (copy s, copy at);
        (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), 0u64, move#last %#4));
        ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
        (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
        pop  = (std=0x1)::string::append<>((&mut front, move#last o));
        pop  = (std=0x1)::string::append<>((&mut front, move#last end));
        *move#last s = move#last front;
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&copy s.bytes)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&copy s.bytes)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&copy s.bytes)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&move#last s.bytes)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<u8>(&move#last s.bytes)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= copy l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &copy s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= copy l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((copy bytes, copy i, copy j))}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [10, 11]
    10 => [12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    10 <= [9]
    11 <= [9]
    12 <= [10]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 10
    10 => 12
    12 => 11

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &move#last s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= move#last l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 10 else 11

    
    label 10:
        jump 12

    
    label 11:
        pop _ = move#last bytes;
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => [4, 5]
    4 => [6]
    5 => [6]
    6 => [7, 8]
    7 => [9]
    8 => [9]
    9 => [11, 12]
    11 => []
    12 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]
    4 <= [3]
    5 <= [3]
    6 <= [4, 5]
    7 <= [6]
    8 <= [6]
    9 <= [7, 8]
    11 <= [9]
    12 <= [9]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6
    6 => 7
    7 => 8
    8 => 9
    9 => 11
    11 => 12

loop heads:

start: 0
blocks:

    label 0:
        (bytes: &vector<u8>) = &move#last s.bytes;
        (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
        jump_if(copy j <= move#last l) 1 else 2

    
    label 1:
        (%#1: bool) = copy i <= copy j;
        jump 3

    
    label 2:
        (%#1: bool) = false;
        jump 3

    
    label 3:
        jump_if(move#last %#1) 4 else 5

    
    label 4:
        (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
        jump 6

    
    label 5:
        (%#2: bool) = false;
        jump 6

    
    label 6:
        jump_if(move#last %#2) 7 else 8

    
    label 7:
        (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
        jump 9

    
    label 8:
        (%#3: bool) = false;
        jump 9

    
    label 9:
        jump_if(move#last %#3) 12 else 11

    
    label 11:
        pop _ = move#last bytes;
        abort EINVALID_INDEX

    
    label 12:
        return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: copy bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => [3]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1, 2]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
        jump 3

    
    label 2:
        (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
        jump 3

    
    label 3:
        return move#last %#1
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: copy bytes}
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: copy bytes}
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: move#last bytes}
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 3 else 2

    
    label 2:
        abort EINVALID_UTF8

    
    label 3:
        return String<>{bytes: move#last bytes}
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy self.name
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &copy self.name
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last self.name
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return &move#last self.name
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return *&&self.name
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#511>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)));
        jump 1

    
    label 3:
        pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
        return /*;()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#511>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)));
        jump 1

    
    label 3:
        pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
        return /*;()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#511>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)));
        jump 1

    
    label 3:
        pop _ = move#last lhs;
        pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
        return /*;()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 3]
    2 => [1]
    3 => []

predecessor_map:
    0 <= []
    1 <= [0, 2]
    2 <= [1]
    3 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3

loop heads:
    loop head: 1. back edge predecessor: 2

start: 0
blocks:

    label 0:
        pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
        jump 1

    
    label 1:
        jump_if(! (std=0x1)::vector::is_empty<Element#511>(&other)) 2 else 3

    
    label 2:
        pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)));
        jump 1

    
    label 3:
        pop _ = move#last lhs;
        pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
        return /*;()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return false
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return false
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@true

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return false
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e) 3 else 5

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@true

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return false
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@(true, copy i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return (false, 0u64)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        return@(true, copy i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = copy i + 1u64;
        jump 1

    
    label 6:
        return (false, 0u64)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => []
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e) 3 else 4

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@(true, move#last i)

    
    label 4:
        jump 5

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return (false, 0u64)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 5]
    3 => []
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    5 <= [2]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (i: u64) = 0u64;
        (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
        jump 1

    
    label 1:
        jump_if(copy i < copy len) 2 else 6

    
    label 2:
        jump_if((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e) 3 else 5

    
    label 3:
        pop _ = move#last v;
        pop _ = move#last e;
        return@(true, move#last i)

    
    label 5:
        (i: u64) = move#last i + 1u64;
        jump 1

    
    label 6:
        pop _ = move#last v;
        pop _ = move#last e;
        return (false, 0u64)
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#524>(copy v) == 0u64
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#524>(copy v) == 0u64
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#524>(move#last v) == 0u64
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        return (std=0x1)::vector::length<Element#524>(move#last v) == 0u64
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#530>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = copy i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#530>(copy v)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#530>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = copy i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#530>(copy v)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 2

    
    label 1:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 2:
        jump 3

    
    label 3:
        (len: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#530>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = move#last i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#530>(move#last v)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
        jump_if(copy i >= copy len) 1 else 3

    
    label 1:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (len: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy i < copy len) 5 else 6

    
    label 5:
        (%#2: &mut vector<Element#530>) = copy v;
        (%#1: u64) = copy i;
        (i: u64) = move#last i + 1u64;
        pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i));
        jump 4

    
    label 6:
        return (std=0x1)::vector::pop_back<Element#530>(move#last v)
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
        (front_index: u64) = copy front_index + 1u64;
        (back_index: u64) = copy back_index - 1u64;
        jump 4

    
    label 6:
        return /*()*/
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = copy len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
        (front_index: u64) = copy front_index + 1u64;
        (back_index: u64) = copy back_index - 1u64;
        jump 4

    
    label 6:
        return /*()*/
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => []
    2 => [3]
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [2]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 2

    
    label 1:
        pop _ = move#last v;
        return@()

    
    label 2:
        jump 3

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
        (front_index: u64) = move#last front_index + 1u64;
        (back_index: u64) = move#last back_index - 1u64;
        jump 4

    
    label 6:
        pop _ = move#last v;
        return /*()*/
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 3]
    1 => []
    3 => [4]
    4 => [5, 6]
    5 => [4]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0]
    3 <= [0]
    4 <= [3, 5]
    5 <= [4]
    6 <= [4]

traversal:
    0 => 1
    1 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 4. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
        jump_if(copy len == 0u64) 1 else 3

    
    label 1:
        pop _ = move#last v;
        return@()

    
    label 3:
        (front_index: u64) = 0u64;
        (back_index: u64) = move#last len - 1u64;
        jump 4

    
    label 4:
        jump_if(copy front_index < copy back_index) 5 else 6

    
    label 5:
        pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
        (front_index: u64) = move#last front_index + 1u64;
        (back_index: u64) = move#last back_index - 1u64;
        jump 4

    
    label 6:
        pop _ = move#last v;
        return /*()*/
BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
        return move#no-copy v
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
        return move#no-copy v
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
        return move#no-copy v
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => []

predecessor_map:
    0 <= []

traversal:

loop heads:

start: 0
blocks:

    label 0:
        (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
        pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
        return move#no-copy v
BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#534>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#534>(copy v)
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#534>((copy v, copy i, copy last_idx));
        return (std=0x1)::vector::pop_back<Element#534>(copy v)
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1, 2]
    1 => [3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    1 <= [0]
    2 <= [0]
    3 <= [1]

traversal:
    0 => 1
    1 => 3
    3 => 2

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v))) 1 else 2

    
    label 1:
        jump 3

    
    label 2:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#534>((copy v, move#last i, move#last last_idx));
        return (std=0x1)::vector::pop_back<Element#534>(move#last v)
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [2, 3]
    2 => []
    3 => []

predecessor_map:
    0 <= []
    2 <= [0]
    3 <= [0]

traversal:
    0 => 2
    2 => 3

loop heads:

start: 0
blocks:

    label 0:
        jump_if(! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v))) 3 else 2

    
    label 2:
        pop _ = move#last v;
        abort EINDEX_OUT_OF_BOUNDS

    
    label 3:
        (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
        pop  = (std=0x1)::vector::swap<Element#534>((copy v, move#last i, move#last last_idx));
        return (std=0x1)::vector::pop_back<Element#534>(move#last v)
After cfgir: program = module (std=0x1)::ascii {
    #[]library module
    dependency order #2
    #[]struct Char has copy drop store {
        byte: u8
    }
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_ASCII_CHARACTER:u64 = 65536;
    #[]public all_characters_printable(string: &(std=0x1)::ascii::String): bool {
        locals:
            byte: u8,
            i: u64,
            len: u64,
            string: &(std=0x1)::ascii::String

        loop heads:

            1

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<u8>(&copy string.bytes);
            (i: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from (std=0x1)::ascii::all_characters_printable::#0 uses [i (i), len (len), string (string)];
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            (byte: u8) = *(std=0x1)::vector::borrow<u8>((&copy string.bytes, copy i));
            jump_if(! (std=0x1)::ascii::is_printable_char<>(move#last byte)) 3 else 5

        
        label 3:
            pop _ = move#last string;
            return@false

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop  = spec #1 from (std=0x1)::ascii::all_characters_printable::#1 uses [i (i), len (len), string (string)];
            return true


    }
    #[]public as_bytes(string: &(std=0x1)::ascii::String): &vector<u8> {
        locals:
            string: &(std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return &move#last string.bytes


    }
    #[]public byte(char: (std=0x1)::ascii::Char): u8 {
        locals:
            byte: u8,
            char: (std=0x1)::ascii::Char

        loop heads:


        start=0

        label 0:
            Char<>{byte: (byte: u8)} = move#last char;
            return move#last byte


    }
    #[]public char(byte: u8): (std=0x1)::ascii::Char {
        locals:
            byte: u8

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::ascii::is_valid_char<>(copy byte)) 3 else 2

        
        label 2:
            abort EINVALID_ASCII_CHARACTER

        
        label 3:
            return Char<>{byte: move#last byte}


    }
    #[]public into_bytes(string: (std=0x1)::ascii::String): vector<u8> {
        locals:
            bytes: vector<u8>,
            string: (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            String<>{bytes: (bytes: vector<u8>)} = move#last string;
            return move#last bytes


    }
    #[]public is_printable_char(byte: u8): bool {
        locals:
            %#1: bool,
            byte: u8

        loop heads:


        start=0

        label 0:
            jump_if(copy byte >= 32u8) 1 else 2

        
        label 1:
            (%#1: bool) = move#last byte <= 126u8;
            jump 3

        
        label 2:
            (%#1: bool) = false;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public is_valid_char(b: u8): bool {
        locals:
            b: u8

        loop heads:


        start=0

        label 0:
            return move#last b <= 127u8


    }
    #[]public length(string: &(std=0x1)::ascii::String): u64 {
        locals:
            string: &(std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<u8>((std=0x1)::ascii::as_bytes<>(move#last string))


    }
    #[]public pop_char(string: &mut (std=0x1)::ascii::String): (std=0x1)::ascii::Char {
        locals:
            string: &mut (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            return Char<>{byte: (std=0x1)::vector::pop_back<u8>(&mut move#last string.bytes)}


    }
    #[]public push_char(string: &mut (std=0x1)::ascii::String, char: (std=0x1)::ascii::Char): () {
        locals:
            char: (std=0x1)::ascii::Char,
            string: &mut (std=0x1)::ascii::String

        loop heads:


        start=0

        label 0:
            pop  = (std=0x1)::vector::push_back<u8>((&mut move#last string.bytes, *&&char.byte));
            return /*;()*/


    }
    #[]public string(bytes: vector<u8>): (std=0x1)::ascii::String {
        locals:
            bytes: vector<u8>,
            x: (std=0x1)::option::Option<(std=0x1)::ascii::String>

        loop heads:


        start=0

        label 0:
            (x: (std=0x1)::option::Option<(std=0x1)::ascii::String>) = (std=0x1)::ascii::try_string<>(move#last bytes);
            jump_if((std=0x1)::option::is_some<(std=0x1)::ascii::String>(&x)) 3 else 2

        
        label 2:
            abort EINVALID_ASCII_CHARACTER

        
        label 3:
            return (std=0x1)::option::destroy_some<(std=0x1)::ascii::String>(move#last x)


    }
    #[]public try_string(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::ascii::String> {
        locals:
            bytes: vector<u8>,
            i: u64,
            len: u64,
            possible_byte: u8

        loop heads:

            1

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<u8>(&bytes);
            (i: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from (std=0x1)::ascii::try_string::#0 uses [bytes (bytes), i (i), len (len)];
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            (possible_byte: u8) = *(std=0x1)::vector::borrow<u8>((&bytes, copy i));
            jump_if(! (std=0x1)::ascii::is_valid_char<>(move#last possible_byte)) 3 else 5

        
        label 3:
            return@(std=0x1)::option::none<(std=0x1)::ascii::String>(())

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop  = spec #1 from (std=0x1)::ascii::try_string::#1 uses [bytes (bytes), i (i), len (len)];
            return (std=0x1)::option::some<(std=0x1)::ascii::String>(String<>{bytes: move#last bytes})


    }

}
module (std=0x1)::bcs {
    #[]library module
    dependency order #0
    #[]public native to_bytes<MoveValue#483>(v: &MoveValue#483): vector<u8>;


}
module (std=0x1)::bit_vector {
    #[]library module
    dependency order #3
    #[]struct BitVector has copy drop store {
        length: u64;
        bit_field: vector<bool>
    }
    #[]const EINDEX:u64 = 131072;
    #[]const ELENGTH:u64 = 131073;
    #[]const MAX_SIZE:u64 = 1024;
    #[]const WORD_SIZE:u64 = 1;
    #[]public is_index_set(bitvector: &(std=0x1)::bit_vector::BitVector, bit_index: u64): bool {
        locals:
            bit_index: u64,
            bitvector: &(std=0x1)::bit_vector::BitVector

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            return *(std=0x1)::vector::borrow<bool>((&move#last bitvector.bit_field, move#last bit_index))


    }
    #[]public length(bitvector: &(std=0x1)::bit_vector::BitVector): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<bool>(&move#last bitvector.bit_field)


    }
    #[]public longest_set_sequence_starting_at(bitvector: &(std=0x1)::bit_vector::BitVector, start_index: u64): u64 {
        locals:
            bitvector: &(std=0x1)::bit_vector::BitVector,
            index: u64,
            start_index: u64

        loop heads:

            4

        start=0

        label 0:
            jump_if(copy start_index < *&copy bitvector.length) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (index: u64) = copy start_index;
            jump 4

        
        label 4:
            jump_if(copy index < *&copy bitvector.length) 5 else 13

        
        label 5:
            jump_if(! (std=0x1)::bit_vector::is_index_set<>((copy bitvector, copy index))) 6 else 8

        
        label 6:
            pop _ = move#last bitvector;
            jump@9

        
        label 8:
            (index: u64) = move#last index + 1u64;
            jump 4

        
        label 9:
            return move#last index - move#last start_index

        
        label 13:
            pop _ = move#last bitvector;
            jump 9


    }
    #[]public new(length: u64): (std=0x1)::bit_vector::BitVector {
        locals:
            bit_field: vector<bool>,
            counter: u64,
            length: u64

        loop heads:

            7

        start=0

        label 0:
            jump_if(copy length > 0u64) 3 else 2

        
        label 2:
            abort ELENGTH

        
        label 3:
            jump_if(copy length < MAX_SIZE) 6 else 5

        
        label 5:
            abort ELENGTH

        
        label 6:
            (counter: u64) = 0u64;
            (bit_field: vector<bool>) = (std=0x1)::vector::empty<bool>(());
            jump 7

        
        label 7:
            pop  = spec #0 from (std=0x1)::bit_vector::new::#0 uses [bit_field (bit_field), counter (counter), length (length)];
            jump_if(copy counter < copy length) 8 else 9

        
        label 8:
            pop  = (std=0x1)::vector::push_back<bool>((&mut bit_field, false));
            (counter: u64) = move#last counter + 1u64;
            jump 7

        
        label 9:
            pop  = spec #1 from (std=0x1)::bit_vector::new::#1 uses [bit_field (bit_field), counter (counter), length (length)];
            return BitVector<>{length: move#last length, bit_field: move#last bit_field}


    }
    #[]public set(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
            *move#last x = true;
            return /*;()*/


    }
    #[]public shift_left(bitvector: &mut (std=0x1)::bit_vector::BitVector, amount: u64): () {
        locals:
            %#2: &mut (std=0x1)::bit_vector::BitVector,
            %#3: u64,
            amount: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            elem: &mut bool,
            i: u64,
            i#1: u64,
            len: u64

        loop heads:

            2
            6
            12

        start=0

        label 0:
            jump_if(copy amount >= *&copy bitvector.length) 1 else 5

        
        label 1:
            (len: u64) = (std=0x1)::vector::length<bool>(&copy bitvector.bit_field);
            (i: u64) = 0u64;
            jump 2

        
        label 2:
            jump_if(copy i < copy len) 3 else 4

        
        label 3:
            (elem: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut copy bitvector.bit_field, copy i));
            *move#last elem = false;
            (i: u64) = move#last i + 1u64;
            jump 2

        
        label 4:
            pop _ = move#last bitvector;
            jump 15

        
        label 5:
            (i#1: u64) = copy amount;
            jump 6

        
        label 6:
            jump_if(copy i#1 < *&copy bitvector.length) 7 else 11

        
        label 7:
            ((%#2: &mut (std=0x1)::bit_vector::BitVector), (%#3: u64)) = (copy bitvector, copy i#1);
            jump_if((std=0x1)::bit_vector::is_index_set<>((freeze(move#last %#2), move#last %#3))) 8 else 9

        
        label 8:
            pop  = (std=0x1)::bit_vector::set<>((copy bitvector, copy i#1 - copy amount));
            jump 10

        
        label 9:
            pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1 - copy amount));
            jump 10

        
        label 10:
            (i#1: u64) = move#last i#1 + 1u64;
            jump 6

        
        label 11:
            (i#1: u64) = *&copy bitvector.length - move#last amount;
            jump 12

        
        label 12:
            jump_if(copy i#1 < *&copy bitvector.length) 13 else 14

        
        label 13:
            pop  = (std=0x1)::bit_vector::unset<>((copy bitvector, copy i#1));
            (i#1: u64) = move#last i#1 + 1u64;
            jump 12

        
        label 14:
            pop _ = move#last bitvector;
            jump 15

        
        label 15:
            return /*()*/


    }
    #[]public unset(bitvector: &mut (std=0x1)::bit_vector::BitVector, bit_index: u64): () {
        locals:
            bit_index: u64,
            bitvector: &mut (std=0x1)::bit_vector::BitVector,
            x: &mut bool

        loop heads:


        start=0

        label 0:
            jump_if(copy bit_index < (std=0x1)::vector::length<bool>(&copy bitvector.bit_field)) 3 else 2

        
        label 2:
            pop _ = move#last bitvector;
            abort EINDEX

        
        label 3:
            (x: &mut bool) = (std=0x1)::vector::borrow_mut<bool>((&mut move#last bitvector.bit_field, move#last bit_index));
            *move#last x = false;
            return /*;()*/


    }

}
module (std=0x1)::error {
    #[]library module
    dependency order #0
    #[]const ABORTED:u64 = 7;
    #[]const ALREADY_EXISTS:u64 = 8;
    #[]const CANCELLED:u64 = 10;
    #[]const INTERNAL:u64 = 11;
    #[]const INVALID_ARGUMENT:u64 = 1;
    #[]const INVALID_STATE:u64 = 3;
    #[]const NOT_FOUND:u64 = 6;
    #[]const NOT_IMPLEMENTED:u64 = 12;
    #[]const OUT_OF_RANGE:u64 = 2;
    #[]const PERMISSION_DENIED:u64 = 5;
    #[]const RESOURCE_EXHAUSTED:u64 = 9;
    #[]const UNAUTHENTICATED:u64 = 4;
    #[]const UNAVAILABLE:u64 = 13;
    #[]public aborted(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((ABORTED, move#last r))


    }
    #[]public already_exists(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((ALREADY_EXISTS, move#last r))


    }
    #[]public canonical(category: u64, reason: u64): u64 {
        locals:
            category: u64,
            reason: u64

        loop heads:


        start=0

        label 0:
            return move#last category << 16u8 + move#last reason


    }
    #[]public internal(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INTERNAL, move#last r))


    }
    #[]public invalid_argument(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INVALID_ARGUMENT, move#last r))


    }
    #[]public invalid_state(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((INVALID_STATE, move#last r))


    }
    #[]public not_found(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((NOT_FOUND, move#last r))


    }
    #[]public not_implemented(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((NOT_IMPLEMENTED, move#last r))


    }
    #[]public out_of_range(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((OUT_OF_RANGE, move#last r))


    }
    #[]public permission_denied(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((PERMISSION_DENIED, move#last r))


    }
    #[]public resource_exhausted(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((RESOURCE_EXHAUSTED, move#last r))


    }
    #[]public unauthenticated(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((UNAUTHENTICATED, move#last r))


    }
    #[]public unavailable(r: u64): u64 {
        locals:
            r: u64

        loop heads:


        start=0

        label 0:
            return (std=0x1)::error::canonical<>((UNAVAILABLE, move#last r))


    }

}
module (std=0x1)::fixed_point32 {
    #[]library module
    dependency order #0
    #[]struct FixedPoint32 has copy drop store {
        value: u64
    }
    #[]const EDENOMINATOR:u64 = 65537;
    #[]const EDIVISION:u64 = 131074;
    #[]const EDIVISION_BY_ZERO:u64 = 65540;
    #[]const EMULTIPLICATION:u64 = 131075;
    #[]const ERATIO_OUT_OF_RANGE:u64 = 131077;
    #[]const MAX_U64:u128 = 18446744073709551615;
    #[]public ceil(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32,
            val: u128

        loop heads:


        start=0

        label 0:
            (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
            jump_if(*&&num.value == copy floored_num) 1 else 3

        
        label 1:
            return@move#last floored_num >> 32u8

        
        label 3:
            (val: u128) = (move#last floored_num as u128) + 4294967296u128;
            return (move#last val >> 32u8 as u64)


    }
    #[]public create_from_rational(numerator: u64, denominator: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: bool,
            denominator: u64,
            numerator: u64,
            quotient: u128,
            scaled_denominator: u128,
            scaled_numerator: u128

        loop heads:


        start=0

        label 0:
            (scaled_numerator: u128) = (copy numerator as u128) << 64u8;
            (scaled_denominator: u128) = (move#last denominator as u128) << 32u8;
            jump_if(copy scaled_denominator != 0u128) 3 else 2

        
        label 2:
            abort EDENOMINATOR

        
        label 3:
            (quotient: u128) = move#last scaled_numerator / move#last scaled_denominator;
            jump_if(copy quotient != 0u128) 4 else 5

        
        label 4:
            (%#1: bool) = true;
            jump 6

        
        label 5:
            (%#1: bool) = move#last numerator == 0u64;
            jump 6

        
        label 6:
            jump_if(move#last %#1) 9 else 8

        
        label 8:
            abort ERATIO_OUT_OF_RANGE

        
        label 9:
            jump_if(copy quotient <= MAX_U64) 12 else 11

        
        label 11:
            abort ERATIO_OUT_OF_RANGE

        
        label 12:
            return FixedPoint32<>{value: (move#last quotient as u64)}


    }
    #[]public create_from_raw_value(value: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            value: u64

        loop heads:


        start=0

        label 0:
            return FixedPoint32<>{value: move#last value}


    }
    #[]public create_from_u64(val: u64): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            val: u64,
            value: u128

        loop heads:


        start=0

        label 0:
            (value: u128) = (move#last val as u128) << 32u8;
            jump_if(copy value <= MAX_U64) 3 else 2

        
        label 2:
            abort ERATIO_OUT_OF_RANGE

        
        label 3:
            return FixedPoint32<>{value: (move#last value as u64)}


    }
    #[]public divide_u64(val: u64, divisor: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            divisor: (std=0x1)::fixed_point32::FixedPoint32,
            quotient: u128,
            scaled_value: u128,
            val: u64

        loop heads:


        start=0

        label 0:
            jump_if(*&&divisor.value != 0u64) 3 else 2

        
        label 2:
            abort EDIVISION_BY_ZERO

        
        label 3:
            (scaled_value: u128) = (move#last val as u128) << 32u8;
            (quotient: u128) = move#last scaled_value / (*&&divisor.value as u128);
            jump_if(copy quotient <= MAX_U64) 6 else 5

        
        label 5:
            abort EDIVISION

        
        label 6:
            return (move#last quotient as u64)


    }
    #[]public floor(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value >> 32u8


    }
    #[]public get_raw_value(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value


    }
    #[]public is_zero(num: (std=0x1)::fixed_point32::FixedPoint32): bool {
        locals:
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            return *&&num.value == 0u64


    }
    #[]public max(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            jump_if(*&&num1.value > *&&num2.value) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
            jump 3

        
        label 2:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public min(num1: (std=0x1)::fixed_point32::FixedPoint32, num2: (std=0x1)::fixed_point32::FixedPoint32): (std=0x1)::fixed_point32::FixedPoint32 {
        locals:
            %#1: (std=0x1)::fixed_point32::FixedPoint32,
            num1: (std=0x1)::fixed_point32::FixedPoint32,
            num2: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            jump_if(*&&num1.value < *&&num2.value) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num1;
            jump 3

        
        label 2:
            (%#1: (std=0x1)::fixed_point32::FixedPoint32) = move#last num2;
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public multiply_u64(val: u64, multiplier: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            multiplier: (std=0x1)::fixed_point32::FixedPoint32,
            product: u128,
            unscaled_product: u128,
            val: u64

        loop heads:


        start=0

        label 0:
            (unscaled_product: u128) = (move#last val as u128) * (*&&multiplier.value as u128);
            (product: u128) = move#last unscaled_product >> 32u8;
            jump_if(copy product <= MAX_U64) 3 else 2

        
        label 2:
            abort EMULTIPLICATION

        
        label 3:
            return (move#last product as u64)


    }
    #[]public round(num: (std=0x1)::fixed_point32::FixedPoint32): u64 {
        locals:
            %#1: u64,
            boundary: u64,
            floored_num: u64,
            num: (std=0x1)::fixed_point32::FixedPoint32

        loop heads:


        start=0

        label 0:
            (floored_num: u64) = (std=0x1)::fixed_point32::floor<>(copy num) << 32u8;
            (boundary: u64) = copy floored_num + 2147483648u64;
            jump_if(*&&num.value < move#last boundary) 1 else 2

        
        label 1:
            (%#1: u64) = move#last floored_num >> 32u8;
            jump 3

        
        label 2:
            (%#1: u64) = (std=0x1)::fixed_point32::ceil<>(move#last num);
            jump 3

        
        label 3:
            return move#last %#1


    }

}
module (std=0x1)::hash {
    #[]library module
    dependency order #0
    #[]public native sha2_256(data: vector<u8>): vector<u8>;

    #[]public native sha3_256(data: vector<u8>): vector<u8>;


}
module (std=0x1)::option {
    #[]library module
    dependency order #1
    #[]struct Option<Element#484> has copy drop store {
        vec: vector<Element#484>
    }
    #[]const EOPTION_IS_SET:u64 = 262144;
    #[]const EOPTION_NOT_SET:u64 = 262145;
    #[]public borrow<Element#485>(t: &(std=0x1)::option::Option<Element#485>): &Element#485 {
        locals:
            t: &(std=0x1)::option::Option<Element#485>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#485>(copy t)) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::borrow<Element#485>((&move#last t.vec, 0u64))


    }
    #[]public borrow_mut<Element#486>(t: &mut (std=0x1)::option::Option<Element#486>): &mut Element#486 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#486>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#486>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::borrow_mut<Element#486>((&mut move#last t.vec, 0u64))


    }
    #[]public borrow_with_default<Element#487>(t: &(std=0x1)::option::Option<Element#487>, default_ref: &Element#487): &Element#487 {
        locals:
            %#1: &Element#487,
            default_ref: &Element#487,
            t: &(std=0x1)::option::Option<Element#487>,
            vec_ref: &vector<Element#487>

        loop heads:


        start=0

        label 0:
            (vec_ref: &vector<Element#487>) = &move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#487>(copy vec_ref)) 1 else 2

        
        label 1:
            pop _ = move#last vec_ref;
            (%#1: &Element#487) = move#last default_ref;
            jump 3

        
        label 2:
            pop _ = move#last default_ref;
            (%#1: &Element#487) = (std=0x1)::vector::borrow<Element#487>((move#last vec_ref, 0u64));
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public contains<Element#488>(t: &(std=0x1)::option::Option<Element#488>, e_ref: &Element#488): bool {
        locals:
            e_ref: &Element#488,
            t: &(std=0x1)::option::Option<Element#488>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::contains<Element#488>((&move#last t.vec, move#last e_ref))


    }
    #[]public destroy_none<Element#489>(t: (std=0x1)::option::Option<Element#489>): () {
        locals:
            t: (std=0x1)::option::Option<Element#489>,
            vec: vector<Element#489>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_none<Element#489>(&t)) 3 else 2

        
        label 2:
            abort EOPTION_IS_SET

        
        label 3:
            Option<Element#489>{vec: (vec: vector<Element#489>)} = move#no-copy t;
            return (std=0x1)::vector::destroy_empty<Element#489>(move#no-copy vec)


    }
    #[]public destroy_some<Element#490>(t: (std=0x1)::option::Option<Element#490>): Element#490 {
        locals:
            elem: Element#490,
            t: (std=0x1)::option::Option<Element#490>,
            vec: vector<Element#490>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#490>(&t)) 3 else 2

        
        label 2:
            abort EOPTION_NOT_SET

        
        label 3:
            Option<Element#490>{vec: (vec: vector<Element#490>)} = move#no-copy t;
            (elem: Element#490) = (std=0x1)::vector::pop_back<Element#490>(&mut vec);
            pop  = (std=0x1)::vector::destroy_empty<Element#490>(move#no-copy vec);
            return move#no-copy elem


    }
    #[]public destroy_with_default<Element#491: drop>(t: (std=0x1)::option::Option<Element#491: drop>, default: Element#491: drop): Element#491: drop {
        locals:
            %#1: Element#491: drop,
            default: Element#491: drop,
            t: (std=0x1)::option::Option<Element#491: drop>,
            vec: vector<Element#491: drop>

        loop heads:


        start=0

        label 0:
            Option<Element#491: drop>{vec: (vec: vector<Element#491: drop>)} = move#no-copy t;
            jump_if((std=0x1)::vector::is_empty<Element#491: drop>(freeze(&mut vec))) 1 else 2

        
        label 1:
            (%#1: Element#491: drop) = move#no-copy default;
            jump 3

        
        label 2:
            (%#1: Element#491: drop) = (std=0x1)::vector::pop_back<Element#491: drop>(&mut vec);
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public extract<Element#492>(t: &mut (std=0x1)::option::Option<Element#492>): Element#492 {
        locals:
            t: &mut (std=0x1)::option::Option<Element#492>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#492>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            return (std=0x1)::vector::pop_back<Element#492>(&mut move#last t.vec)


    }
    #[]public fill<Element#493>(t: &mut (std=0x1)::option::Option<Element#493>, e: Element#493): () {
        locals:
            e: Element#493,
            t: &mut (std=0x1)::option::Option<Element#493>,
            vec_ref: &mut vector<Element#493>

        loop heads:


        start=0

        label 0:
            (vec_ref: &mut vector<Element#493>) = &mut move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#493>(freeze(copy vec_ref))) 3 else 2

        
        label 2:
            pop _ = move#last vec_ref;
            abort EOPTION_IS_SET

        
        label 3:
            pop  = (std=0x1)::vector::push_back<Element#493>((move#last vec_ref, move#no-copy e));
            return /*()*/


    }
    #[]public get_with_default<Element#500: copy+drop>(t: &(std=0x1)::option::Option<Element#500: copy+drop>, default: Element#500: copy+drop): Element#500: copy+drop {
        locals:
            %#1: Element#500: copy+drop,
            default: Element#500: copy+drop,
            t: &(std=0x1)::option::Option<Element#500: copy+drop>,
            vec_ref: &vector<Element#500: copy+drop>

        loop heads:


        start=0

        label 0:
            (vec_ref: &vector<Element#500: copy+drop>) = &move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#500: copy+drop>(copy vec_ref)) 1 else 2

        
        label 1:
            pop _ = move#last vec_ref;
            (%#1: Element#500: copy+drop) = move#last default;
            jump 3

        
        label 2:
            (%#1: Element#500: copy+drop) = *(std=0x1)::vector::borrow<Element#500: copy+drop>((move#last vec_ref, 0u64));
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public is_none<Element#501>(t: &(std=0x1)::option::Option<Element#501>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#501>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::is_empty<Element#501>(&move#last t.vec)


    }
    #[]public is_some<Element#502>(t: &(std=0x1)::option::Option<Element#502>): bool {
        locals:
            t: &(std=0x1)::option::Option<Element#502>

        loop heads:


        start=0

        label 0:
            return ! (std=0x1)::vector::is_empty<Element#502>(&move#last t.vec)


    }
    #[]public none<Element#505>(): (std=0x1)::option::Option<Element#505> {
        locals:


        loop heads:


        start=0

        label 0:
            return Option<Element#505>{vec: (std=0x1)::vector::empty<Element#505>(())}


    }
    #[]public some<Element#506>(e: Element#506): (std=0x1)::option::Option<Element#506> {
        locals:
            e: Element#506

        loop heads:


        start=0

        label 0:
            return Option<Element#506>{vec: (std=0x1)::vector::singleton<Element#506>(move#no-copy e)}


    }
    #[]public swap<Element#507>(t: &mut (std=0x1)::option::Option<Element#507>, e: Element#507): Element#507 {
        locals:
            e: Element#507,
            old_value: Element#507,
            t: &mut (std=0x1)::option::Option<Element#507>,
            vec_ref: &mut vector<Element#507>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::option::is_some<Element#507>(freeze(copy t))) 3 else 2

        
        label 2:
            pop _ = move#last t;
            abort EOPTION_NOT_SET

        
        label 3:
            (vec_ref: &mut vector<Element#507>) = &mut move#last t.vec;
            (old_value: Element#507) = (std=0x1)::vector::pop_back<Element#507>(copy vec_ref);
            pop  = (std=0x1)::vector::push_back<Element#507>((move#last vec_ref, move#no-copy e));
            return move#no-copy old_value


    }
    #[]public swap_or_fill<Element#508>(t: &mut (std=0x1)::option::Option<Element#508>, e: Element#508): (std=0x1)::option::Option<Element#508> {
        locals:
            %#1: (std=0x1)::option::Option<Element#508>,
            e: Element#508,
            old_value: (std=0x1)::option::Option<Element#508>,
            t: &mut (std=0x1)::option::Option<Element#508>,
            vec_ref: &mut vector<Element#508>

        loop heads:


        start=0

        label 0:
            (vec_ref: &mut vector<Element#508>) = &mut move#last t.vec;
            jump_if((std=0x1)::vector::is_empty<Element#508>(freeze(copy vec_ref))) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::none<Element#508>(());
            jump 3

        
        label 2:
            (%#1: (std=0x1)::option::Option<Element#508>) = (std=0x1)::option::some<Element#508>((std=0x1)::vector::pop_back<Element#508>(copy vec_ref));
            jump 3

        
        label 3:
            (old_value: (std=0x1)::option::Option<Element#508>) = move#last %#1;
            pop  = (std=0x1)::vector::push_back<Element#508>((move#last vec_ref, move#no-copy e));
            return move#no-copy old_value


    }
    #[]public to_vec<Element#509>(t: (std=0x1)::option::Option<Element#509>): vector<Element#509> {
        locals:
            t: (std=0x1)::option::Option<Element#509>,
            vec: vector<Element#509>

        loop heads:


        start=0

        label 0:
            Option<Element#509>{vec: (vec: vector<Element#509>)} = move#no-copy t;
            return move#no-copy vec


    }

}
module (std=0x1)::signer {
    #[]library module
    dependency order #0
    #[]public address_of(s: &signer): address {
        locals:
            s: &signer

        loop heads:


        start=0

        label 0:
            return *(std=0x1)::signer::borrow_address<>(move#last s)


    }
    #[]public native borrow_address(s: &signer): &address;


}
module (std=0x1)::string {
    #[]library module
    dependency order #4
    #[]struct String has copy drop store {
        bytes: vector<u8>
    }
    #[]const EINVALID_INDEX:u64 = 2;
    #[]const EINVALID_UTF8:u64 = 1;
    #[]public append(s: &mut (std=0x1)::string::String, r: (std=0x1)::string::String): () {
        locals:
            r: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::append<u8>((&mut move#last s.bytes, *&&r.bytes))


    }
    #[]public append_utf8(s: &mut (std=0x1)::string::String, bytes: vector<u8>): () {
        locals:
            bytes: vector<u8>,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::string::append<>((move#last s, (std=0x1)::string::utf8<>(move#last bytes)))


    }
    #[]public bytes(s: &(std=0x1)::string::String): &vector<u8> {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return &move#last s.bytes


    }
    #[]public index_of(s: &(std=0x1)::string::String, r: &(std=0x1)::string::String): u64 {
        locals:
            r: &(std=0x1)::string::String,
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::string::internal_index_of<>((&move#last s.bytes, &move#last r.bytes))


    }
    #[]public insert(s: &mut (std=0x1)::string::String, at: u64, o: (std=0x1)::string::String): () {
        locals:
            %#1: bool,
            %#2: &mut (std=0x1)::string::String,
            %#3: u64,
            %#4: u64,
            %#5: &mut (std=0x1)::string::String,
            %#6: u64,
            %#7: u64,
            at: u64,
            bytes: &vector<u8>,
            end: (std=0x1)::string::String,
            front: (std=0x1)::string::String,
            l: u64,
            o: (std=0x1)::string::String,
            s: &mut (std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            (bytes: &vector<u8>) = &copy s.bytes;
            jump_if(copy at <= (std=0x1)::vector::length<u8>(copy bytes)) 1 else 2

        
        label 1:
            (%#1: bool) = (std=0x1)::string::internal_is_char_boundary<>((move#last bytes, copy at));
            jump 3

        
        label 2:
            pop _ = move#last bytes;
            (%#1: bool) = false;
            jump 3

        
        label 3:
            jump_if(move#last %#1) 6 else 5

        
        label 5:
            pop _ = move#last s;
            abort EINVALID_INDEX

        
        label 6:
            (l: u64) = (std=0x1)::string::length<>(freeze(copy s));
            ((%#2: &mut (std=0x1)::string::String), (%#4: u64)) = (copy s, copy at);
            (front: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#2), 0u64, move#last %#4));
            ((%#5: &mut (std=0x1)::string::String), (%#6: u64), (%#7: u64)) = (copy s, move#last at, move#last l);
            (end: (std=0x1)::string::String) = (std=0x1)::string::sub_string<>((freeze(move#last %#5), move#last %#6, move#last %#7));
            pop  = (std=0x1)::string::append<>((&mut front, move#last o));
            pop  = (std=0x1)::string::append<>((&mut front, move#last end));
            *move#last s = move#last front;
            return /*;()*/


    }
    #[] native internal_check_utf8(v: &vector<u8>): bool;

    #[] native internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;

    #[] native internal_is_char_boundary(v: &vector<u8>, i: u64): bool;

    #[] native internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;

    #[]public is_empty(s: &(std=0x1)::string::String): bool {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::is_empty<u8>(&move#last s.bytes)


    }
    #[]public length(s: &(std=0x1)::string::String): u64 {
        locals:
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<u8>(&move#last s.bytes)


    }
    #[]public sub_string(s: &(std=0x1)::string::String, i: u64, j: u64): (std=0x1)::string::String {
        locals:
            %#1: bool,
            %#2: bool,
            %#3: bool,
            bytes: &vector<u8>,
            i: u64,
            j: u64,
            l: u64,
            s: &(std=0x1)::string::String

        loop heads:


        start=0

        label 0:
            (bytes: &vector<u8>) = &move#last s.bytes;
            (l: u64) = (std=0x1)::vector::length<u8>(copy bytes);
            jump_if(copy j <= move#last l) 1 else 2

        
        label 1:
            (%#1: bool) = copy i <= copy j;
            jump 3

        
        label 2:
            (%#1: bool) = false;
            jump 3

        
        label 3:
            jump_if(move#last %#1) 4 else 5

        
        label 4:
            (%#2: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy i));
            jump 6

        
        label 5:
            (%#2: bool) = false;
            jump 6

        
        label 6:
            jump_if(move#last %#2) 7 else 8

        
        label 7:
            (%#3: bool) = (std=0x1)::string::internal_is_char_boundary<>((copy bytes, copy j));
            jump 9

        
        label 8:
            (%#3: bool) = false;
            jump 9

        
        label 9:
            jump_if(move#last %#3) 12 else 11

        
        label 11:
            pop _ = move#last bytes;
            abort EINVALID_INDEX

        
        label 12:
            return String<>{bytes: (std=0x1)::string::internal_sub_string<>((move#last bytes, move#last i, move#last j))}


    }
    #[]public try_utf8(bytes: vector<u8>): (std=0x1)::option::Option<(std=0x1)::string::String> {
        locals:
            %#1: (std=0x1)::option::Option<(std=0x1)::string::String>,
            bytes: vector<u8>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 1 else 2

        
        label 1:
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::some<(std=0x1)::string::String>(String<>{bytes: move#last bytes});
            jump 3

        
        label 2:
            (%#1: (std=0x1)::option::Option<(std=0x1)::string::String>) = (std=0x1)::option::none<(std=0x1)::string::String>(());
            jump 3

        
        label 3:
            return move#last %#1


    }
    #[]public utf8(bytes: vector<u8>): (std=0x1)::string::String {
        locals:
            bytes: vector<u8>

        loop heads:


        start=0

        label 0:
            jump_if((std=0x1)::string::internal_check_utf8<>(&bytes)) 3 else 2

        
        label 2:
            abort EINVALID_UTF8

        
        label 3:
            return String<>{bytes: move#last bytes}


    }

}
module (std=0x1)::type_name {
    #[]library module
    dependency order #5
    #[]struct TypeName has copy drop store {
        name: (std=0x1)::ascii::String
    }
    #[]public borrow_string(self: &(std=0x1)::type_name::TypeName): &(std=0x1)::ascii::String {
        locals:
            self: &(std=0x1)::type_name::TypeName

        loop heads:


        start=0

        label 0:
            return &move#last self.name


    }
    #[]public native get<T#510>(): (std=0x1)::type_name::TypeName;

    #[]public into_string(self: (std=0x1)::type_name::TypeName): (std=0x1)::ascii::String {
        locals:
            self: (std=0x1)::type_name::TypeName

        loop heads:


        start=0

        label 0:
            return *&&self.name


    }

}
module (std=0x1)::vector {
    #[]library module
    dependency order #0
    #[]const EINDEX_OUT_OF_BOUNDS:u64 = 131072;
    #[]public append<Element#511>(lhs: &mut vector<Element#511>, other: vector<Element#511>): () {
        locals:
            lhs: &mut vector<Element#511>,
            other: vector<Element#511>

        loop heads:

            1

        start=0

        label 0:
            pop  = (std=0x1)::vector::reverse<Element#511>(&mut other);
            jump 1

        
        label 1:
            jump_if(! (std=0x1)::vector::is_empty<Element#511>(&other)) 2 else 3

        
        label 2:
            pop  = (std=0x1)::vector::push_back<Element#511>((copy lhs, (std=0x1)::vector::pop_back<Element#511>(&mut other)));
            jump 1

        
        label 3:
            pop _ = move#last lhs;
            pop  = (std=0x1)::vector::destroy_empty<Element#511>(move#no-copy other);
            return /*;()*/


    }
    #[bytecode_instruction]public native borrow<Element#512>(v: &vector<Element#512>, i: u64): &Element#512;

    #[bytecode_instruction]public native borrow_mut<Element#513>(v: &mut vector<Element#513>, i: u64): &mut Element#513;

    #[]public contains<Element#514>(v: &vector<Element#514>, e: &Element#514): bool {
        locals:
            e: &Element#514,
            i: u64,
            len: u64,
            v: &vector<Element#514>

        loop heads:

            1

        start=0

        label 0:
            (i: u64) = 0u64;
            (len: u64) = (std=0x1)::vector::length<Element#514>(copy v);
            jump 1

        
        label 1:
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            jump_if((std=0x1)::vector::borrow<Element#514>((copy v, copy i)) == copy e) 3 else 5

        
        label 3:
            pop _ = move#last v;
            pop _ = move#last e;
            return@true

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop _ = move#last v;
            pop _ = move#last e;
            return false


    }
    #[bytecode_instruction]public native destroy_empty<Element#515>(v: vector<Element#515>): ();

    #[bytecode_instruction]public native empty<Element#516>(): vector<Element#516>;

    #[]public index_of<Element#523>(v: &vector<Element#523>, e: &Element#523): (bool, u64) {
        locals:
            e: &Element#523,
            i: u64,
            len: u64,
            v: &vector<Element#523>

        loop heads:

            1

        start=0

        label 0:
            (i: u64) = 0u64;
            (len: u64) = (std=0x1)::vector::length<Element#523>(copy v);
            jump 1

        
        label 1:
            jump_if(copy i < copy len) 2 else 6

        
        label 2:
            jump_if((std=0x1)::vector::borrow<Element#523>((copy v, copy i)) == copy e) 3 else 5

        
        label 3:
            pop _ = move#last v;
            pop _ = move#last e;
            return@(true, move#last i)

        
        label 5:
            (i: u64) = move#last i + 1u64;
            jump 1

        
        label 6:
            pop _ = move#last v;
            pop _ = move#last e;
            return (false, 0u64)


    }
    #[]public is_empty<Element#524>(v: &vector<Element#524>): bool {
        locals:
            v: &vector<Element#524>

        loop heads:


        start=0

        label 0:
            return (std=0x1)::vector::length<Element#524>(move#last v) == 0u64


    }
    #[bytecode_instruction]public native length<Element#525>(v: &vector<Element#525>): u64;

    #[bytecode_instruction]public native pop_back<Element#528>(v: &mut vector<Element#528>): Element#528;

    #[bytecode_instruction]public native push_back<Element#529>(v: &mut vector<Element#529>, e: Element#529): ();

    #[]public remove<Element#530>(v: &mut vector<Element#530>, i: u64): Element#530 {
        locals:
            %#1: u64,
            %#2: &mut vector<Element#530>,
            i: u64,
            len: u64,
            v: &mut vector<Element#530>

        loop heads:

            4

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<Element#530>(freeze(copy v));
            jump_if(copy i >= copy len) 1 else 3

        
        label 1:
            pop _ = move#last v;
            abort EINDEX_OUT_OF_BOUNDS

        
        label 3:
            (len: u64) = move#last len - 1u64;
            jump 4

        
        label 4:
            jump_if(copy i < copy len) 5 else 6

        
        label 5:
            (%#2: &mut vector<Element#530>) = copy v;
            (%#1: u64) = copy i;
            (i: u64) = move#last i + 1u64;
            pop  = (std=0x1)::vector::swap<Element#530>((move#last %#2, move#last %#1, copy i));
            jump 4

        
        label 6:
            return (std=0x1)::vector::pop_back<Element#530>(move#last v)


    }
    #[]public reverse<Element#531>(v: &mut vector<Element#531>): () {
        locals:
            back_index: u64,
            front_index: u64,
            len: u64,
            v: &mut vector<Element#531>

        loop heads:

            4

        start=0

        label 0:
            (len: u64) = (std=0x1)::vector::length<Element#531>(freeze(copy v));
            jump_if(copy len == 0u64) 1 else 3

        
        label 1:
            pop _ = move#last v;
            return@()

        
        label 3:
            (front_index: u64) = 0u64;
            (back_index: u64) = move#last len - 1u64;
            jump 4

        
        label 4:
            jump_if(copy front_index < copy back_index) 5 else 6

        
        label 5:
            pop  = (std=0x1)::vector::swap<Element#531>((copy v, copy front_index, copy back_index));
            (front_index: u64) = move#last front_index + 1u64;
            (back_index: u64) = move#last back_index - 1u64;
            jump 4

        
        label 6:
            pop _ = move#last v;
            return /*()*/


    }
    #[]public singleton<Element#532>(e: Element#532): vector<Element#532> {
        locals:
            e: Element#532,
            v: vector<Element#532>

        loop heads:


        start=0

        label 0:
            (v: vector<Element#532>) = (std=0x1)::vector::empty<Element#532>(());
            pop  = (std=0x1)::vector::push_back<Element#532>((&mut v, move#no-copy e));
            return move#no-copy v


    }
    #[bytecode_instruction]public native swap<Element#533>(v: &mut vector<Element#533>, i: u64, j: u64): ();

    #[]public swap_remove<Element#534>(v: &mut vector<Element#534>, i: u64): Element#534 {
        locals:
            i: u64,
            last_idx: u64,
            v: &mut vector<Element#534>

        loop heads:


        start=0

        label 0:
            jump_if(! (std=0x1)::vector::is_empty<Element#534>(freeze(copy v))) 3 else 2

        
        label 2:
            pop _ = move#last v;
            abort EINDEX_OUT_OF_BOUNDS

        
        label 3:
            (last_idx: u64) = (std=0x1)::vector::length<Element#534>(freeze(copy v)) - 1u64;
            pop  = (std=0x1)::vector::swap<Element#534>((copy v, move#last i, move#last last_idx));
            return (std=0x1)::vector::pop_back<Element#534>(move#last v)


    }

}
Before expansion: program = ------ Lib Defs: ------

------ Source Defs: ------
no package
std => 0x1
module 0x42::Test {
    use std::vector;public inline fun filter<X: drop>(v: &mut vector<X>, predicate: (&X):bool): () {
        let i = 0;
        while ( {
            spec {spec {invariant forall k in 0 .. i : ! predicate(v[k])}};
            i < vector::length(v)
        }) {
            if (predicate(vector::borrow(v, i)))  {
                vector::swap_remove(v, i);

            } else  {
                i = i + 1;

            };

        }
    }public fun test_filter(): vector<u64> {
        let v = vector[1u64, 2, 3];
        filter(&mut v, |e|*e > 1);
        v
    }spec test_filter{pragma verify = false}
}
After expansion: program = module 0x42::Test {
    #[]source module
    dependency order #0
    #[]public inline fun filter<X: drop>(v: &mut vector<X>, predicate: |&X|bool): () {
        let i = 0;
        while ( {
            spec #0 uses [i, v] applies [predicate];
            i < (std=0x1)::vector::length(v)
        }) {
            if (predicate((std=0x1)::vector::borrow(v, i)))  {
                (std=0x1)::vector::swap_remove(v, i);
                /*()*/
            } else  {
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun test_filter(): vector<u64> {
        let v = vector[1u64, 2, 3];
        0x42::Test::filter(&mut v, |e|*e > 1);
        v
    }
     spec test_filter{pragma verify = false}

}
After naming: program = module 0x42::Test {
    #[]library module
    dependency order #0
    #[]public inline fun filter<X#966: drop>(v: &mut vector<X#966: drop>, predicate: |..|..<&X#966: drop, bool>): () {
        let i = 0;
        while ( {
            spec #0 uses [i, v] applies [predicate];
            i < (std=0x1)::vector::length(v)
        }) {
            if (predicate((std=0x1)::vector::borrow(v, i)))  {
                (std=0x1)::vector::swap_remove(v, i);
                /*()*/
            } else  {
                i = i + 1;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun test_filter(): vector<u64> {
        let v = vector[1u64, 2, 3];
        0x42::Test::filter(&mut v, |e|*e > 1);
        v
    }

}
After typing: program = module 0x42::Test {
    #[]library module
    dependency order #0
    #[]public fun filter!<X#966: drop>(v: &mut vector<X#966: drop>, predicate: |..|..<&X#966: drop, bool>): () {
        let i: (u64) = 0u64;
        while ( {
            spec #0 uses [i (i), predicate (predicate), v (v)];
            copy i <@u64 (std=0x1)::vector::length[parameter_types: [&vector<X#966: drop>]<X#966: drop>(copy v)
        }) {
            if (predicate((std=0x1)::vector::borrow[parameter_types: [&vector<X#966: drop>, u64]<X#966: drop>((copy v, copy i))))  {
                (std=0x1)::vector::swap_remove[parameter_types: [&mut vector<X#966: drop>, u64]<X#966: drop>((copy v, copy i));
                /*()*/
            } else  {
                i: (u64) = copy i +@u64 1u64;
                /*()*/
            };
            /*()*/
        }
    }
    #[]public fun test_filter(): vector<u64> {
        let v: (vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        0x42::Test::filter[parameter_types: [&mut vector<u64>, |..|..<&u64, bool>]<u64>((&mut v, |e|*copy e >@u64 1u64));
        copy v
    }

}
After inlining: program = module 0x42::Test {
    #[]library module
    dependency order #0
    #[]public fun test_filter(): vector<u64> {
        let v: (vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
         {
            let v#0: (&mut vector<u64>) = annot(&mut v: &mut vector<u64>);
            let i#2: (u64) = 0u64;
            while ( {
                spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate]
                lambda predicate -> test_filter_predicate_0: (e: &u64): bool {
                    *copy e >@u64 1u64
                }
                ;
                copy i#2 <@u64 (std=0x1)::vector::length[parameter_types: [&vector<u64>]<u64>(copy v#0)
            }) {
                if ( {
                    let e#3: (&u64) = (std=0x1)::vector::borrow[parameter_types: [&vector<u64>, u64]<u64>((copy v#0, copy i#2));
                    *copy e#3 >@u64 1u64
                })  {
                    (std=0x1)::vector::swap_remove[parameter_types: [&mut vector<u64>, u64]<u64>((copy v#0, copy i#2));
                    /*()*/
                } else  {
                    i#2: (u64) = copy i#2 +@u64 1u64;
                    /*()*/
                };
                /*()*/
            }
        };
        copy v
    }

}
After hlir: program = module 0x42::Test {
    #[]library module
    dependency order #0
    #[]public fun test_filter(): vector<u64> {
        locals:
            %#1: &mut vector<u64>,
            %#2: u64,
            e#3: &u64,
            i#2: u64,
            v: vector<u64>,
            v#0: &mut vector<u64>

        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        while ( {
            pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
            ;
            copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))
        }) {
            ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
            (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
            if (*copy e#3 > 1u64)  {
                pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
                pop  = /*;()*/
            } else  {
                (i#2: u64) = copy i#2 + 1u64;
                pop  = /*()*/;
                pop  = /*;()*/
            };
            pop  = /*;()*/
        };
        pop  = /*()*/;
        return copy v
    }

}
BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*copy e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = copy i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        return copy v
AFter removing critical edges, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*copy e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = copy i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        return copy v
After refine_inference_and_verify, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#3<u64>[(1u64, 2u64, 3u64)];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*move#last e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = move#last i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        pop _ = move#last v#0;
        return move#last v
After optimize, BlockCFG is --BlockCFG--
successor_map:
    0 => [1]
    1 => [2, 6]
    2 => [3, 4]
    3 => [5]
    4 => [5]
    5 => [1]
    6 => []

predecessor_map:
    0 <= []
    1 <= [0, 5]
    2 <= [1]
    3 <= [2]
    4 <= [2]
    5 <= [3, 4]
    6 <= [1]

traversal:
    0 => 1
    1 => 2
    2 => 3
    3 => 4
    4 => 5
    5 => 6

loop heads:
    loop head: 1. back edge predecessor: 5

start: 0
blocks:

    label 0:
        (v: vector<u64>) = vector#value<u64>[1u64, 2u64, 3u64];
        (v#0: &mut vector<u64>) = &mut v;
        (i#2: u64) = 0u64;
        jump 1

    
    label 1:
        pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
        ;
        jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

    
    label 2:
        ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
        (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
        jump_if(*move#last e#3 > 1u64) 3 else 4

    
    label 3:
        pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
        jump 5

    
    label 4:
        (i#2: u64) = move#last i#2 + 1u64;
        jump 5

    
    label 5:
        jump 1

    
    label 6:
        pop _ = move#last v#0;
        return move#last v
After cfgir: program = module 0x42::Test {
    #[]library module
    dependency order #0
    #[]public test_filter(): vector<u64> {
        locals:
            %#1: &mut vector<u64>,
            %#2: u64,
            e#3: &u64,
            i#2: u64,
            v: vector<u64>,
            v#0: &mut vector<u64>

        loop heads:

            1

        start=0

        label 0:
            (v: vector<u64>) = vector#value<u64>[1u64, 2u64, 3u64];
            (v#0: &mut vector<u64>) = &mut v;
            (i#2: u64) = 0u64;
            jump 1

        
        label 1:
            pop  = spec #0 from 0x42::Test::filter::#0 uses [i (i#2), v (v#0)] applies [predicate /*test_filter_predicate_0*/ ()]
            ;
            jump_if(copy i#2 < (std=0x1)::vector::length<u64>(freeze(copy v#0))) 2 else 6

        
        label 2:
            ((%#1: &mut vector<u64>), (%#2: u64)) = (copy v#0, copy i#2);
            (e#3: &u64) = (std=0x1)::vector::borrow<u64>((freeze(move#last %#1), move#last %#2));
            jump_if(*move#last e#3 > 1u64) 3 else 4

        
        label 3:
            pop _ = (std=0x1)::vector::swap_remove<u64>((copy v#0, copy i#2));
            jump 5

        
        label 4:
            (i#2: u64) = move#last i#2 + 1u64;
            jump 5

        
        label 5:
            jump 1

        
        label 6:
            pop _ = move#last v#0;
            return move#last v


    }

}
After error check, GlobalEnv=module 0x42::Test {
    use std::vector;
    public inline fun filter<X>(v: &mut vector<#0>,predicate: |&#0|bool) {
        {
          let i: u64 = 0;
          loop {
            if spec {
              invariant forall k: num: Range(0, i): Not((predicate)(Index($t0, k)));
            }
            ;
            Lt<u64>(i, vector::length<X>(v)) {
              if (predicate)(vector::borrow<X>(v, i)) {
                vector::swap_remove<X>(v, i);
                Tuple()
              } else {
                i: u64 = Add<u64>(i, 1);
                Tuple()
              };
              Tuple()
            } else {
              break
            }
          }
        }
    }
    public fun test_filter(): vector<u64> {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          Test::filter<u64>(Borrow(Mutable)(v), |e: &u64| Gt<u64>(Deref(e), 1));
          v
        }
    }
    spec fun $filter<X>(v: &mut vector<#0>,predicate: |&#0|bool);
    spec fun $test_filter(): vector<u64>;
} // end 0x42::Test

inlining function `public inline fun filter<X>(v: &mut vector<#0>,predicate: |&#0|bool) {
    {
      let i: u64 = 0;
      loop {
        if spec {
          invariant forall k: num: Range(0, i): Not((predicate)(Index($t0, k)));
        }
        ;
        Lt<u64>(i, vector::length<X>(v)) {
          if (predicate)(vector::borrow<X>(v, i)) {
            vector::swap_remove<X>(v, i);
            Tuple()
          } else {
            i: u64 = Add<u64>(i, 1);
            Tuple()
          };
          Tuple()
        } else {
          break
        }
      }
    }
}
` with args `Borrow(Mutable)(v),|e: &u64| Gt<u64>(Deref(e), 1)`
After inlining, expr is `{
  let (v: &mut vector<u64>) = Tuple(Borrow(Mutable)(v));
  {
    let i: u64 = 0;
    loop {
      if spec {
        invariant forall k: num: Range(0, i): Not((predicate)(Index($t0, k)));
      }
      ;
      Lt<u64>(i, vector::length<u64>(v)) {
        if {
          let (e: &u64) = Tuple(vector::borrow<u64>(v, i));
          Gt<u64>(Deref(e), 1)
        } {
          vector::swap_remove<u64>(v, i);
          Tuple()
        } else {
          i: u64 = Add<u64>(i, 1);
          Tuple()
        };
        Tuple()
      } else {
        break
      }
    }
  }
}`
After inlining, GlobalEnv=module 0x42::Test {
    use std::vector;
    public fun test_filter(): vector<u64> {
        {
          let v: vector<u64> = Vector<u64>(1, 2, 3);
          {
            let (v: &mut vector<u64>) = Tuple(Borrow(Mutable)(v));
            {
              let i: u64 = 0;
              loop {
                if spec {
                  invariant forall k: num: Range(0, i): Not((predicate)(Index($t0, k)));
                }
                ;
                Lt<u64>(i, vector::length<u64>(v)) {
                  if {
                    let (e: &u64) = Tuple(vector::borrow<u64>(v, i));
                    Gt<u64>(Deref(e), 1)
                  } {
                    vector::swap_remove<u64>(v, i);
                    Tuple()
                  } else {
                    i: u64 = Add<u64>(i, 1);
                    Tuple()
                  };
                  Tuple()
                } else {
                  break
                }
              }
            }
          };
          v
        }
    }
    spec fun $filter<X>(v: &mut vector<#0>,predicate: |&#0|bool);
    spec fun $test_filter(): vector<u64>;
} // end 0x42::Test

test run::inlining/inline_fun.move ... [0m[32mok[0m

test result: [0m[32mok[0m. 1 passed; 0 failed; 0 ignored; 0 measured; 114 filtered out; finished in 0.35s

